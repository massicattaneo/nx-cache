{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"],"sourcesContent":["/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').State} State\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n"],"names":["inlineCode","peek","inlineCodePeek","node","_","state","value","sequence","index","RegExp","test","unsafe","length","pattern","expression","compilePattern","match","atBreak","exec","position","charCodeAt","slice"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;;CAIC;;;;+BAUeA;;;eAAAA;;;AARhBA,WAAWC,IAAI,GAAGC;AAQX,SAASF,WAAWG,IAAI,EAAEC,CAAC,EAAEC,KAAK;IACvC,IAAIC,QAAQH,KAAKG,KAAK,IAAI;IAC1B,IAAIC,WAAW;IACf,IAAIC,QAAQ,CAAC;IAEb,2EAA2E;IAC3E,OAAO;IACP,sCAAsC;IACtC,MAAO,IAAIC,OAAO,aAAaF,WAAW,YAAYG,IAAI,CAACJ,OAAQ;QACjEC,YAAY;IACd;IAEA,wEAAwE;IACxE,2EAA2E;IAC3E,IACE,WAAWG,IAAI,CAACJ,UACf,CAAA,AAAC,WAAWI,IAAI,CAACJ,UAAU,WAAWI,IAAI,CAACJ,UAAW,QAAQI,IAAI,CAACJ,MAAK,GACzE;QACAA,QAAQ,MAAMA,QAAQ;IACxB;IAEA,6EAA6E;IAC7E,qBAAqB;IACrB,yEAAyE;IACzE,4BAA4B;IAC5B,mEAAmE;IACnE,6EAA6E;IAC7E,YAAY;IACZ,MAAO,EAAEE,QAAQH,MAAMM,MAAM,CAACC,MAAM,CAAE;QACpC,MAAMC,UAAUR,MAAMM,MAAM,CAACH,MAAM;QACnC,MAAMM,aAAaT,MAAMU,cAAc,CAACF;QACxC,mCAAmC,GACnC,IAAIG;QAEJ,4BAA4B;QAC5B,yEAAyE;QACzE,MAAM;QACN,IAAI,CAACH,QAAQI,OAAO,EAAE;QAEtB,MAAQD,QAAQF,WAAWI,IAAI,CAACZ,OAAS;YACvC,IAAIa,WAAWH,MAAMR,KAAK;YAE1B,+DAA+D;YAC/D,IACEF,MAAMc,UAAU,CAACD,cAAc,GAAG,QAAQ,OAC1Cb,MAAMc,UAAU,CAACD,WAAW,OAAO,GAAG,QAAQ,KAC9C;gBACAA;YACF;YAEAb,QAAQA,MAAMe,KAAK,CAAC,GAAGF,YAAY,MAAMb,MAAMe,KAAK,CAACL,MAAMR,KAAK,GAAG;QACrE;IACF;IAEA,OAAOD,WAAWD,QAAQC;AAC5B;AAEA;;CAEC,GACD,SAASL;IACP,OAAO;AACT"}