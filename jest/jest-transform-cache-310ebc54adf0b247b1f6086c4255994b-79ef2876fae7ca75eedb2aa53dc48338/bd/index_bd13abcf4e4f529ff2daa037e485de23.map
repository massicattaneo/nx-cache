{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/unified/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('trough').Pipeline} Pipeline\n *\n * @typedef {import('unist').Node} Node\n *\n * @typedef {import('vfile').Compatible} Compatible\n * @typedef {import('vfile').Value} Value\n *\n * @typedef {import('../index.js').CompileResultMap} CompileResultMap\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Settings} Settings\n */\n\n/**\n * @typedef {CompileResultMap[keyof CompileResultMap]} CompileResults\n *   Acceptable results from compilers.\n *\n *   To register custom results, add them to\n *   {@link CompileResultMap `CompileResultMap`}.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The node that the compiler receives (default: `Node`).\n * @template {CompileResults} [Result=CompileResults]\n *   The thing that the compiler yields (default: `CompileResults`).\n * @callback Compiler\n *   A **compiler** handles the compiling of a syntax tree to something else\n *   (in most cases, text) (TypeScript type).\n *\n *   It is used in the stringify phase and called with a {@link Node `Node`}\n *   and {@link VFile `VFile`} representation of the document to compile.\n *   It should return the textual representation of the given tree (typically\n *   `string`).\n *\n *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\n *   > return `string` (or `Uint8Array`).\n *   > Some compilers, such as the one configured with\n *   > [`rehype-react`][rehype-react], return other values (in this case, a\n *   > React tree).\n *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n *   > result values.\n *   >\n *   > To register custom results in TypeScript, add them to\n *   > {@link CompileResultMap `CompileResultMap`}.\n *\n *   [rehype-react]: https://github.com/rehypejs/rehype-react\n * @param {Tree} tree\n *   Tree to compile.\n * @param {VFile} file\n *   File associated with `tree`.\n * @returns {Result}\n *   New content: compiled text (`string` or `Uint8Array`, for `file.value`) or\n *   something else (for `file.result`).\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The node that the parser yields (default: `Node`)\n * @callback Parser\n *   A **parser** handles the parsing of text to a syntax tree.\n *\n *   It is used in the parse phase and is called with a `string` and\n *   {@link VFile `VFile`} of the document to parse.\n *   It must return the syntax tree representation of the given file\n *   ({@link Node `Node`}).\n * @param {string} document\n *   Document to parse.\n * @param {VFile} file\n *   File associated with `document`.\n * @returns {Tree}\n *   Node representing the given file.\n */\n\n/**\n * @typedef {(\n *   Plugin<Array<any>, any, any> |\n *   PluginTuple<Array<any>, any, any> |\n *   Preset\n * )} Pluggable\n *   Union of the different ways to add plugins and settings.\n */\n\n/**\n * @typedef {Array<Pluggable>} PluggableList\n *   List of plugins and presets.\n */\n\n// Note: we canâ€™t use `callback` yet as it messes up `this`:\n//  <https://github.com/microsoft/TypeScript/issues/55197>.\n/**\n * @template {Array<unknown>} [PluginParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=Node]\n *   Value that is expected as input (default: `Node`).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\n *       `string`.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\n *       node it expects.\n * @template [Output=Input]\n *   Value that is yielded as output (default: `Input`).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\n *       result it yields.\n * @typedef {(\n *   (this: Processor, ...parameters: PluginParameters) =>\n *     Input extends string ? // Parser.\n *        Output extends Node | undefined ? undefined | void : never :\n *     Output extends CompileResults ? // Compiler.\n *        Input extends Node | undefined ? undefined | void : never :\n *     Transformer<\n *       Input extends Node ? Input : Node,\n *       Output extends Node ? Output : Node\n *     > | undefined | void\n * )} Plugin\n *   Single plugin.\n *\n *   Plugins configure the processors they are applied on in the following\n *   ways:\n *\n *   *   they change the processor, such as the parser, the compiler, or by\n *       configuring data\n *   *   they specify how to handle trees and files\n *\n *   In practice, they are functions that can receive options and configure the\n *   processor (`this`).\n *\n *   > ðŸ‘‰ **Note**: plugins are called when the processor is *frozen*, not when\n *   > they are applied.\n */\n\n/**\n * Tuple of a plugin and its configuration.\n *\n * The first item is a plugin, the rest are its parameters.\n *\n * @template {Array<unknown>} [TupleParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=undefined]\n *   Value that is expected as input (optional).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\n *       `string`.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\n *       node it expects.\n * @template [Output=undefined] (optional).\n *   Value that is yielded as output.\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\n *       result it yields.\n * @typedef {(\n *   [\n *     plugin: Plugin<TupleParameters, Input, Output>,\n *     ...parameters: TupleParameters\n *   ]\n * )} PluginTuple\n */\n\n/**\n * @typedef Preset\n *   Sharable configuration.\n *\n *   They can contain plugins and settings.\n * @property {PluggableList | undefined} [plugins]\n *   List of plugins and presets (optional).\n * @property {Settings | undefined} [settings]\n *   Shared settings for parsers and compilers (optional).\n */\n\n/**\n * @template {VFile} [File=VFile]\n *   The file that the callback receives (default: `VFile`).\n * @callback ProcessCallback\n *   Callback called when the process is done.\n *\n *   Called with either an error or a result.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {File | undefined} [file]\n *   Processed file (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The tree that the callback receives (default: `Node`).\n * @callback RunCallback\n *   Callback called when transformers are done.\n *\n *   Called with either an error or results.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {Tree | undefined} [tree]\n *   Transformed tree (optional).\n * @param {VFile | undefined} [file]\n *   File (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Output=Node]\n *   Node type that the transformer yields (default: `Node`).\n * @callback TransformCallback\n *   Callback passed to transforms.\n *\n *   If the signature of a `transformer` accepts a third argument, the\n *   transformer may perform asynchronous operations, and must call it.\n * @param {Error | undefined} [error]\n *   Fatal error to stop the process (optional).\n * @param {Output | undefined} [tree]\n *   New, changed, tree (optional).\n * @param {VFile | undefined} [file]\n *   New, changed, file (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Input=Node]\n *   Node type that the transformer expects (default: `Node`).\n * @template {Node} [Output=Input]\n *   Node type that the transformer yields (default: `Input`).\n * @callback Transformer\n *   Transformers handle syntax trees and files.\n *\n *   They are functions that are called each time a syntax tree and file are\n *   passed through the run phase.\n *   When an error occurs in them (either because itâ€™s thrown, returned,\n *   rejected, or passed to `next`), the process stops.\n *\n *   The run phase is handled by [`trough`][trough], see its documentation for\n *   the exact semantics of these functions.\n *\n *   > ðŸ‘‰ **Note**: you should likely ignore `next`: donâ€™t accept it.\n *   > it supports callback-style async work.\n *   > But promises are likely easier to reason about.\n *\n *   [trough]: https://github.com/wooorm/trough#function-fninput-next\n * @param {Input} tree\n *   Tree to handle.\n * @param {VFile} file\n *   File to handle.\n * @param {TransformCallback<Output>} next\n *   Callback.\n * @returns {(\n *   Promise<Output | undefined | void> |\n *   Promise<never> | // For some reason this is needed separately.\n *   Output |\n *   Error |\n *   undefined |\n *   void\n * )}\n *   If you accept `next`, nothing.\n *   Otherwise:\n *\n *   *   `Error` â€” fatal error to stop the process\n *   *   `Promise<undefined>` or `undefined` â€” the next transformer keeps using\n *       same tree\n *   *   `Promise<Node>` or `Node` â€” new, changed, tree\n */\n\n/**\n * @template {Node | undefined} ParseTree\n *   Output of `parse`.\n * @template {Node | undefined} HeadTree\n *   Input for `run`.\n * @template {Node | undefined} TailTree\n *   Output for `run`.\n * @template {Node | undefined} CompileTree\n *   Input of `stringify`.\n * @template {CompileResults | undefined} CompileResult\n *   Output of `stringify`.\n * @template {Node | string | undefined} Input\n *   Input of plugin.\n * @template Output\n *   Output of plugin (optional).\n * @typedef {(\n *   Input extends string\n *     ? Output extends Node | undefined\n *       ? // Parser.\n *         Processor<\n *           Output extends undefined ? ParseTree : Output,\n *           HeadTree,\n *           TailTree,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Output extends CompileResults\n *     ? Input extends Node | undefined\n *       ? // Compiler.\n *         Processor<\n *           ParseTree,\n *           HeadTree,\n *           TailTree,\n *           Input extends undefined ? CompileTree : Input,\n *           Output extends undefined ? CompileResult : Output\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Input extends Node | undefined\n *     ? Output extends Node | undefined\n *       ? // Transform.\n *         Processor<\n *           ParseTree,\n *           HeadTree extends undefined ? Input : HeadTree,\n *           Output extends undefined ? TailTree : Output,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : // Unknown.\n *       Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n * )} UsePlugin\n *   Create a processor based on the input/output of a {@link Plugin plugin}.\n */\n\n/**\n * @template {CompileResults | undefined} Result\n *   Node type that the transformer yields.\n * @typedef {(\n *   Result extends Value | undefined ?\n *     VFile :\n *     VFile & {result: Result}\n *   )} VFileWithOutput\n *   Type to generate a {@link VFile `VFile`} corresponding to a compiler result.\n *\n *   If a result that is not acceptable on a `VFile` is used, that will\n *   be stored on the `result` field of {@link VFile `VFile`}.\n */\n\nimport {bail} from 'bail'\nimport extend from 'extend'\nimport {ok as assert} from 'devlop'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\nimport {CallableInstance} from './callable-instance.js'\n\n// To do: next major: drop `Compiler`, `Parser`: prefer lowercase.\n\n// To do: we could start yielding `never` in TS when a parser is missing and\n// `parse` is called.\n// Currently, we allow directly setting `processor.parser`, which is untyped.\n\nconst own = {}.hasOwnProperty\n\n/**\n * @template {Node | undefined} [ParseTree=undefined]\n *   Output of `parse` (optional).\n * @template {Node | undefined} [HeadTree=undefined]\n *   Input for `run` (optional).\n * @template {Node | undefined} [TailTree=undefined]\n *   Output for `run` (optional).\n * @template {Node | undefined} [CompileTree=undefined]\n *   Input of `stringify` (optional).\n * @template {CompileResults | undefined} [CompileResult=undefined]\n *   Output of `stringify` (optional).\n * @extends {CallableInstance<[], Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>>}\n */\nexport class Processor extends CallableInstance {\n  /**\n   * Create a processor.\n   */\n  constructor() {\n    // If `Processor()` is called (w/o new), `copy` is called instead.\n    super('copy')\n\n    /**\n     * Compiler to use (deprecated).\n     *\n     * @deprecated\n     *   Use `compiler` instead.\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */\n    this.Compiler = undefined\n\n    /**\n     * Parser to use (deprecated).\n     *\n     * @deprecated\n     *   Use `parser` instead.\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */\n    this.Parser = undefined\n\n    // Note: the following fields are considered private.\n    // However, they are needed for tests, and TSC generates an untyped\n    // `private freezeIndex` field for, which trips `type-coverage` up.\n    // Instead, we use `@deprecated` to visualize that they shouldnâ€™t be used.\n    /**\n     * Internal list of configured plugins.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Array<PluginTuple<Array<unknown>>>}\n     */\n    this.attachers = []\n\n    /**\n     * Compiler to use.\n     *\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */\n    this.compiler = undefined\n\n    /**\n     * Internal state to track where we are while freezing.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {number}\n     */\n    this.freezeIndex = -1\n\n    /**\n     * Internal state to track whether weâ€™re frozen.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {boolean | undefined}\n     */\n    this.frozen = undefined\n\n    /**\n     * Internal state.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Data}\n     */\n    this.namespace = {}\n\n    /**\n     * Parser to use.\n     *\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */\n    this.parser = undefined\n\n    /**\n     * Internal list of configured transformers.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Pipeline}\n     */\n    this.transformers = trough()\n  }\n\n  /**\n   * Copy a processor.\n   *\n   * @deprecated\n   *   This is a private internal method and should not be used.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   New *unfrozen* processor ({@link Processor `Processor`}) that is\n   *   configured to work the same as its ancestor.\n   *   When the descendant processor is configured in the future it does not\n   *   affect the ancestral processor.\n   */\n  copy() {\n    // Cast as the type parameters will be the same after attaching.\n    const destination =\n      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */ (\n        new Processor()\n      )\n    let index = -1\n\n    while (++index < this.attachers.length) {\n      const attacher = this.attachers[index]\n      destination.use(...attacher)\n    }\n\n    destination.data(extend(true, {}, this.namespace))\n\n    return destination\n  }\n\n  /**\n   * Configure the processor with info available to all plugins.\n   * Information is stored in an object.\n   *\n   * Typically, options can be given to a specific plugin, but sometimes it\n   * makes sense to have information shared with several plugins.\n   * For example, a list of HTML elements that are self-closing, which is\n   * needed during all phases.\n   *\n   * > ðŸ‘‰ **Note**: setting information cannot occur on *frozen* processors.\n   * > Call the processor first to create a new unfrozen processor.\n   *\n   * > ðŸ‘‰ **Note**: to register custom data in TypeScript, augment the\n   * > {@link Data `Data`} interface.\n   *\n   * @example\n   *   This example show how to get and set info:\n   *\n   *   ```js\n   *   import {unified} from 'unified'\n   *\n   *   const processor = unified().data('alpha', 'bravo')\n   *\n   *   processor.data('alpha') // => 'bravo'\n   *\n   *   processor.data() // => {alpha: 'bravo'}\n   *\n   *   processor.data({charlie: 'delta'})\n   *\n   *   processor.data() // => {charlie: 'delta'}\n   *   ```\n   *\n   * @template {keyof Data} Key\n   *\n   * @overload\n   * @returns {Data}\n   *\n   * @overload\n   * @param {Data} dataset\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {Key} key\n   * @returns {Data[Key]}\n   *\n   * @overload\n   * @param {Key} key\n   * @param {Data[Key]} value\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @param {Data | Key} [key]\n   *   Key to get or set, or entire dataset to set, or nothing to get the\n   *   entire dataset (optional).\n   * @param {Data[Key]} [value]\n   *   Value to set (optional).\n   * @returns {unknown}\n   *   The current processor when setting, the value at `key` when getting, or\n   *   the entire dataset when getting without key.\n   */\n  data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', this.frozen)\n        this.namespace[key] = value\n        return this\n      }\n\n      // Get `key`.\n      return (own.call(this.namespace, key) && this.namespace[key]) || undefined\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', this.frozen)\n      this.namespace = key\n      return this\n    }\n\n    // Get space.\n    return this.namespace\n  }\n\n  /**\n   * Freeze a processor.\n   *\n   * Frozen processors are meant to be extended and not to be configured\n   * directly.\n   *\n   * When a processor is frozen it cannot be unfrozen.\n   * New processors working the same way can be created by calling the\n   * processor.\n   *\n   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.\n   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,\n   * `.stringify()`, `.process()`, or `.processSync()` are called.\n   *\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   The current processor.\n   */\n  freeze() {\n    if (this.frozen) {\n      return this\n    }\n\n    // Cast so that we can type plugins easier.\n    // Plugins are supposed to be usable on different processors, not just on\n    // this exact processor.\n    const self = /** @type {Processor} */ (/** @type {unknown} */ (this))\n\n    while (++this.freezeIndex < this.attachers.length) {\n      const [attacher, ...options] = this.attachers[this.freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      const transformer = attacher.call(self, ...options)\n\n      if (typeof transformer === 'function') {\n        this.transformers.use(transformer)\n      }\n    }\n\n    this.frozen = true\n    this.freezeIndex = Number.POSITIVE_INFINITY\n\n    return this\n  }\n\n  /**\n   * Parse text to a syntax tree.\n   *\n   * > ðŸ‘‰ **Note**: `parse` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `parse` performs the parse phase, not the run phase or other\n   * > phases.\n   *\n   * @param {Compatible | undefined} [file]\n   *   file to parse (optional); typically `string` or `VFile`; any value\n   *   accepted as `x` in `new VFile(x)`.\n   * @returns {ParseTree extends undefined ? Node : ParseTree}\n   *   Syntax tree representing `file`.\n   */\n  parse(file) {\n    this.freeze()\n    const realFile = vfile(file)\n    const parser = this.parser || this.Parser\n    assertParser('parse', parser)\n    return parser(String(realFile), realFile)\n  }\n\n  /**\n   * Process the given file as configured on the processor.\n   *\n   * > ðŸ‘‰ **Note**: `process` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `process` performs the parse, run, and stringify phases.\n   *\n   * @overload\n   * @param {Compatible | undefined} file\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {Compatible | undefined} [file]\n   * @returns {Promise<VFileWithOutput<CompileResult>>}\n   *\n   * @param {Compatible | undefined} [file]\n   *   File (optional); typically `string` or `VFile`]; any value accepted as\n   *   `x` in `new VFile(x)`.\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]\n   *   Callback (optional).\n   * @returns {Promise<VFile> | undefined}\n   *   Nothing if `done` is given.\n   *   Otherwise a promise, rejected with a fatal error or resolved with the\n   *   processed file.\n   *\n   *   The parsed, transformed, and compiled value is available at\n   *   `file.value` (see note).\n   *\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\n   *   > compilers return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@link CompileResultMap `CompileResultMap`}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  process(file, done) {\n    const self = this\n\n    this.freeze()\n    assertParser('process', this.parser || this.Parser)\n    assertCompiler('process', this.compiler || this.Compiler)\n\n    return done ? executor(undefined, done) : new Promise(executor)\n\n    // Note: `void`s needed for TS.\n    /**\n     * @param {((file: VFileWithOutput<CompileResult>) => undefined | void) | undefined} resolve\n     * @param {(error: Error | undefined) => undefined | void} reject\n     * @returns {undefined}\n     */\n    function executor(resolve, reject) {\n      const realFile = vfile(file)\n      // Assume `ParseTree` (the result of the parser) matches `HeadTree` (the\n      // input of the first transform).\n      const parseTree =\n        /** @type {HeadTree extends undefined ? Node : HeadTree} */ (\n          /** @type {unknown} */ (self.parse(realFile))\n        )\n\n      self.run(parseTree, realFile, function (error, tree, file) {\n        if (error || !tree || !file) {\n          return realDone(error)\n        }\n\n        // Assume `TailTree` (the output of the last transform) matches\n        // `CompileTree` (the input of the compiler).\n        const compileTree =\n          /** @type {CompileTree extends undefined ? Node : CompileTree} */ (\n            /** @type {unknown} */ (tree)\n          )\n\n        const compileResult = self.stringify(compileTree, file)\n\n        if (looksLikeAValue(compileResult)) {\n          file.value = compileResult\n        } else {\n          file.result = compileResult\n        }\n\n        realDone(error, /** @type {VFileWithOutput<CompileResult>} */ (file))\n      })\n\n      /**\n       * @param {Error | undefined} error\n       * @param {VFileWithOutput<CompileResult> | undefined} [file]\n       * @returns {undefined}\n       */\n      function realDone(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          assert(done, '`done` is defined if `resolve` is not')\n          done(undefined, file)\n        }\n      }\n    }\n  }\n\n  /**\n   * Process the given file as configured on the processor.\n   *\n   * An error is thrown if asynchronous transforms are configured.\n   *\n   * > ðŸ‘‰ **Note**: `processSync` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `processSync` performs the parse, run, and stringify phases.\n   *\n   * @param {Compatible | undefined} [file]\n   *   File (optional); typically `string` or `VFile`; any value accepted as\n   *   `x` in `new VFile(x)`.\n   * @returns {VFileWithOutput<CompileResult>}\n   *   The processed file.\n   *\n   *   The parsed, transformed, and compiled value is available at\n   *   `file.value` (see note).\n   *\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\n   *   > compilers return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@link CompileResultMap `CompileResultMap`}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  processSync(file) {\n    /** @type {boolean} */\n    let complete = false\n    /** @type {VFileWithOutput<CompileResult> | undefined} */\n    let result\n\n    this.freeze()\n    assertParser('processSync', this.parser || this.Parser)\n    assertCompiler('processSync', this.compiler || this.Compiler)\n\n    this.process(file, realDone)\n    assertDone('processSync', 'process', complete)\n    assert(result, 'we either bailed on an error or have a tree')\n\n    return result\n\n    /**\n     * @type {ProcessCallback<VFileWithOutput<CompileResult>>}\n     */\n    function realDone(error, file) {\n      complete = true\n      bail(error)\n      result = file\n    }\n  }\n\n  /**\n   * Run *transformers* on a syntax tree.\n   *\n   * > ðŸ‘‰ **Note**: `run` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `run` performs the run phase, not other phases.\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {Compatible | undefined} file\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {Compatible | undefined} [file]\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}\n   *\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   *   Tree to transform and inspect.\n   * @param {(\n   *   RunCallback<TailTree extends undefined ? Node : TailTree> |\n   *   Compatible\n   * )} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]\n   *   Callback (optional).\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}\n   *   Nothing if `done` is given.\n   *   Otherwise, a promise rejected with a fatal error or resolved with the\n   *   transformed tree.\n   */\n  run(tree, file, done) {\n    assertNode(tree)\n    this.freeze()\n\n    const transformers = this.transformers\n\n    if (!done && typeof file === 'function') {\n      done = file\n      file = undefined\n    }\n\n    return done ? executor(undefined, done) : new Promise(executor)\n\n    // Note: `void`s needed for TS.\n    /**\n     * @param {(\n     *   ((tree: TailTree extends undefined ? Node : TailTree) => undefined | void) |\n     *   undefined\n     * )} resolve\n     * @param {(error: Error) => undefined | void} reject\n     * @returns {undefined}\n     */\n    function executor(resolve, reject) {\n      assert(\n        typeof file !== 'function',\n        '`file` canâ€™t be a `done` anymore, we checked'\n      )\n      const realFile = vfile(file)\n      transformers.run(tree, realFile, realDone)\n\n      /**\n       * @param {Error | undefined} error\n       * @param {Node} outputTree\n       * @param {VFile} file\n       * @returns {undefined}\n       */\n      function realDone(error, outputTree, file) {\n        const resultingTree =\n          /** @type {TailTree extends undefined ? Node : TailTree} */ (\n            outputTree || tree\n          )\n\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(resultingTree)\n        } else {\n          assert(done, '`done` is defined if `resolve` is not')\n          done(undefined, resultingTree, file)\n        }\n      }\n    }\n  }\n\n  /**\n   * Run *transformers* on a syntax tree.\n   *\n   * An error is thrown if asynchronous transforms are configured.\n   *\n   * > ðŸ‘‰ **Note**: `runSync` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `runSync` performs the run phase, not other phases.\n   *\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   *   Tree to transform and inspect.\n   * @param {Compatible | undefined} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @returns {TailTree extends undefined ? Node : TailTree}\n   *   Transformed tree.\n   */\n  runSync(tree, file) {\n    /** @type {boolean} */\n    let complete = false\n    /** @type {(TailTree extends undefined ? Node : TailTree) | undefined} */\n    let result\n\n    this.run(tree, file, realDone)\n\n    assertDone('runSync', 'run', complete)\n    assert(result, 'we either bailed on an error or have a tree')\n    return result\n\n    /**\n     * @type {RunCallback<TailTree extends undefined ? Node : TailTree>}\n     */\n    function realDone(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * Compile a syntax tree.\n   *\n   * > ðŸ‘‰ **Note**: `stringify` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `stringify` performs the stringify phase, not the run phase\n   * > or other phases.\n   *\n   * @param {CompileTree extends undefined ? Node : CompileTree} tree\n   *   Tree to compile.\n   * @param {Compatible | undefined} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @returns {CompileResult extends undefined ? Value : CompileResult}\n   *   Textual representation of the tree (see note).\n   *\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\n   *   > return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@link CompileResultMap `CompileResultMap`}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  stringify(tree, file) {\n    this.freeze()\n    const realFile = vfile(file)\n    const compiler = this.compiler || this.Compiler\n    assertCompiler('stringify', compiler)\n    assertNode(tree)\n\n    return compiler(tree, realFile)\n  }\n\n  /**\n   * Configure the processor to use a plugin, a list of usable values, or a\n   * preset.\n   *\n   * If the processor is already using a plugin, the previous plugin\n   * configuration is changed based on the options that are passed in.\n   * In other words, the plugin is not added a second time.\n   *\n   * > ðŸ‘‰ **Note**: `use` cannot be called on *frozen* processors.\n   * > Call the processor first to create a new unfrozen processor.\n   *\n   * @example\n   *   There are many ways to pass plugins to `.use()`.\n   *   This example gives an overview:\n   *\n   *   ```js\n   *   import {unified} from 'unified'\n   *\n   *   unified()\n   *     // Plugin with options:\n   *     .use(pluginA, {x: true, y: true})\n   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n   *     .use(pluginA, {y: false, z: true})\n   *     // Plugins:\n   *     .use([pluginB, pluginC])\n   *     // Two plugins, the second with options:\n   *     .use([pluginD, [pluginE, {}]])\n   *     // Preset with plugins and settings:\n   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n   *     // Settings only:\n   *     .use({settings: {position: false}})\n   *   ```\n   *\n   * @template {Array<unknown>} [Parameters=[]]\n   * @template {Node | string | undefined} [Input=undefined]\n   * @template [Output=Input]\n   *\n   * @overload\n   * @param {Preset | null | undefined} [preset]\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {PluggableList} list\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {Plugin<Parameters, Input, Output>} plugin\n   * @param {...(Parameters | [boolean])} parameters\n   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}\n   *\n   * @param {PluggableList | Plugin | Preset | null | undefined} value\n   *   Usable value.\n   * @param {...unknown} parameters\n   *   Parameters, when a plugin is given as a usable value.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   Current processor.\n   */\n  use(value, ...parameters) {\n    const attachers = this.attachers\n    const namespace = this.namespace\n\n    assertUnfrozen('use', this.frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, parameters)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    return this\n\n    /**\n     * @param {Pluggable} value\n     * @returns {undefined}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value, [])\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...parameters] =\n            /** @type {PluginTuple<Array<unknown>>} */ (value)\n          addPlugin(plugin, parameters)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {undefined}\n     */\n    function addPreset(result) {\n      if (!('plugins' in result) && !('settings' in result)) {\n        throw new Error(\n          'Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither'\n        )\n      }\n\n      addList(result.plugins)\n\n      if (result.settings) {\n        namespace.settings = extend(true, namespace.settings, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList | null | undefined} plugins\n     * @returns {undefined}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {Array<unknown>} parameters\n     * @returns {undefined}\n     */\n    function addPlugin(plugin, parameters) {\n      let index = -1\n      let entryIndex = -1\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entryIndex = index\n          break\n        }\n      }\n\n      if (entryIndex === -1) {\n        attachers.push([plugin, ...parameters])\n      }\n      // Only set if there was at least a `primary` value, otherwise weâ€™d change\n      // `arguments.length`.\n      else if (parameters.length > 0) {\n        let [primary, ...rest] = parameters\n        const currentPrimary = attachers[entryIndex][1]\n        if (isPlainObj(currentPrimary) && isPlainObj(primary)) {\n          primary = extend(true, currentPrimary, primary)\n        }\n\n        attachers[entryIndex] = [plugin, primary, ...rest]\n      }\n    }\n  }\n}\n\n// Note: this returns a *callable* instance.\n// Thatâ€™s why itâ€™s documented as a function.\n/**\n * Create a new processor.\n *\n * @example\n *   This example shows how a new processor can be created (from `remark`) and linked\n *   to **stdin**(4) and **stdout**(4).\n *\n *   ```js\n *   import process from 'node:process'\n *   import concatStream from 'concat-stream'\n *   import {remark} from 'remark'\n *\n *   process.stdin.pipe(\n *     concatStream(function (buf) {\n *       process.stdout.write(String(remark().processSync(buf)))\n *     })\n *   )\n *   ```\n *\n * @returns\n *   New *unfrozen* processor (`processor`).\n *\n *   This processor is configured to work the same as its ancestor.\n *   When the descendant processor is configured in the future it does not\n *   affect the ancestral processor.\n */\nexport const unified = new Processor().freeze()\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {Compatible | undefined} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {Compatible | undefined} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is Value}\n */\nfunction looksLikeAValue(value) {\n  return typeof value === 'string' || isUint8Array(value)\n}\n\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */\nfunction isUint8Array(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'byteLength' in value &&\n      'byteOffset' in value\n  )\n}\n"],"names":["Processor","unified","own","hasOwnProperty","CallableInstance","copy","destination","index","attachers","length","attacher","use","data","extend","namespace","key","value","arguments","assertUnfrozen","frozen","call","undefined","freeze","self","freezeIndex","options","transformer","transformers","Number","POSITIVE_INFINITY","parse","file","realFile","vfile","parser","Parser","assertParser","String","process","done","assertCompiler","compiler","Compiler","executor","Promise","resolve","reject","parseTree","run","error","tree","realDone","compileTree","compileResult","stringify","looksLikeAValue","result","assert","processSync","complete","assertDone","bail","assertNode","outputTree","resultingTree","runSync","parameters","addPlugin","Array","isArray","addList","addPreset","TypeError","add","plugin","Error","plugins","settings","thing","entryIndex","push","primary","rest","currentPrimary","isPlainObj","constructor","trough","name","node","type","asyncName","looksLikeAVFile","VFile","Boolean","isUint8Array"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}