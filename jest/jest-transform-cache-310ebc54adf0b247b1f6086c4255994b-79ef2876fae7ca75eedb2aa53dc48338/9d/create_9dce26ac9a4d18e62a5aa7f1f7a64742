09227dd775ac5b970b344e33410c27b7
/**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 *
 * @typedef {Record<string, string>} Attributes
 *
 * @typedef {Object} Definition
 * @property {Record<string, number|null>} properties
 * @property {(attributes: Attributes, property: string) => string} transform
 * @property {string} [space]
 * @property {Attributes} [attributes]
 * @property {Array<string>} [mustUseProperty]
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "create", {
    enumerable: true,
    get: function() {
        return create;
    }
});
const _normalize = require("../normalize.js");
const _schema = require("./schema.js");
const _definedinfo = require("./defined-info.js");
const own = {}.hasOwnProperty;
function create(definition) {
    /** @type {Properties} */ const property = {};
    /** @type {Normal} */ const normal = {};
    /** @type {string} */ let prop;
    for(prop in definition.properties){
        if (own.call(definition.properties, prop)) {
            const value = definition.properties[prop];
            const info = new _definedinfo.DefinedInfo(prop, definition.transform(definition.attributes || {}, prop), value, definition.space);
            if (definition.mustUseProperty && definition.mustUseProperty.includes(prop)) {
                info.mustUseProperty = true;
            }
            property[prop] = info;
            normal[(0, _normalize.normalize)(prop)] = prop;
            normal[(0, _normalize.normalize)(info.attribute)] = prop;
        }
    }
    return new _schema.Schema(property, normal, definition.space);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1pbmZvcm1hdGlvbi9saWIvdXRpbC9jcmVhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NjaGVtYS5qcycpLlByb3BlcnRpZXN9IFByb3BlcnRpZXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2NoZW1hLmpzJykuTm9ybWFsfSBOb3JtYWxcbiAqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gQXR0cmlidXRlc1xuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgbnVtYmVyfG51bGw+fSBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHkgeyhhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVzLCBwcm9wZXJ0eTogc3RyaW5nKSA9PiBzdHJpbmd9IHRyYW5zZm9ybVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzcGFjZV1cbiAqIEBwcm9wZXJ0eSB7QXR0cmlidXRlc30gW2F0dHJpYnV0ZXNdXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFttdXN0VXNlUHJvcGVydHldXG4gKi9cblxuaW1wb3J0IHtub3JtYWxpemV9IGZyb20gJy4uL25vcm1hbGl6ZS5qcydcbmltcG9ydCB7U2NoZW1hfSBmcm9tICcuL3NjaGVtYS5qcydcbmltcG9ydCB7RGVmaW5lZEluZm99IGZyb20gJy4vZGVmaW5lZC1pbmZvLmpzJ1xuXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vKipcbiAqIEBwYXJhbSB7RGVmaW5pdGlvbn0gZGVmaW5pdGlvblxuICogQHJldHVybnMge1NjaGVtYX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShkZWZpbml0aW9uKSB7XG4gIC8qKiBAdHlwZSB7UHJvcGVydGllc30gKi9cbiAgY29uc3QgcHJvcGVydHkgPSB7fVxuICAvKiogQHR5cGUge05vcm1hbH0gKi9cbiAgY29uc3Qgbm9ybWFsID0ge31cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBwcm9wXG5cbiAgZm9yIChwcm9wIGluIGRlZmluaXRpb24ucHJvcGVydGllcykge1xuICAgIGlmIChvd24uY2FsbChkZWZpbml0aW9uLnByb3BlcnRpZXMsIHByb3ApKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRlZmluaXRpb24ucHJvcGVydGllc1twcm9wXVxuICAgICAgY29uc3QgaW5mbyA9IG5ldyBEZWZpbmVkSW5mbyhcbiAgICAgICAgcHJvcCxcbiAgICAgICAgZGVmaW5pdGlvbi50cmFuc2Zvcm0oZGVmaW5pdGlvbi5hdHRyaWJ1dGVzIHx8IHt9LCBwcm9wKSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRlZmluaXRpb24uc3BhY2VcbiAgICAgIClcblxuICAgICAgaWYgKFxuICAgICAgICBkZWZpbml0aW9uLm11c3RVc2VQcm9wZXJ0eSAmJlxuICAgICAgICBkZWZpbml0aW9uLm11c3RVc2VQcm9wZXJ0eS5pbmNsdWRlcyhwcm9wKVxuICAgICAgKSB7XG4gICAgICAgIGluZm8ubXVzdFVzZVByb3BlcnR5ID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBwcm9wZXJ0eVtwcm9wXSA9IGluZm9cblxuICAgICAgbm9ybWFsW25vcm1hbGl6ZShwcm9wKV0gPSBwcm9wXG4gICAgICBub3JtYWxbbm9ybWFsaXplKGluZm8uYXR0cmlidXRlKV0gPSBwcm9wXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEocHJvcGVydHksIG5vcm1hbCwgZGVmaW5pdGlvbi5zcGFjZSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJvd24iLCJoYXNPd25Qcm9wZXJ0eSIsImRlZmluaXRpb24iLCJwcm9wZXJ0eSIsIm5vcm1hbCIsInByb3AiLCJwcm9wZXJ0aWVzIiwiY2FsbCIsInZhbHVlIiwiaW5mbyIsIkRlZmluZWRJbmZvIiwidHJhbnNmb3JtIiwiYXR0cmlidXRlcyIsInNwYWNlIiwibXVzdFVzZVByb3BlcnR5IiwiaW5jbHVkZXMiLCJub3JtYWxpemUiLCJhdHRyaWJ1dGUiLCJTY2hlbWEiXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztDQVlDOzs7OytCQVllQTs7O2VBQUFBOzs7MkJBVlE7d0JBQ0g7NkJBQ0s7QUFFMUIsTUFBTUMsTUFBTSxDQUFDLEVBQUVDLGNBQWM7QUFNdEIsU0FBU0YsT0FBT0csVUFBVTtJQUMvQix1QkFBdUIsR0FDdkIsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLG1CQUFtQixHQUNuQixNQUFNQyxTQUFTLENBQUM7SUFDaEIsbUJBQW1CLEdBQ25CLElBQUlDO0lBRUosSUFBS0EsUUFBUUgsV0FBV0ksVUFBVSxDQUFFO1FBQ2xDLElBQUlOLElBQUlPLElBQUksQ0FBQ0wsV0FBV0ksVUFBVSxFQUFFRCxPQUFPO1lBQ3pDLE1BQU1HLFFBQVFOLFdBQVdJLFVBQVUsQ0FBQ0QsS0FBSztZQUN6QyxNQUFNSSxPQUFPLElBQUlDLHdCQUFXLENBQzFCTCxNQUNBSCxXQUFXUyxTQUFTLENBQUNULFdBQVdVLFVBQVUsSUFBSSxDQUFDLEdBQUdQLE9BQ2xERyxPQUNBTixXQUFXVyxLQUFLO1lBR2xCLElBQ0VYLFdBQVdZLGVBQWUsSUFDMUJaLFdBQVdZLGVBQWUsQ0FBQ0MsUUFBUSxDQUFDVixPQUNwQztnQkFDQUksS0FBS0ssZUFBZSxHQUFHO1lBQ3pCO1lBRUFYLFFBQVEsQ0FBQ0UsS0FBSyxHQUFHSTtZQUVqQkwsTUFBTSxDQUFDWSxJQUFBQSxvQkFBUyxFQUFDWCxNQUFNLEdBQUdBO1lBQzFCRCxNQUFNLENBQUNZLElBQUFBLG9CQUFTLEVBQUNQLEtBQUtRLFNBQVMsRUFBRSxHQUFHWjtRQUN0QztJQUNGO0lBRUEsT0FBTyxJQUFJYSxjQUFNLENBQUNmLFVBQVVDLFFBQVFGLFdBQVdXLEtBQUs7QUFDdEQifQ==