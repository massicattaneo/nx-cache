93b2a0247059b1a0a5e1ec87ccdf7fbd
// Packages
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Datepicker", {
    enumerable: true,
    get: function() {
        return Datepicker;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reactdatepicker = /*#__PURE__*/ _interop_require_wildcard(require("react-datepicker"));
const _core = require("@rp/react/web/mui/core");
const _Datepickerstyle = require("./Datepicker.style");
const _TriangleArrow = require("./TriangleArrow");
const _formatDateRange = require("./utils/formatDateRange");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
const Datepicker = ({ onSubmit, options, date, defaultOption, open = false, onClose, hideInput = false, withRangeList = true, monthsToShown = 2 })=>{
    const initialDate = date !== null && date !== void 0 ? date : options[defaultOption];
    const [startDate, setStartDate] = (0, _react.useState)(new Date(initialDate.start));
    const [endDate, setEndDate] = (0, _react.useState)(new Date(initialDate.end));
    const [isOpen, setIsOpen] = (0, _react.useState)(false);
    /* Input labels */ const optionIndex = Object.values(options).findIndex((option)=>option.start === initialDate.start && option.end === initialDate.end);
    const [selectedIndex, setSelectedIndex] = (0, _react.useState)(optionIndex);
    const [inputLabel, setInputLabel] = (0, _react.useState)(initialDate.label);
    const handleClose = (0, _react.useCallback)(()=>{
        setIsOpen(false);
        setStartDate(new Date(initialDate.start));
        setEndDate(new Date(initialDate.end));
        setInputLabel(initialDate.label);
        setSelectedIndex(optionIndex);
        onClose && onClose();
    }, [
        initialDate.start,
        initialDate.end,
        initialDate.label,
        optionIndex,
        onClose
    ]);
    const handleSubmit = ()=>{
        /* Setting input label */ if (startDate) {
            /* User select only start date -> set endingDate as startDate   */ if (!endDate) {
                setEndDate(startDate);
                handleApply(startDate, startDate, (0, _formatDateRange.formatDateLabel)(startDate, startDate));
            } else {
                handleApply(startDate, endDate, (0, _formatDateRange.formatDateLabel)(startDate, endDate));
            }
            setIsOpen(false);
        }
    };
    const handleApply = (start, end, label)=>{
        const { start: formattedStart, end: formattedEnd } = (0, _formatDateRange.formatDatesForQuery)({
            startDate: start,
            endDate: end
        });
        setInputLabel(label);
        onSubmit({
            type: "date",
            value: [
                formattedStart,
                formattedEnd
            ]
        });
    };
    const handleChange = (date)=>{
        if (Array.isArray(date)) {
            const [start, end] = date;
            setStartDate(start);
            setEndDate(end);
            setSelectedIndex(null);
        }
    };
    /* Calendar wrapper */ const Container = ({ className, children })=>{
        const handleSelect = ({ optionId, index })=>{
            const { start, end, label } = options[optionId];
            setStartDate(start);
            setEndDate(end);
            setSelectedIndex(index);
            setInputLabel(label);
            onSubmit({
                type: "date",
                value: optionId
            });
            setIsOpen(false);
        };
        // Close Datepicker on ESC key press
        (0, _react.useEffect)(()=>{
            const closeOnEsc = (e)=>{
                if (e.key === "Escape") {
                    handleClose();
                }
            };
            document.addEventListener("keydown", closeOnEsc);
            return ()=>document.removeEventListener("keydown", closeOnEsc);
        }, []);
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
            className: _Datepickerstyle.classes.container,
            children: [
                withRangeList && /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsxs)(_core.List, {
                            component: "nav",
                            "aria-label": "dates-threshold ",
                            children: [
                                /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                    className: _Datepickerstyle.classes.title,
                                    children: "Specific"
                                }),
                                Object.entries(options).map(([id, value], index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_core.ListItemButton, {
                                        className: _Datepickerstyle.classes.listItem,
                                        selected: index === selectedIndex,
                                        onClick: ()=>handleSelect({
                                                optionId: id,
                                                index
                                            }),
                                        children: value.label
                                    }, id))
                            ]
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_core.Divider, {
                            sx: {
                                margin: "0 20px",
                                color: "white"
                            },
                            orientation: "vertical",
                            flexItem: true
                        })
                    ]
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    className: _Datepickerstyle.classes.right,
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                            children: [
                                /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                    className: _Datepickerstyle.classes.title,
                                    children: "Custom"
                                }),
                                /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactdatepicker.CalendarContainer, {
                                    className: className,
                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                        style: {
                                            position: "relative"
                                        },
                                        children: children
                                    })
                                })
                            ]
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                            className: _Datepickerstyle.classes.buttons,
                            children: [
                                /*#__PURE__*/ (0, _jsxruntime.jsx)(_core.Button, {
                                    onClick: handleClose,
                                    children: "Cancel"
                                }),
                                /*#__PURE__*/ (0, _jsxruntime.jsx)(_core.Button, {
                                    disabled: Boolean(!startDate),
                                    onClick: handleSubmit,
                                    children: "Apply"
                                })
                            ]
                        })
                    ]
                })
            ]
        });
    };
    const ReactDatePickerInput = /*#__PURE__*/ _react.default.forwardRef((_param, ref)=>{
        var { onClick } = _param, props = _object_without_properties(_param, [
            "onClick"
        ]);
        const handleInput = isOpen ? handleClose : onClick;
        if (hideInput) return null;
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)("button", _object_spread_props(_object_spread({
            type: "button",
            ref: ref
        }, props), {
            onClick: handleInput,
            children: [
                inputLabel,
                /*#__PURE__*/ (0, _jsxruntime.jsx)(_TriangleArrow.TriangleArrow, {
                    isOpen: isOpen
                })
            ]
        }));
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_Datepickerstyle.DatePickerStyled, {
        className: _Datepickerstyle.classes.input,
        children: [
            !hideInput && /*#__PURE__*/ (0, _jsxruntime.jsx)(_core.Typography, {
                variant: "body2",
                children: "Date:"
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactdatepicker.default, {
                open: open ? open : isOpen,
                onInputClick: ()=>setIsOpen(true),
                onClickOutside: handleClose,
                className: _Datepickerstyle.classes.datepicker,
                focusSelectedMonth: true,
                selected: startDate,
                startDate: startDate,
                endDate: endDate,
                onChange: handleChange,
                monthsShown: monthsToShown,
                dateFormat: "MMMM dd, yyyy",
                shouldCloseOnSelect: false,
                calendarStartDay: 1,
                calendarContainer: Container,
                customInput: /*#__PURE__*/ (0, _jsxruntime.jsx)(ReactDatePickerInput, {}),
                maxDate: new Date(),
                disabledKeyboardNavigation: true,
                selectsRange: true,
                popperPlacement: "bottom",
                openToDate: (0, _formatDateRange.openToDate)(endDate)
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_Datepickerstyle.DatePickerOverlay, {
                isOpen: isOpen
            })
        ]
    });
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL2xpYnMvcmVhY3Qvd2ViL2NvbW1vbi9jb21wb3NpdGUtY29tcG9uZW50cy9zcmMvRGF0ZXBpY2tlci9EYXRlcGlja2VyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQYWNrYWdlc1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCBEYXRlUGlja2VyLCB7IENhbGVuZGFyQ29udGFpbmVyIH0gZnJvbSBcInJlYWN0LWRhdGVwaWNrZXJcIlxuaW1wb3J0IHsgUnBxbERhdGVGaWx0ZXIgfSBmcm9tIFwiQHJwL2NvbW1vbi9hcGktdHlwZXNcIlxuLy8gQ29tcG9uZW50c1xuaW1wb3J0IHsgQnV0dG9uLCBEaXZpZGVyLCBMaXN0LCBMaXN0SXRlbUJ1dHRvbiwgVHlwb2dyYXBoeSB9IGZyb20gXCJAcnAvcmVhY3Qvd2ViL211aS9jb3JlXCJcbi8vIFN0eWxlc1xuaW1wb3J0IHsgRGF0ZVBpY2tlck92ZXJsYXksIERhdGVQaWNrZXJTdHlsZWQsIGNsYXNzZXMgfSBmcm9tIFwiLi9EYXRlcGlja2VyLnN0eWxlXCJcbmltcG9ydCB7IFRyaWFuZ2xlQXJyb3cgfSBmcm9tIFwiLi9UcmlhbmdsZUFycm93XCJcbi8vIFV0aWxcbmltcG9ydCB7XG4gIERhdGVQaWNrZXJPcHRpb25zLFxuICBJbml0aWFsRGF0ZXMsXG4gIGZvcm1hdERhdGVMYWJlbCxcbiAgZm9ybWF0RGF0ZXNGb3JRdWVyeSxcbiAgb3BlblRvRGF0ZSxcbn0gZnJvbSBcIi4vdXRpbHMvZm9ybWF0RGF0ZVJhbmdlXCJcblxuY29uc3QgRGF0ZXBpY2tlciA9IDxUIGV4dGVuZHMgRGF0ZVBpY2tlck9wdGlvbnM+KHtcbiAgb25TdWJtaXQsXG4gIG9wdGlvbnMsXG4gIGRhdGUsXG4gIGRlZmF1bHRPcHRpb24sXG4gIG9wZW4gPSBmYWxzZSxcbiAgb25DbG9zZSxcbiAgaGlkZUlucHV0ID0gZmFsc2UsXG4gIHdpdGhSYW5nZUxpc3QgPSB0cnVlLFxuICBtb250aHNUb1Nob3duID0gMixcbn06IHtcbiAgb25TdWJtaXQ6IChkYXRlOiBScHFsRGF0ZUZpbHRlcikgPT4gdm9pZFxuICBvcHRpb25zOiBUXG4gIGRlZmF1bHRPcHRpb246IGtleW9mIFRcbiAgZGF0ZTogSW5pdGlhbERhdGVzIHwgbnVsbFxuICBvcGVuPzogYm9vbGVhblxuICBvbkNsb3NlPzogKCkgPT4gdm9pZFxuICBoaWRlSW5wdXQ/OiBib29sZWFuXG4gIHdpdGhSYW5nZUxpc3Q/OiBib29sZWFuXG4gIG1vbnRoc1RvU2hvd24/OiBudW1iZXJcbn0pID0+IHtcbiAgY29uc3QgaW5pdGlhbERhdGUgPSBkYXRlID8/IG9wdGlvbnNbZGVmYXVsdE9wdGlvbl1cblxuICBjb25zdCBbc3RhcnREYXRlLCBzZXRTdGFydERhdGVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG5ldyBEYXRlKGluaXRpYWxEYXRlLnN0YXJ0KSlcbiAgY29uc3QgW2VuZERhdGUsIHNldEVuZERhdGVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG5ldyBEYXRlKGluaXRpYWxEYXRlLmVuZCkpXG4gIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICAvKiBJbnB1dCBsYWJlbHMgKi9cbiAgY29uc3Qgb3B0aW9uSW5kZXggPSBPYmplY3QudmFsdWVzKG9wdGlvbnMpLmZpbmRJbmRleChcbiAgICBvcHRpb24gPT4gb3B0aW9uLnN0YXJ0ID09PSBpbml0aWFsRGF0ZS5zdGFydCAmJiBvcHRpb24uZW5kID09PSBpbml0aWFsRGF0ZS5lbmQsXG4gIClcblxuICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihvcHRpb25JbmRleClcbiAgY29uc3QgW2lucHV0TGFiZWwsIHNldElucHV0TGFiZWxdID0gdXNlU3RhdGU8c3RyaW5nPihpbml0aWFsRGF0ZS5sYWJlbClcblxuICBjb25zdCBoYW5kbGVDbG9zZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJc09wZW4oZmFsc2UpXG4gICAgc2V0U3RhcnREYXRlKG5ldyBEYXRlKGluaXRpYWxEYXRlLnN0YXJ0KSlcbiAgICBzZXRFbmREYXRlKG5ldyBEYXRlKGluaXRpYWxEYXRlLmVuZCkpXG4gICAgc2V0SW5wdXRMYWJlbChpbml0aWFsRGF0ZS5sYWJlbClcbiAgICBzZXRTZWxlY3RlZEluZGV4KG9wdGlvbkluZGV4KVxuICAgIG9uQ2xvc2UgJiYgb25DbG9zZSgpXG4gIH0sIFtpbml0aWFsRGF0ZS5zdGFydCwgaW5pdGlhbERhdGUuZW5kLCBpbml0aWFsRGF0ZS5sYWJlbCwgb3B0aW9uSW5kZXgsIG9uQ2xvc2VdKVxuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9ICgpID0+IHtcbiAgICAvKiBTZXR0aW5nIGlucHV0IGxhYmVsICovXG4gICAgaWYgKHN0YXJ0RGF0ZSkge1xuICAgICAgLyogVXNlciBzZWxlY3Qgb25seSBzdGFydCBkYXRlIC0+IHNldCBlbmRpbmdEYXRlIGFzIHN0YXJ0RGF0ZSAgICovXG4gICAgICBpZiAoIWVuZERhdGUpIHtcbiAgICAgICAgc2V0RW5kRGF0ZShzdGFydERhdGUpXG4gICAgICAgIGhhbmRsZUFwcGx5KHN0YXJ0RGF0ZSwgc3RhcnREYXRlLCBmb3JtYXREYXRlTGFiZWwoc3RhcnREYXRlLCBzdGFydERhdGUpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlQXBwbHkoc3RhcnREYXRlLCBlbmREYXRlLCBmb3JtYXREYXRlTGFiZWwoc3RhcnREYXRlLCBlbmREYXRlKSlcbiAgICAgIH1cbiAgICAgIHNldElzT3BlbihmYWxzZSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBoYW5kbGVBcHBseSA9IChzdGFydDogRGF0ZSwgZW5kOiBEYXRlLCBsYWJlbDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgeyBzdGFydDogZm9ybWF0dGVkU3RhcnQsIGVuZDogZm9ybWF0dGVkRW5kIH0gPSBmb3JtYXREYXRlc0ZvclF1ZXJ5KHtcbiAgICAgIHN0YXJ0RGF0ZTogc3RhcnQsXG4gICAgICBlbmREYXRlOiBlbmQsXG4gICAgfSlcblxuICAgIHNldElucHV0TGFiZWwobGFiZWwpXG4gICAgb25TdWJtaXQoeyB0eXBlOiBcImRhdGVcIiwgdmFsdWU6IFtmb3JtYXR0ZWRTdGFydCwgZm9ybWF0dGVkRW5kXSB9KVxuICB9XG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChkYXRlOiBEYXRlIHwgW0RhdGUgfCBudWxsLCBEYXRlIHwgbnVsbF0gfCBudWxsKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0ZSkpIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IGRhdGVcbiAgICAgIHNldFN0YXJ0RGF0ZShzdGFydClcbiAgICAgIHNldEVuZERhdGUoZW5kKVxuICAgICAgc2V0U2VsZWN0ZWRJbmRleChudWxsKVxuICAgIH1cbiAgfVxuXG4gIC8qIENhbGVuZGFyIHdyYXBwZXIgKi9cbiAgY29uc3QgQ29udGFpbmVyID0gKHtcbiAgICBjbGFzc05hbWUsXG4gICAgY2hpbGRyZW4sXG4gIH06IHtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmdcbiAgICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZVxuICB9KSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU2VsZWN0ID0gKHsgb3B0aW9uSWQsIGluZGV4IH06IHsgb3B0aW9uSWQ6IHN0cmluZzsgaW5kZXg6IG51bWJlciB9KSA9PiB7XG4gICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIGxhYmVsIH0gPSBvcHRpb25zW29wdGlvbklkXVxuICAgICAgc2V0U3RhcnREYXRlKHN0YXJ0KVxuICAgICAgc2V0RW5kRGF0ZShlbmQpXG4gICAgICBzZXRTZWxlY3RlZEluZGV4KGluZGV4KVxuICAgICAgc2V0SW5wdXRMYWJlbChsYWJlbClcbiAgICAgIG9uU3VibWl0KHsgdHlwZTogXCJkYXRlXCIsIHZhbHVlOiBvcHRpb25JZCB9KVxuICAgICAgc2V0SXNPcGVuKGZhbHNlKVxuICAgIH1cblxuICAgIC8vIENsb3NlIERhdGVwaWNrZXIgb24gRVNDIGtleSBwcmVzc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBjbG9zZU9uRXNjID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgaGFuZGxlQ2xvc2UoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNsb3NlT25Fc2MpXG5cbiAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBjbG9zZU9uRXNjKVxuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmNvbnRhaW5lcn0+XG4gICAgICAgIHt3aXRoUmFuZ2VMaXN0ICYmIChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPExpc3QgY29tcG9uZW50PVwibmF2XCIgYXJpYS1sYWJlbD1cImRhdGVzLXRocmVzaG9sZCBcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXMudGl0bGV9PlNwZWNpZmljPC9kaXY+XG4gICAgICAgICAgICAgIHtPYmplY3QuZW50cmllcyhvcHRpb25zKS5tYXAoKFtpZCwgdmFsdWVdLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgIDxMaXN0SXRlbUJ1dHRvblxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzLmxpc3RJdGVtfVxuICAgICAgICAgICAgICAgICAga2V5PXtpZH1cbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtpbmRleCA9PT0gc2VsZWN0ZWRJbmRleH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZVNlbGVjdCh7IG9wdGlvbklkOiBpZCwgaW5kZXggfSl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3ZhbHVlLmxhYmVsfVxuICAgICAgICAgICAgICAgIDwvTGlzdEl0ZW1CdXR0b24+XG4gICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC9MaXN0PlxuICAgICAgICAgICAgPERpdmlkZXIgc3g9e3sgbWFyZ2luOiBcIjAgMjBweFwiLCBjb2xvcjogXCJ3aGl0ZVwiIH19IG9yaWVudGF0aW9uPVwidmVydGljYWxcIiBmbGV4SXRlbSAvPlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLnJpZ2h0fT5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXMudGl0bGV9PkN1c3RvbTwvZGl2PlxuICAgICAgICAgICAgPENhbGVuZGFyQ29udGFpbmVyIGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH19PntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgIDwvQ2FsZW5kYXJDb250YWluZXI+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuYnV0dG9uc30+XG4gICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e2hhbmRsZUNsb3NlfT5DYW5jZWw8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b24gZGlzYWJsZWQ9e0Jvb2xlYW4oIXN0YXJ0RGF0ZSl9IG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH0+XG4gICAgICAgICAgICAgIEFwcGx5XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBjb25zdCBSZWFjdERhdGVQaWNrZXJJbnB1dCA9IFJlYWN0LmZvcndhcmRSZWY8XG4gICAgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gICAgUmVhY3QuRGV0YWlsZWRIVE1MUHJvcHM8UmVhY3QuQnV0dG9uSFRNTEF0dHJpYnV0ZXM8SFRNTEJ1dHRvbkVsZW1lbnQ+LCBIVE1MQnV0dG9uRWxlbWVudD5cbiAgPigoeyBvbkNsaWNrLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcbiAgICBjb25zdCBoYW5kbGVJbnB1dCA9IGlzT3BlbiA/IGhhbmRsZUNsb3NlIDogb25DbGlja1xuICAgIGlmIChoaWRlSW5wdXQpIHJldHVybiBudWxsXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIHJlZj17cmVmfSB7Li4ucHJvcHN9IG9uQ2xpY2s9e2hhbmRsZUlucHV0fT5cbiAgICAgICAge2lucHV0TGFiZWx9XG4gICAgICAgIDxUcmlhbmdsZUFycm93IGlzT3Blbj17aXNPcGVufSAvPlxuICAgICAgPC9idXR0b24+XG4gICAgKVxuICB9KVxuXG4gIHJldHVybiAoXG4gICAgPERhdGVQaWNrZXJTdHlsZWQgY2xhc3NOYW1lPXtjbGFzc2VzLmlucHV0fT5cbiAgICAgIHshaGlkZUlucHV0ICYmIDxUeXBvZ3JhcGh5IHZhcmlhbnQ9XCJib2R5MlwiPkRhdGU6PC9UeXBvZ3JhcGh5Pn1cbiAgICAgIDxEYXRlUGlja2VyXG4gICAgICAgIG9wZW49e29wZW4gPyBvcGVuIDogaXNPcGVufVxuICAgICAgICBvbklucHV0Q2xpY2s9eygpID0+IHNldElzT3Blbih0cnVlKX1cbiAgICAgICAgb25DbGlja091dHNpZGU9e2hhbmRsZUNsb3NlfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXMuZGF0ZXBpY2tlcn1cbiAgICAgICAgZm9jdXNTZWxlY3RlZE1vbnRoXG4gICAgICAgIHNlbGVjdGVkPXtzdGFydERhdGV9XG4gICAgICAgIHN0YXJ0RGF0ZT17c3RhcnREYXRlfVxuICAgICAgICBlbmREYXRlPXtlbmREYXRlfVxuICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfVxuICAgICAgICBtb250aHNTaG93bj17bW9udGhzVG9TaG93bn1cbiAgICAgICAgZGF0ZUZvcm1hdD1cIk1NTU0gZGQsIHl5eXlcIlxuICAgICAgICBzaG91bGRDbG9zZU9uU2VsZWN0PXtmYWxzZX1cbiAgICAgICAgY2FsZW5kYXJTdGFydERheT17MX1cbiAgICAgICAgY2FsZW5kYXJDb250YWluZXI9e0NvbnRhaW5lcn1cbiAgICAgICAgY3VzdG9tSW5wdXQ9ezxSZWFjdERhdGVQaWNrZXJJbnB1dCAvPn1cbiAgICAgICAgbWF4RGF0ZT17bmV3IERhdGUoKX1cbiAgICAgICAgZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb25cbiAgICAgICAgc2VsZWN0c1JhbmdlXG4gICAgICAgIHBvcHBlclBsYWNlbWVudD1cImJvdHRvbVwiXG4gICAgICAgIG9wZW5Ub0RhdGU9e29wZW5Ub0RhdGUoZW5kRGF0ZSl9XG4gICAgICAvPlxuICAgICAgPERhdGVQaWNrZXJPdmVybGF5IGlzT3Blbj17aXNPcGVufSAvPlxuICAgIDwvRGF0ZVBpY2tlclN0eWxlZD5cbiAgKVxufVxuXG5leHBvcnQgeyBEYXRlcGlja2VyIH1cbiJdLCJuYW1lcyI6WyJEYXRlcGlja2VyIiwib25TdWJtaXQiLCJvcHRpb25zIiwiZGF0ZSIsImRlZmF1bHRPcHRpb24iLCJvcGVuIiwib25DbG9zZSIsImhpZGVJbnB1dCIsIndpdGhSYW5nZUxpc3QiLCJtb250aHNUb1Nob3duIiwiaW5pdGlhbERhdGUiLCJzdGFydERhdGUiLCJzZXRTdGFydERhdGUiLCJ1c2VTdGF0ZSIsIkRhdGUiLCJzdGFydCIsImVuZERhdGUiLCJzZXRFbmREYXRlIiwiZW5kIiwiaXNPcGVuIiwic2V0SXNPcGVuIiwib3B0aW9uSW5kZXgiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmaW5kSW5kZXgiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4Iiwic2V0U2VsZWN0ZWRJbmRleCIsImlucHV0TGFiZWwiLCJzZXRJbnB1dExhYmVsIiwibGFiZWwiLCJoYW5kbGVDbG9zZSIsInVzZUNhbGxiYWNrIiwiaGFuZGxlU3VibWl0IiwiaGFuZGxlQXBwbHkiLCJmb3JtYXREYXRlTGFiZWwiLCJmb3JtYXR0ZWRTdGFydCIsImZvcm1hdHRlZEVuZCIsImZvcm1hdERhdGVzRm9yUXVlcnkiLCJ0eXBlIiwidmFsdWUiLCJoYW5kbGVDaGFuZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJDb250YWluZXIiLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsImhhbmRsZVNlbGVjdCIsIm9wdGlvbklkIiwiaW5kZXgiLCJ1c2VFZmZlY3QiLCJjbG9zZU9uRXNjIiwiZSIsImtleSIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXYiLCJjbGFzc2VzIiwiY29udGFpbmVyIiwiTGlzdCIsImNvbXBvbmVudCIsImFyaWEtbGFiZWwiLCJ0aXRsZSIsImVudHJpZXMiLCJtYXAiLCJpZCIsIkxpc3RJdGVtQnV0dG9uIiwibGlzdEl0ZW0iLCJzZWxlY3RlZCIsIm9uQ2xpY2siLCJEaXZpZGVyIiwic3giLCJtYXJnaW4iLCJjb2xvciIsIm9yaWVudGF0aW9uIiwiZmxleEl0ZW0iLCJyaWdodCIsIkNhbGVuZGFyQ29udGFpbmVyIiwic3R5bGUiLCJwb3NpdGlvbiIsImJ1dHRvbnMiLCJCdXR0b24iLCJkaXNhYmxlZCIsIkJvb2xlYW4iLCJSZWFjdERhdGVQaWNrZXJJbnB1dCIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInJlZiIsInByb3BzIiwiaGFuZGxlSW5wdXQiLCJidXR0b24iLCJUcmlhbmdsZUFycm93IiwiRGF0ZVBpY2tlclN0eWxlZCIsImlucHV0IiwiVHlwb2dyYXBoeSIsInZhcmlhbnQiLCJEYXRlUGlja2VyIiwib25JbnB1dENsaWNrIiwib25DbGlja091dHNpZGUiLCJkYXRlcGlja2VyIiwiZm9jdXNTZWxlY3RlZE1vbnRoIiwib25DaGFuZ2UiLCJtb250aHNTaG93biIsImRhdGVGb3JtYXQiLCJzaG91bGRDbG9zZU9uU2VsZWN0IiwiY2FsZW5kYXJTdGFydERheSIsImNhbGVuZGFyQ29udGFpbmVyIiwiY3VzdG9tSW5wdXQiLCJtYXhEYXRlIiwiZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24iLCJzZWxlY3RzUmFuZ2UiLCJwb3BwZXJQbGFjZW1lbnQiLCJvcGVuVG9EYXRlIiwiRGF0ZVBpY2tlck92ZXJsYXkiXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXOzs7OzsrQkFnTkZBOzs7ZUFBQUE7Ozs7K0RBL00rQzt5RUFDVjtzQkFHb0I7aUNBRUw7K0JBQy9CO2lDQVF2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVQLE1BQU1BLGFBQWEsQ0FBOEIsRUFDL0NDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxJQUFJLEVBQ0pDLGFBQWEsRUFDYkMsT0FBTyxLQUFLLEVBQ1pDLE9BQU8sRUFDUEMsWUFBWSxLQUFLLEVBQ2pCQyxnQkFBZ0IsSUFBSSxFQUNwQkMsZ0JBQWdCLENBQUMsRUFXbEI7SUFDQyxNQUFNQyxjQUFjUCxpQkFBQUEsa0JB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