171639b557c5f1d1d69d425ecdbc5964
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createBeginDrag", {
    enumerable: true,
    get: function() {
        return createBeginDrag;
    }
});
const _invariant = require("@react-dnd/invariant");
const _js_utils = require("../../utils/js_utils.js");
const _setClientOffset = require("./local/setClientOffset.js");
const _types = require("./types.js");
const ResetCoordinatesAction = {
    type: _types.INIT_COORDS,
    payload: {
        clientOffset: null,
        sourceClientOffset: null
    }
};
function createBeginDrag(manager) {
    return function beginDrag(sourceIds = [], options = {
        publishSource: true
    }) {
        const { publishSource = true, clientOffset, getSourceClientOffset } = options;
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        // Initialize the coordinates using the client offset
        manager.dispatch((0, _setClientOffset.setClientOffset)(clientOffset));
        verifyInvariants(sourceIds, monitor, registry);
        // Get the draggable source
        const sourceId = getDraggableSource(sourceIds, monitor);
        if (sourceId == null) {
            manager.dispatch(ResetCoordinatesAction);
            return;
        }
        // Get the source client offset
        let sourceClientOffset = null;
        if (clientOffset) {
            if (!getSourceClientOffset) {
                throw new Error('getSourceClientOffset must be defined');
            }
            verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);
            sourceClientOffset = getSourceClientOffset(sourceId);
        }
        // Initialize the full coordinates
        manager.dispatch((0, _setClientOffset.setClientOffset)(clientOffset, sourceClientOffset));
        const source = registry.getSource(sourceId);
        const item = source.beginDrag(monitor, sourceId);
        // If source.beginDrag returns null, this is an indicator to cancel the drag
        if (item == null) {
            return undefined;
        }
        verifyItemIsObject(item);
        registry.pinSource(sourceId);
        const itemType = registry.getSourceType(sourceId);
        return {
            type: _types.BEGIN_DRAG,
            payload: {
                itemType,
                item,
                sourceId,
                clientOffset: clientOffset || null,
                sourceClientOffset: sourceClientOffset || null,
                isSourcePublic: !!publishSource
            }
        };
    };
}
function verifyInvariants(sourceIds, monitor, registry) {
    (0, _invariant.invariant)(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');
    sourceIds.forEach(function(sourceId) {
        (0, _invariant.invariant)(registry.getSource(sourceId), 'Expected sourceIds to be registered.');
    });
}
function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {
    (0, _invariant.invariant)(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');
}
function verifyItemIsObject(item) {
    (0, _invariant.invariant)((0, _js_utils.isObject)(item), 'Item must be an object.');
}
function getDraggableSource(sourceIds, monitor) {
    let sourceId = null;
    for(let i = sourceIds.length - 1; i >= 0; i--){
        if (monitor.canDragSource(sourceIds[i])) {
            sourceId = sourceIds[i];
            break;
        }
    }
    return sourceId;
} //# sourceMappingURL=beginDrag.js.map

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hY3Rpb25zL2RyYWdEcm9wL2JlZ2luRHJhZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdAcmVhY3QtZG5kL2ludmFyaWFudCdcblxuaW1wb3J0IHR5cGUge1xuXHRBY3Rpb24sXG5cdEJlZ2luRHJhZ09wdGlvbnMsXG5cdEJlZ2luRHJhZ1BheWxvYWQsXG5cdERyYWdEcm9wTWFuYWdlcixcblx0RHJhZ0Ryb3BNb25pdG9yLFxuXHRIYW5kbGVyUmVnaXN0cnksXG5cdElkZW50aWZpZXIsXG5cdFhZQ29vcmQsXG59IGZyb20gJy4uLy4uL2ludGVyZmFjZXMuanMnXG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzL2pzX3V0aWxzLmpzJ1xuaW1wb3J0IHsgc2V0Q2xpZW50T2Zmc2V0IH0gZnJvbSAnLi9sb2NhbC9zZXRDbGllbnRPZmZzZXQuanMnXG5pbXBvcnQgeyBCRUdJTl9EUkFHLCBJTklUX0NPT1JEUyB9IGZyb20gJy4vdHlwZXMuanMnXG5cbmNvbnN0IFJlc2V0Q29vcmRpbmF0ZXNBY3Rpb24gPSB7XG5cdHR5cGU6IElOSVRfQ09PUkRTLFxuXHRwYXlsb2FkOiB7XG5cdFx0Y2xpZW50T2Zmc2V0OiBudWxsLFxuXHRcdHNvdXJjZUNsaWVudE9mZnNldDogbnVsbCxcblx0fSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJlZ2luRHJhZyhtYW5hZ2VyOiBEcmFnRHJvcE1hbmFnZXIpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIGJlZ2luRHJhZyhcblx0XHRzb3VyY2VJZHM6IElkZW50aWZpZXJbXSA9IFtdLFxuXHRcdG9wdGlvbnM6IEJlZ2luRHJhZ09wdGlvbnMgPSB7XG5cdFx0XHRwdWJsaXNoU291cmNlOiB0cnVlLFxuXHRcdH0sXG5cdCk6IEFjdGlvbjxCZWdpbkRyYWdQYXlsb2FkPiB8IHVuZGVmaW5lZCB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0cHVibGlzaFNvdXJjZSA9IHRydWUsXG5cdFx0XHRjbGllbnRPZmZzZXQsXG5cdFx0XHRnZXRTb3VyY2VDbGllbnRPZmZzZXQsXG5cdFx0fTogQmVnaW5EcmFnT3B0aW9ucyA9IG9wdGlvbnNcblx0XHRjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKClcblx0XHRjb25zdCByZWdpc3RyeSA9IG1hbmFnZXIuZ2V0UmVnaXN0cnkoKVxuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgY29vcmRpbmF0ZXMgdXNpbmcgdGhlIGNsaWVudCBvZmZzZXRcblx0XHRtYW5hZ2VyLmRpc3BhdGNoKHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQpKVxuXG5cdFx0dmVyaWZ5SW52YXJpYW50cyhzb3VyY2VJZHMsIG1vbml0b3IsIHJlZ2lzdHJ5KVxuXG5cdFx0Ly8gR2V0IHRoZSBkcmFnZ2FibGUgc291cmNlXG5cdFx0Y29uc3Qgc291cmNlSWQgPSBnZXREcmFnZ2FibGVTb3VyY2Uoc291cmNlSWRzLCBtb25pdG9yKVxuXHRcdGlmIChzb3VyY2VJZCA9PSBudWxsKSB7XG5cdFx0XHRtYW5hZ2VyLmRpc3BhdGNoKFJlc2V0Q29vcmRpbmF0ZXNBY3Rpb24pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvLyBHZXQgdGhlIHNvdXJjZSBjbGllbnQgb2Zmc2V0XG5cdFx0bGV0IHNvdXJjZUNsaWVudE9mZnNldDogWFlDb29yZCB8IG51bGwgPSBudWxsXG5cdFx0aWYgKGNsaWVudE9mZnNldCkge1xuXHRcdFx0aWYgKCFnZXRTb3VyY2VDbGllbnRPZmZzZXQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdnZXRTb3VyY2VDbGllbnRPZmZzZXQgbXVzdCBiZSBkZWZpbmVkJylcblx0XHRcdH1cblx0XHRcdHZlcmlmeUdldFNvdXJjZUNsaWVudE9mZnNldElzRnVuY3Rpb24oZ2V0U291cmNlQ2xpZW50T2Zmc2V0KVxuXHRcdFx0c291cmNlQ2xpZW50T2Zmc2V0ID0gZ2V0U291cmNlQ2xpZW50T2Zmc2V0KHNvdXJjZUlkKVxuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGZ1bGwgY29vcmRpbmF0ZXNcblx0XHRtYW5hZ2VyLmRpc3BhdGNoKHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkpXG5cblx0XHRjb25zdCBzb3VyY2UgPSByZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQpXG5cdFx0Y29uc3QgaXRlbSA9IHNvdXJjZS5iZWdpbkRyYWcobW9uaXRvciwgc291cmNlSWQpXG5cdFx0Ly8gSWYgc291cmNlLmJlZ2luRHJhZyByZXR1cm5zIG51bGwsIHRoaXMgaXMgYW4gaW5kaWNhdG9yIHRvIGNhbmNlbCB0aGUgZHJhZ1xuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWRcblx0XHR9XG5cdFx0dmVyaWZ5SXRlbUlzT2JqZWN0KGl0ZW0pXG5cdFx0cmVnaXN0cnkucGluU291cmNlKHNvdXJjZUlkKVxuXG5cdFx0Y29uc3QgaXRlbVR5cGUgPSByZWdpc3RyeS5nZXRTb3VyY2VUeXBlKHNvdXJjZUlkKVxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBCRUdJTl9EUkFHLFxuXHRcdFx0cGF5bG9hZDoge1xuXHRcdFx0XHRpdGVtVHlwZSxcblx0XHRcdFx0aXRlbSxcblx0XHRcdFx0c291cmNlSWQsXG5cdFx0XHRcdGNsaWVudE9mZnNldDogY2xpZW50T2Zmc2V0IHx8IG51bGwsXG5cdFx0XHRcdHNvdXJjZUNsaWVudE9mZnNldDogc291cmNlQ2xpZW50T2Zmc2V0IHx8IG51bGwsXG5cdFx0XHRcdGlzU291cmNlUHVibGljOiAhIXB1Ymxpc2hTb3VyY2UsXG5cdFx0XHR9LFxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiB2ZXJpZnlJbnZhcmlhbnRzKFxuXHRzb3VyY2VJZHM6IElkZW50aWZpZXJbXSxcblx0bW9uaXRvcjogRHJhZ0Ryb3BNb25pdG9yLFxuXHRyZWdpc3RyeTogSGFuZGxlclJlZ2lzdHJ5LFxuKSB7XG5cdGludmFyaWFudCghbW9uaXRvci5pc0RyYWdnaW5nKCksICdDYW5ub3QgY2FsbCBiZWdpbkRyYWcgd2hpbGUgZHJhZ2dpbmcuJylcblx0c291cmNlSWRzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUlkKSB7XG5cdFx0aW52YXJpYW50KFxuXHRcdFx0cmVnaXN0cnkuZ2V0U291cmNlKHNvdXJjZUlkKSxcblx0XHRcdCdFeHBlY3RlZCBzb3VyY2VJZHMgdG8gYmUgcmVnaXN0ZXJlZC4nLFxuXHRcdClcblx0fSlcbn1cblxuZnVuY3Rpb24gdmVyaWZ5R2V0U291cmNlQ2xpZW50T2Zmc2V0SXNGdW5jdGlvbihnZXRTb3VyY2VDbGllbnRPZmZzZXQ6IGFueSkge1xuXHRpbnZhcmlhbnQoXG5cdFx0dHlwZW9mIGdldFNvdXJjZUNsaWVudE9mZnNldCA9PT0gJ2Z1bmN0aW9uJyxcblx0XHQnV2hlbiBjbGllbnRPZmZzZXQgaXMgcHJvdmlkZWQsIGdldFNvdXJjZUNsaWVudE9mZnNldCBtdXN0IGJlIGEgZnVuY3Rpb24uJyxcblx0KVxufVxuXG5mdW5jdGlvbiB2ZXJpZnlJdGVtSXNPYmplY3QoaXRlbTogYW55KSB7XG5cdGludmFyaWFudChpc09iamVjdChpdGVtKSwgJ0l0ZW0gbXVzdCBiZSBhbiBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlU291cmNlKHNvdXJjZUlkczogSWRlbnRpZmllcltdLCBtb25pdG9yOiBEcmFnRHJvcE1vbml0b3IpIHtcblx0bGV0IHNvdXJjZUlkID0gbnVsbFxuXHRmb3IgKGxldCBpID0gc291cmNlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0aWYgKG1vbml0b3IuY2FuRHJhZ1NvdXJjZShzb3VyY2VJZHNbaV0pKSB7XG5cdFx0XHRzb3VyY2VJZCA9IHNvdXJjZUlkc1tpXVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHNvdXJjZUlkXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQmVnaW5EcmFnIiwiUmVzZXRDb29yZGluYXRlc0FjdGlvbiIsInR5cGUiLCJJTklUX0NPT1JEUyIsInBheWxvYWQiLCJjbGllbnRPZmZzZXQiLCJzb3VyY2VDbGllbnRPZmZzZXQiLCJtYW5hZ2VyIiwiYmVnaW5EcmFnIiwic291cmNlSWRzIiwib3B0aW9ucyIsInB1Ymxpc2hTb3VyY2UiLCJnZXRTb3VyY2VDbGllbnRPZmZzZXQiLCJtb25pdG9yIiwiZ2V0TW9uaXRvciIsInJlZ2lzdHJ5IiwiZ2V0UmVnaXN0cnkiLCJkaXNwYXRjaCIsInNldENsaWVudE9mZnNldCIsInZlcmlmeUludmFyaWFudHMiLCJzb3VyY2VJZCIsImdldERyYWdnYWJsZVNvdXJjZSIsIkVycm9yIiwidmVyaWZ5R2V0U291cmNlQ2xpZW50T2Zmc2V0SXNGdW5jdGlvbiIsInNvdXJjZSIsImdldFNvdXJjZSIsIml0ZW0iLCJ1bmRlZmluZWQiLCJ2ZXJpZnlJdGVtSXNPYmplY3QiLCJwaW5Tb3VyY2UiLCJpdGVtVHlwZSIsImdldFNvdXJjZVR5cGUiLCJCRUdJTl9EUkFHIiwiaXNTb3VyY2VQdWJsaWMiLCJpbnZhcmlhbnQiLCJpc0RyYWdnaW5nIiwiZm9yRWFjaCIsImlzT2JqZWN0IiwiaSIsImxlbmd0aCIsImNhbkRyYWdTb3VyY2UiXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiOzs7OytCQXdCZ0JBOzs7ZUFBQUE7OzsyQkF4QlU7MEJBWUQ7aUNBQ087dUJBQ1E7QUFFeEMsTUFBTUMseUJBQXlCO0lBQzlCQyxNQUFNQyxrQkFBVztJQUNqQkMsU0FBUztRQUNSQyxjQUFjO1FBQ2RDLG9CQUFvQjs7O0FBSWYsU0FBU04sZ0JBQWdCTyxPQUF3QjtJQUN2RCxPQUFPLFNBQVNDLFVBQ2ZDLFlBQTBCLEVBQUUsRUFDNUJDLFVBQTRCO1FBQzNCQyxlQUFlO0tBQ2Y7UUFFRCxNQUFNLEVBQ0xBLGdCQUFnQixJQUFJLEVBQ3BCTixZQUFZLEVBQ1pPLHFCQUFxQixFQUNyQixHQUFxQkY7UUFDdEIsTUFBTUcsVUFBVU4sUUFBUU8sVUFBVTtRQUNsQyxNQUFNQyxXQUFXUixRQUFRUyxXQUFXO1FBRXBDLHFEQUFxRDtRQUNyRFQsUUFBUVUsUUFBUSxDQUFDQyxJQUFBQSxnQ0FBZSxFQUFDYjtRQUVqQ2MsaUJBQWlCVixXQUFXSSxTQUFTRTtRQUVyQywyQkFBMkI7UUFDM0IsTUFBTUssV0FBV0MsbUJBQW1CWixXQUFXSTtRQUMvQyxJQUFJTyxZQUFZLE1BQU07WUFDckJiLFFBQVFVLFFBQVEsQ0FBQ2hCO1lBQ2pCOztRQUdELCtCQUErQjtRQUMvQixJQUFJSyxxQkFBcUM7UUFDekMsSUFBSUQsY0FBYztZQUNqQixJQUFJLENBQUNPLHVCQUF1QjtnQkFDM0IsTUFBTSxJQUFJVSxNQUFNOztZQUVqQkMsc0NBQXNDWDtZQUN0Q04scUJBQXFCTSxzQkFBc0JROztRQUc1QyxrQ0FBa0M7UUFDbENiLFFBQVFVLFFBQVEsQ0FBQ0MsSUFBQUEsZ0NBQWUsRUFBQ2IsY0FBY0M7UUFFL0MsTUFBTWtCLFNBQVNULFNBQVNVLFNBQVMsQ0FBQ0w7UUFDbEMsTUFBTU0sT0FBT0YsT0FBT2hCLFNBQVMsQ0FBQ0ssU0FBU087UUFDdkMsNEVBQTRFO1FBQzVFLElBQUlNLFFBQVEsTUFBTTtZQUNqQixPQUFPQzs7UUFFUkMsbUJBQW1CRjtRQUNuQlgsU0FBU2MsU0FBUyxDQUFDVDtRQUVuQixNQUFNVSxXQUFXZixTQUFTZ0IsYUFBYSxDQUFDWDtRQUN4QyxPQUFPO1lBQ05sQixNQUFNOEIsaUJBQVU7WUFDaEI1QixTQUFTO2dCQUNSMEI7Z0JBQ0FKO2dCQUNBTjtnQkFDQWYsY0FBY0EsZ0JBQWdCO2dCQUM5QkMsb0JBQW9CQSxzQkFBc0I7Z0JBQzFDMkIsZ0JBQWdCLENBQUMsQ0FBQ3RCOzs7OztBQU10QixTQUFTUSxpQkFDUlYsU0FBdUIsRUFDdkJJLE9BQXdCLEVBQ3hCRSxRQUF5QjtJQUV6Qm1CLElBQUFBLG9CQUFTLEVBQUMsQ0FBQ3JCLFFBQVFzQixVQUFVLElBQUk7SUFDakMxQixVQUFVMkIsT0FBTyxDQUFDLFNBQVVoQixRQUFRO1FBQ25DYyxJQUFBQSxvQkFBUyxFQUNSbkIsU0FBU1UsU0FBUyxDQUFDTCxXQUNuQjs7O0FBS0gsU0FBU0csc0NBQXNDWCxxQkFBMEI7SUFDeEVzQixJQUFBQSxvQkFBUyxFQUNSLE9BQU90QiwwQkFBMEIsWUFDakM7O0FBSUYsU0FBU2dCLG1CQUFtQkYsSUFBUztJQUNwQ1EsSUFBQUEsb0JBQVMsRUFBQ0csSUFBQUEsa0JBQVEsRUFBQ1gsT0FBTzs7QUFHM0IsU0FBU0wsbUJBQW1CWixTQUF1QixFQUFFSSxPQUF3QjtJQUM1RSxJQUFJTyxXQUFXO0lBQ2YsSUFBSyxJQUFJa0IsSUFBSTdCLFVBQVU4QixNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxJQUFLO1FBQy9DLElBQUl6QixRQUFRMkIsYUFBYSxDQUFDL0IsU0FBUyxDQUFDNkIsRUFBRSxHQUFHO1lBQ3hDbEIsV0FBV1gsU0FBUyxDQUFDNkIsRUFBRTtZQUN2Qjs7O0lBR0YsT0FBT2xCIn0=