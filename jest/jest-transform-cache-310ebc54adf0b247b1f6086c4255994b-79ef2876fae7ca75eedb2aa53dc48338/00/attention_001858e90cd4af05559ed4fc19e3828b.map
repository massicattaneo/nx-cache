{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-core-commonmark/lib/attention.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n// eslint-disable-next-line complexity\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n  let open\n  /** @type {Token} */\n  let group\n  /** @type {Token} */\n  let text\n  /** @type {Token} */\n  let openingSequence\n  /** @type {Token} */\n  let closingSequence\n  /** @type {number} */\n  let use\n  /** @type {Array<Event>} */\n  let nextEvents\n  /** @type {number} */\n  let offset\n\n  // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index\n\n      // Now walk back to find an opener.\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open &&\n          // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          }\n\n          // Number of markers to use from the sequence.\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          const start = Object.assign({}, events[open][1].end)\n          const end = Object.assign({}, events[index][1].start)\n          movePoint(start, -use)\n          movePoint(end, use)\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          }\n          events[open][1].end = Object.assign({}, openingSequence.start)\n          events[index][1].start = Object.assign({}, closingSequence.end)\n          nextEvents = []\n\n          // If there are more markers in the opening, add them before.\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          }\n\n          // Opening.\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ])\n\n          // Always populated by defaults.\n\n          // Between.\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          )\n\n          // Closing.\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ])\n\n          // If there are more markers in the closing, add them after.\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n          splice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  }\n\n  // Remove remaining sequences.\n  index = -1\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Before a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    marker = code\n    effects.enter('attentionSequence')\n    return inside(code)\n  }\n\n  /**\n   * In a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n    const token = effects.exit('attentionSequence')\n\n    // To do: next major: move this to resolver, just like `markdown-rs`.\n    const after = classifyCharacter(code)\n\n    // Always populated by defaults.\n\n    const open =\n      !after || (after === 2 && before) || attentionMarkers.includes(code)\n    const close =\n      !before || (before === 2 && after) || attentionMarkers.includes(previous)\n    token._open = Boolean(marker === 42 ? open : open && (before || !close))\n    token._close = Boolean(marker === 42 ? close : close && (after || !open))\n    return ok(code)\n  }\n}\n\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {undefined}\n */\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n"],"names":["attention","name","tokenize","tokenizeAttention","resolveAll","resolveAllAttention","events","context","index","open","group","text","openingSequence","closingSequence","use","nextEvents","offset","length","type","_close","_open","sliceSerialize","charCodeAt","end","start","Object","assign","movePoint","push","parser","constructs","insideSpan","null","slice","splice","effects","ok","attentionMarkers","previous","before","classifyCharacter","marker","code","enter","inside","consume","token","exit","after","includes","close","Boolean","point","column","_bufferIndex"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}