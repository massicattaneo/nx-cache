{"version":3,"sources":["../../src/internals/wrapConnectorHooks.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport type { ReactElement } from 'react'\nimport { cloneElement, isValidElement } from 'react'\n\nfunction throwIfCompositeComponentElement(element: ReactElement<any>) {\n\t// Custom components can no longer be wrapped directly in React DnD 2.0\n\t// so that we don't need to depend on findDOMNode() from react-dom.\n\tif (typeof element.type === 'string') {\n\t\treturn\n\t}\n\n\tconst displayName =\n\t\t(element.type as any).displayName || element.type.name || 'the component'\n\n\tthrow new Error(\n\t\t'Only native element nodes can now be passed to React DnD connectors.' +\n\t\t\t`You can either wrap ${displayName} into a <div>, or turn it into a ` +\n\t\t\t'drag source or a drop target itself.',\n\t)\n}\n\nfunction wrapHookToRecognizeElement(hook: (node: any, options: any) => void) {\n\treturn (elementOrNode = null, options = null) => {\n\t\t// When passed a node, call the hook straight away.\n\t\tif (!isValidElement(elementOrNode)) {\n\t\t\tconst node = elementOrNode\n\t\t\thook(node, options)\n\t\t\t// return the node so it can be chained (e.g. when within callback refs\n\t\t\t// <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\t\t\treturn node\n\t\t}\n\n\t\t// If passed a ReactElement, clone it and attach this function as a ref.\n\t\t// This helps us achieve a neat API where user doesn't even know that refs\n\t\t// are being used under the hood.\n\t\tconst element: ReactElement | null = elementOrNode\n\t\tthrowIfCompositeComponentElement(element as any)\n\n\t\t// When no options are passed, use the hook directly\n\t\tconst ref = options ? (node: Element) => hook(node, options) : hook\n\t\treturn cloneWithRef(element, ref)\n\t}\n}\n\nexport function wrapConnectorHooks(hooks: any) {\n\tconst wrappedHooks: any = {}\n\n\tObject.keys(hooks).forEach((key) => {\n\t\tconst hook = hooks[key]\n\n\t\t// ref objects should be passed straight through without wrapping\n\t\tif (key.endsWith('Ref')) {\n\t\t\twrappedHooks[key] = hooks[key]\n\t\t} else {\n\t\t\tconst wrappedHook = wrapHookToRecognizeElement(hook)\n\t\t\twrappedHooks[key] = () => wrappedHook\n\t\t}\n\t})\n\n\treturn wrappedHooks\n}\n\nfunction setRef(ref: any, node: any) {\n\tif (typeof ref === 'function') {\n\t\tref(node)\n\t} else {\n\t\tref.current = node\n\t}\n}\n\nfunction cloneWithRef(element: any, newRef: any): ReactElement<any> {\n\tconst previousRef = element.ref\n\tinvariant(\n\t\ttypeof previousRef !== 'string',\n\t\t'Cannot connect React DnD to an element with an existing string ref. ' +\n\t\t\t'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' +\n\t\t\t'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs',\n\t)\n\n\tif (!previousRef) {\n\t\t// When there is no ref on the element, use the new ref directly\n\t\treturn cloneElement(element, {\n\t\t\tref: newRef,\n\t\t})\n\t} else {\n\t\treturn cloneElement(element, {\n\t\t\tref: (node: any) => {\n\t\t\t\tsetRef(previousRef, node)\n\t\t\t\tsetRef(newRef, node)\n\t\t\t},\n\t\t})\n\t}\n}\n"],"names":["wrapConnectorHooks","throwIfCompositeComponentElement","element","type","displayName","name","Error","wrapHookToRecognizeElement","hook","elementOrNode","options","isValidElement","node","ref","cloneWithRef","hooks","wrappedHooks","Object","keys","forEach","key","endsWith","wrappedHook","setRef","current","newRef","previousRef","invariant","cloneElement"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BA4CgBA;;;eAAAA;;;2BA5CU;uBAEmB;AAE7C,SAASC,iCAAiCC,OAA0B;IACnE,uEAAuE;IACvE,mEAAmE;IACnE,IAAI,OAAOA,QAAQC,IAAI,KAAK,UAAU;QACrC;;IAGD,MAAMC,cACLF,QAASC,IAAI,CAASC,WAAW,IAAIF,QAAQC,IAAI,CAACE,IAAI,IAAI;IAE3D,MAAM,IAAIC,MACT,yEACC,CAAC,oBAAoB,EAAEF,YAAY,iCAAiC,CAAC,GACrE;;AAIH,SAASG,2BAA2BC,IAAuC;IAC1E,OAAO,CAACC,gBAAgB,IAAI,EAAEC,UAAU,IAAI;QAC3C,mDAAmD;QACnD,IAAI,eAACC,IAAAA,qBAAc,EAACF,gBAAgB;YACnC,MAAMG,OAAOH;YACbD,KAAKI,MAAMF;YACX,uEAAuE;YACvE,kEAAkE;YAClE,OAAOE;;QAGR,wEAAwE;QACxE,0EAA0E;QAC1E,iCAAiC;QACjC,MAAMV,UAA+BO;QACrCR,iCAAiCC;QAEjC,oDAAoD;QACpD,MAAMW,MAAMH,UAAU,CAACE,OAAkBJ,KAAKI,MAAMF,WAAWF;QAC/D,OAAOM,aAAaZ,SAASW;;;AAIxB,SAASb,mBAAmBe,KAAU;IAC5C,MAAMC,eAAoB,CAAA;IAE1BC,OAAOC,IAAI,CAACH,OAAOI,OAAO,CAAC,CAACC;QAC3B,MAAMZ,OAAOO,KAAK,CAACK,IAAI;QAEvB,iEAAiE;QACjE,IAAIA,IAAIC,QAAQ,CAAC,QAAQ;YACxBL,YAAY,CAACI,IAAI,GAAGL,KAAK,CAACK,IAAI;eACxB;YACN,MAAME,cAAcf,2BAA2BC;YAC/CQ,YAAY,CAACI,IAAI,GAAG,IAAME;;;IAI5B,OAAON;;AAGR,SAASO,OAAOV,GAAQ,EAAED,IAAS;IAClC,IAAI,OAAOC,QAAQ,YAAY;QAC9BA,IAAID;WACE;QACNC,IAAIW,OAAO,GAAGZ;;;AAIhB,SAASE,aAAaZ,OAAY,EAAEuB,MAAW;IAC9C,MAAMC,cAAcxB,QAAQW,GAAG;IAC/Bc,IAAAA,oBAAS,EACR,OAAOD,gBAAgB,UACvB,yEACC,yFACA;IAGF,IAAI,CAACA,aAAa;QACjB,gEAAgE;QAChE,qBAAOE,IAAAA,mBAAY,EAAC1B,SAAS;YAC5BW,KAAKY;;WAEA;QACN,qBAAOG,IAAAA,mBAAY,EAAC1B,SAAS;YAC5BW,KAAK,CAACD;gBACLW,OAAOG,aAAad;gBACpBW,OAAOE,QAAQb"}