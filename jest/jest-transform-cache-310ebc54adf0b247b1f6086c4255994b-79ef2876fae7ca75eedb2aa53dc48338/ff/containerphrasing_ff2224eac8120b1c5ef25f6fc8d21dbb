c8214d1e61bd09629703a0d2f02edca6
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Info} Info
 * @typedef {import('../types.js').PhrasingParents} PhrasingParents
 * @typedef {import('../types.js').State} State
 */ /**
 * Serialize the children of a parent that contains phrasing children.
 *
 * These children will be joined flush together.
 *
 * @param {PhrasingParents} parent
 *   Parent of flow nodes.
 * @param {State} state
 *   Info passed around about the current state.
 * @param {Info} info
 *   Info on where we are in the document we are generating.
 * @returns {string}
 *   Serialized children, joined together.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "containerPhrasing", {
    enumerable: true,
    get: function() {
        return containerPhrasing;
    }
});
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function containerPhrasing(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    /** @type {Array<string>} */ const results = [];
    let index = -1;
    let before = info.before;
    indexStack.push(-1);
    let tracker = state.createTracker(info);
    while(++index < children.length){
        const child = children[index];
        /** @type {string} */ let after;
        indexStack[indexStack.length - 1] = index;
        if (index + 1 < children.length) {
            /** @type {Handle} */ // @ts-expect-error: hush, it’s actually a `zwitch`.
            let handle = state.handle.handlers[children[index + 1].type];
            /** @type {Handle} */ // @ts-expect-error: hush, it’s actually a `zwitch`.
            if (handle && handle.peek) handle = handle.peek;
            after = handle ? handle(children[index + 1], parent, state, _object_spread({
                before: '',
                after: ''
            }, tracker.current())).charAt(0) : '';
        } else {
            after = info.after;
        }
        // In some cases, html (text) can be found in phrasing right after an eol.
        // When we’d serialize that, in most cases that would be seen as html
        // (flow).
        // As we can’t escape or so to prevent it from happening, we take a somewhat
        // reasonable approach: replace that eol with a space.
        // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>
        if (results.length > 0 && (before === '\r' || before === '\n') && child.type === 'html') {
            results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, ' ');
            before = ' ';
            // To do: does this work to reset tracker?
            tracker = state.createTracker(info);
            tracker.move(results.join(''));
        }
        results.push(tracker.move(state.handle(child, parent, state, _object_spread_props(_object_spread({}, tracker.current()), {
            before,
            after
        }))));
        before = results[results.length - 1].slice(-1);
    }
    indexStack.pop();
    return results.join('');
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NvbnRhaW5lci1waHJhc2luZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuSGFuZGxlfSBIYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuSW5mb30gSW5mb1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5QaHJhc2luZ1BhcmVudHN9IFBocmFzaW5nUGFyZW50c1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5TdGF0ZX0gU3RhdGVcbiAqL1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgY2hpbGRyZW4gb2YgYSBwYXJlbnQgdGhhdCBjb250YWlucyBwaHJhc2luZyBjaGlsZHJlbi5cbiAqXG4gKiBUaGVzZSBjaGlsZHJlbiB3aWxsIGJlIGpvaW5lZCBmbHVzaCB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge1BocmFzaW5nUGFyZW50c30gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBmbG93IG5vZGVzLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiAgIEluZm8gb24gd2hlcmUgd2UgYXJlIGluIHRoZSBkb2N1bWVudCB3ZSBhcmUgZ2VuZXJhdGluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIFNlcmlhbGl6ZWQgY2hpbGRyZW4sIGpvaW5lZCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5lclBocmFzaW5nKHBhcmVudCwgc3RhdGUsIGluZm8pIHtcbiAgY29uc3QgaW5kZXhTdGFjayA9IHN0YXRlLmluZGV4U3RhY2tcbiAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW4gfHwgW11cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCByZXN1bHRzID0gW11cbiAgbGV0IGluZGV4ID0gLTFcbiAgbGV0IGJlZm9yZSA9IGluZm8uYmVmb3JlXG5cbiAgaW5kZXhTdGFjay5wdXNoKC0xKVxuICBsZXQgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcblxuICB3aGlsZSAoKytpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baW5kZXhdXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IGFmdGVyXG5cbiAgICBpbmRleFN0YWNrW2luZGV4U3RhY2subGVuZ3RoIC0gMV0gPSBpbmRleFxuXG4gICAgaWYgKGluZGV4ICsgMSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBodXNoLCBpdOKAmXMgYWN0dWFsbHkgYSBgendpdGNoYC5cbiAgICAgIGxldCBoYW5kbGUgPSBzdGF0ZS5oYW5kbGUuaGFuZGxlcnNbY2hpbGRyZW5baW5kZXggKyAxXS50eXBlXVxuICAgICAgLyoqIEB0eXBlIHtIYW5kbGV9ICovXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBodXNoLCBpdOKAmXMgYWN0dWFsbHkgYSBgendpdGNoYC5cbiAgICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLnBlZWspIGhhbmRsZSA9IGhhbmRsZS5wZWVrXG4gICAgICBhZnRlciA9IGhhbmRsZVxuICAgICAgICA/IGhhbmRsZShjaGlsZHJlbltpbmRleCArIDFdLCBwYXJlbnQsIHN0YXRlLCB7XG4gICAgICAgICAgICBiZWZvcmU6ICcnLFxuICAgICAgICAgICAgYWZ0ZXI6ICcnLFxuICAgICAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgICAgICAgICB9KS5jaGFyQXQoMClcbiAgICAgICAgOiAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlciA9IGluZm8uYWZ0ZXJcbiAgICB9XG5cbiAgICAvLyBJbiBzb21lIGNhc2VzLCBodG1sICh0ZXh0KSBjYW4gYmUgZm91bmQgaW4gcGhyYXNpbmcgcmlnaHQgYWZ0ZXIgYW4gZW9sLlxuICAgIC8vIFdoZW4gd2XigJlkIHNlcmlhbGl6ZSB0aGF0LCBpbiBtb3N0IGNhc2VzIHRoYXQgd291bGQgYmUgc2VlbiBhcyBodG1sXG4gICAgLy8gKGZsb3cpLlxuICAgIC8vIEFzIHdlIGNhbuKAmXQgZXNjYXBlIG9yIHNvIHRvIHByZXZlbnQgaXQgZnJvbSBoYXBwZW5pbmcsIHdlIHRha2UgYSBzb21ld2hhdFxuICAgIC8vIHJlYXNvbmFibGUgYXBwcm9hY2g6IHJlcGxhY2UgdGhhdCBlb2wgd2l0aCBhIHNwYWNlLlxuICAgIC8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2lzc3Vlcy8xNT5cbiAgICBpZiAoXG4gICAgICByZXN1bHRzLmxlbmd0aCA+IDAgJiZcbiAgICAgIChiZWZvcmUgPT09ICdcXHInIHx8IGJlZm9yZSA9PT0gJ1xcbicpICYmXG4gICAgICBjaGlsZC50eXBlID09PSAnaHRtbCdcbiAgICApIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXSA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXS5yZXBsYWNlKFxuICAgICAgICAvKFxccj9cXG58XFxyKSQvLFxuICAgICAgICAnICdcbiAgICAgIClcbiAgICAgIGJlZm9yZSA9ICcgJ1xuXG4gICAgICAvLyBUbyBkbzogZG9lcyB0aGlzIHdvcmsgdG8gcmVzZXQgdHJhY2tlcj9cbiAgICAgIHRyYWNrZXIgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gICAgICB0cmFja2VyLm1vdmUocmVzdWx0cy5qb2luKCcnKSlcbiAgICB9XG5cbiAgICByZXN1bHRzLnB1c2goXG4gICAgICB0cmFja2VyLm1vdmUoXG4gICAgICAgIHN0YXRlLmhhbmRsZShjaGlsZCwgcGFyZW50LCBzdGF0ZSwge1xuICAgICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpLFxuICAgICAgICAgIGJlZm9yZSxcbiAgICAgICAgICBhZnRlclxuICAgICAgICB9KVxuICAgICAgKVxuICAgIClcblxuICAgIGJlZm9yZSA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXS5zbGljZSgtMSlcbiAgfVxuXG4gIGluZGV4U3RhY2sucG9wKClcblxuICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbImNvbnRhaW5lclBocmFzaW5nIiwicGFyZW50Iiwic3RhdGUiLCJpbmZvIiwiaW5kZXhTdGFjayIsImNoaWxkcmVuIiwicmVzdWx0cyIsImluZGV4IiwiYmVmb3JlIiwicHVzaCIsInRyYWNrZXIiLCJjcmVhdGVUcmFja2VyIiwibGVuZ3RoIiwiY2hpbGQiLCJhZnRlciIsImhhbmRsZSIsImhhbmRsZXJzIiwidHlwZSIsInBlZWsiLCJjdXJyZW50IiwiY2hhckF0IiwicmVwbGFjZSIsIm1vdmUiLCJqb2luIiwic2xpY2UiLCJwb3AiXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Q0FhQzs7OzsrQkFDZUE7OztlQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFULFNBQVNBLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDbkQsTUFBTUMsYUFBYUYsTUFBTUUsVUFBVTtJQUNuQyxNQUFNQyxXQUFXSixPQUFPSSxRQUFRLElBQUksRUFBRTtJQUN0QywwQkFBMEIsR0FDMUIsTUFBTUMsVUFBVSxFQUFFO0lBQ2xCLElBQUlDLFFBQVEsQ0FBQztJQUNiLElBQUlDLFNBQVNMLEtBQUtLLE1BQU07SUFFeEJKLFdBQVdLLElBQUksQ0FBQyxDQUFDO0lBQ2pCLElBQUlDLFVBQVVSLE1BQU1TLGFBQWEsQ0FBQ1I7SUFFbEMsTUFBTyxFQUFFSSxRQUFRRixTQUFTTyxNQUFNLENBQUU7UUFDaEMsTUFBTUMsUUFBUVIsUUFBUSxDQUFDRSxNQUFNO1FBQzdCLG1CQUFtQixHQUNuQixJQUFJTztRQUVKVixVQUFVLENBQUNBLFdBQVdRLE1BQU0sR0FBRyxFQUFFLEdBQUdMO1FBRXBDLElBQUlBLFFBQVEsSUFBSUYsU0FBU08sTUFBTSxFQUFFO1lBQy9CLG1CQUFtQixHQUNuQixvREFBb0Q7WUFDcEQsSUFBSUcsU0FBU2IsTUFBTWEsTUFBTSxDQUFDQyxRQUFRLENBQUNYLFFBQVEsQ0FBQ0UsUUFBUSxFQUFFLENBQUNVLElBQUksQ0FBQztZQUM1RCxtQkFBbUIsR0FDbkIsb0RBQW9EO1lBQ3BELElBQUlGLFVBQVVBLE9BQU9HLElBQUksRUFBRUgsU0FBU0EsT0FBT0csSUFBSTtZQUMvQ0osUUFBUUMsU0FDSkEsT0FBT1YsUUFBUSxDQUFDRSxRQUFRLEVBQUUsRUFBRU4sUUFBUUMsT0FBTztnQkFDekNNLFFBQVE7Z0JBQ1JNLE9BQU87ZUFDSkosUUFBUVMsT0FBTyxLQUNqQkMsTUFBTSxDQUFDLEtBQ1Y7UUFDTixPQUFPO1lBQ0xOLFFBQVFYLEtBQUtXLEtBQUs7UUFDcEI7UUFFQSwwRUFBMEU7UUFDMUUscUVBQXFFO1FBQ3JFLFVBQVU7UUFDViw0RUFBNEU7UUFDNUUsc0RBQXNEO1FBQ3RELHlFQUF5RTtRQUN6RSxJQUNFUixRQUFRTSxNQUFNLEdBQUcsS0FDaEJKLENBQUFBLFdBQVcsUUFBUUEsV0FBVyxJQUFHLEtBQ2xDSyxNQUFNSSxJQUFJLEtBQUssUUFDZjtZQUNBWCxPQUFPLENBQUNBLFFBQVFNLE1BQU0sR0FBRyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ0EsUUFBUU0sTUFBTSxHQUFHLEVBQUUsQ0FBQ1MsT0FBTyxDQUMvRCxlQUNBO1lBRUZiLFNBQVM7WUFFVCwwQ0FBMEM7WUFDMUNFLFVBQVVSLE1BQU1TLGFBQWEsQ0FBQ1I7WUFDOUJPLFFBQVFZLElBQUksQ0FBQ2hCLFFBQVFpQixJQUFJLENBQUM7UUFDNUI7UUFFQWpCLFFBQVFHLElBQUksQ0FDVkMsUUFBUVksSUFBSSxDQUNWcEIsTUFBTWEsTUFBTSxDQUFDRixPQUFPWixRQUFRQyxPQUFPLHdDQUM5QlEsUUFBUVMsT0FBTztZQUNsQlg7WUFDQU07O1FBS05OLFNBQVNGLE9BQU8sQ0FBQ0EsUUFBUU0sTUFBTSxHQUFHLEVBQUUsQ0FBQ1ksS0FBSyxDQUFDLENBQUM7SUFDOUM7SUFFQXBCLFdBQVdxQixHQUFHO0lBRWQsT0FBT25CLFFBQVFpQixJQUFJLENBQUM7QUFDdEIifQ==