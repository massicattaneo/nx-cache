{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark/lib/initialize/document.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef {[Construct, ContainerState]} StackItem\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {InitialConstruct} */\nexport const document = {\n  tokenize: initializeDocument\n}\n\n/** @type {Construct} */\nconst containerConstruct = {\n  tokenize: tokenizeContainer\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Initializer}\n */\nfunction initializeDocument(effects) {\n  const self = this\n  /** @type {Array<StackItem>} */\n  const stack = []\n  let continued = 0\n  /** @type {TokenizeContext | undefined} */\n  let childFlow\n  /** @type {Token | undefined} */\n  let childToken\n  /** @type {number} */\n  let lineStartOffset\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued]\n      self.containerState = item[1]\n      return effects.attempt(\n        item[0].continuation,\n        documentContinue,\n        checkNewContainers\n      )(code)\n    }\n\n    // Done.\n    return checkNewContainers(code)\n  }\n\n  /** @type {State} */\n  function documentContinue(code) {\n    continued++\n\n    // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but it’s already used in the wild by\n    // extensions.\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined\n      if (childFlow) {\n        closeFlow()\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {Point | undefined} */\n      let point\n\n      // Find the flow chunk.\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          point = self.events[indexBeforeFlow][1].end\n          break\n        }\n      }\n      exitContainers(continued)\n\n      // Fix positions.\n      let index = indexBeforeExits\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      }\n\n      // Inject the exits earlier (they’re still also at the end).\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      )\n\n      // Discard the duplicate exits.\n      self.events.length = index\n      return checkNewContainers(code)\n    }\n    return start(code)\n  }\n\n  /** @type {State} */\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code)\n      }\n\n      // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code)\n      }\n\n      // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n      // To do: next major: remove `_gfmTableDynamicInterruptHack` (no longer\n      // needed in micromark-extension-gfm-table@1.0.6).\n      self.interrupt = Boolean(\n        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack\n      )\n    }\n\n    // Check if there is a new container.\n    self.containerState = {}\n    return effects.check(\n      containerConstruct,\n      thereIsANewContainer,\n      thereIsNoNewContainer\n    )(code)\n  }\n\n  /** @type {State} */\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow()\n    exitContainers(continued)\n    return documentContinued(code)\n  }\n\n  /** @type {State} */\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length\n    lineStartOffset = self.now().offset\n    return flowStart(code)\n  }\n\n  /** @type {State} */\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n\n  /** @type {State} */\n  function containerContinue(code) {\n    continued++\n    stack.push([self.currentConstruct, self.containerState])\n    // Try another.\n    return documentContinued(code)\n  }\n\n  /** @type {State} */\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow()\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n\n  /** @type {State} */\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit('chunkFlow'), true)\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      writeToChild(effects.exit('chunkFlow'))\n      // Get ready for the next line.\n      continued = 0\n      self.interrupt = undefined\n      return start\n    }\n    effects.consume(code)\n    return flowContinue\n  }\n\n  /**\n   * @param {Token} token\n   * @param {boolean | undefined} [eof]\n   * @returns {undefined}\n   */\n  function writeToChild(token, eof) {\n    const stream = self.sliceStream(token)\n    if (eof) stream.push(null)\n    token.previous = childToken\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.defineSkip(token.start)\n    childFlow.write(stream)\n\n    // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length\n      while (index--) {\n        if (\n          // The token starts before the line ending…\n          childFlow.events[index][1].start.offset < lineStartOffset &&\n          // …and either is not ended yet…\n          (!childFlow.events[index][1].end ||\n            // …or ends after it.\n            childFlow.events[index][1].end.offset > lineStartOffset)\n        ) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return\n        }\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {boolean | undefined} */\n      let seen\n      /** @type {Point | undefined} */\n      let point\n\n      // Find the previous chunk (the one before the lazy line).\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end\n            break\n          }\n          seen = true\n        }\n      }\n      exitContainers(continued)\n\n      // Fix positions.\n      index = indexBeforeExits\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      }\n\n      // Inject the exits earlier (they’re still also at the end).\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      )\n\n      // Discard the duplicate exits.\n      self.events.length = index\n    }\n  }\n\n  /**\n   * @param {number} size\n   * @returns {undefined}\n   */\n  function exitContainers(size) {\n    let index = stack.length\n\n    // Exit open containers.\n    while (index-- > size) {\n      const entry = stack[index]\n      self.containerState = entry[1]\n      entry[0].exit.call(self, effects)\n    }\n    stack.length = size\n  }\n  function closeFlow() {\n    childFlow.write([null])\n    childToken = undefined\n    childFlow = undefined\n    self.containerState._closeFlow = undefined\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeContainer(effects, ok, nok) {\n  // Always populated by defaults.\n\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n"],"names":["document","tokenize","initializeDocument","containerConstruct","tokenizeContainer","effects","self","stack","continued","childFlow","childToken","lineStartOffset","start","code","length","item","containerState","attempt","continuation","documentContinue","checkNewContainers","_closeFlow","undefined","closeFlow","indexBeforeExits","events","indexBeforeFlow","point","type","end","exitContainers","index","Object","assign","splice","slice","documentContinued","currentConstruct","concrete","flowStart","interrupt","Boolean","_gfmTableDynamicInterruptHack","check","thereIsANewContainer","thereIsNoNewContainer","parser","lazy","now","line","offset","containerContinue","push","consume","flow","enter","contentType","previous","_tokenizer","flowContinue","writeToChild","exit","markdownLineEnding","token","eof","stream","sliceStream","next","defineSkip","write","seen","size","entry","call","ok","nok","factorySpace","constructs","disable","null","includes"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}