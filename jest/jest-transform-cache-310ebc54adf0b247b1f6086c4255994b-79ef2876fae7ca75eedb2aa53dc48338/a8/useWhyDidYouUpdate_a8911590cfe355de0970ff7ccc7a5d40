3f218edaaf85e78d8d7e503deddfd306
/* eslint-disable no-console */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useWhyDidYouUpdate", {
    enumerable: true,
    get: function() {
        return useWhyDidYouUpdate;
    }
});
const _react = require("react");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function useWhyDidYouUpdate(name, props) {
    // Get a mutable ref object where we can store props ...
    // ... for comparison next time this hook runs.
    const previousProps = (0, _react.useRef)({});
    (0, _react.useEffect)(()=>{
        if (previousProps.current) {
            // Get all keys from previous and current props
            const allKeys = Object.keys(_object_spread({}, previousProps.current, props));
            // Use this object to keep track of changed props
            const changesObj = {};
            // Iterate through keys
            allKeys.forEach((key)=>{
                // If previous is different from current
                if (previousProps.current[key] !== props[key]) {
                    // Add to changesObj
                    changesObj[key] = {
                        from: previousProps.current[key],
                        to: props[key]
                    };
                }
            });
            // If changesObj not empty then output to console
            if (Object.keys(changesObj).length) {
                console.log("[ü§∑‚Äç‚ôÇÔ∏è why-did-you-update ü§∑‚Äç‚ôÇÔ∏è]", name, changesObj);
            }
        }
        // Finally update previousProps with current props for next hook call
        previousProps.current = props;
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL2xpYnMvcmVhY3QvY29tbW9uL2hvb2tzL3NyYy9saWIvdXNlV2h5RGlkWW91VXBkYXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCJcblxudHlwZSBQcm9wcyA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG5cbmZ1bmN0aW9uIHVzZVdoeURpZFlvdVVwZGF0ZShuYW1lOiBzdHJpbmcsIHByb3BzOiBQcm9wcykge1xuICAvLyBHZXQgYSBtdXRhYmxlIHJlZiBvYmplY3Qgd2hlcmUgd2UgY2FuIHN0b3JlIHByb3BzIC4uLlxuICAvLyAuLi4gZm9yIGNvbXBhcmlzb24gbmV4dCB0aW1lIHRoaXMgaG9vayBydW5zLlxuICBjb25zdCBwcmV2aW91c1Byb3BzID0gdXNlUmVmPFByb3BzPih7fSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmV2aW91c1Byb3BzLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdldCBhbGwga2V5cyBmcm9tIHByZXZpb3VzIGFuZCBjdXJyZW50IHByb3BzXG4gICAgICBjb25zdCBhbGxLZXlzID0gT2JqZWN0LmtleXMoeyAuLi5wcmV2aW91c1Byb3BzLmN1cnJlbnQsIC4uLnByb3BzIH0pXG4gICAgICAvLyBVc2UgdGhpcyBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjaGFuZ2VkIHByb3BzXG4gICAgICBjb25zdCBjaGFuZ2VzT2JqOiBQcm9wcyA9IHt9XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2gga2V5c1xuICAgICAgYWxsS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIC8vIElmIHByZXZpb3VzIGlzIGRpZmZlcmVudCBmcm9tIGN1cnJlbnRcbiAgICAgICAgaWYgKHByZXZpb3VzUHJvcHMuY3VycmVudFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgICAgLy8gQWRkIHRvIGNoYW5nZXNPYmpcbiAgICAgICAgICBjaGFuZ2VzT2JqW2tleV0gPSB7XG4gICAgICAgICAgICBmcm9tOiBwcmV2aW91c1Byb3BzLmN1cnJlbnRba2V5XSxcbiAgICAgICAgICAgIHRvOiBwcm9wc1trZXldLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gSWYgY2hhbmdlc09iaiBub3QgZW1wdHkgdGhlbiBvdXRwdXQgdG8gY29uc29sZVxuICAgICAgaWYgKE9iamVjdC5rZXlzKGNoYW5nZXNPYmopLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlvwn6S34oCN4pmC77iPIHdoeS1kaWQteW91LXVwZGF0ZSDwn6S34oCN4pmC77iPXVwiLCBuYW1lLCBjaGFuZ2VzT2JqKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmFsbHkgdXBkYXRlIHByZXZpb3VzUHJvcHMgd2l0aCBjdXJyZW50IHByb3BzIGZvciBuZXh0IGhvb2sgY2FsbFxuICAgIHByZXZpb3VzUHJvcHMuY3VycmVudCA9IHByb3BzXG4gIH0pXG59XG5cbmV4cG9ydCB7IHVzZVdoeURpZFlvdVVwZGF0ZSB9XG4iXSwibmFtZXMiOlsidXNlV2h5RGlkWW91VXBkYXRlIiwibmFtZSIsInByb3BzIiwicHJldmlvdXNQcm9wcyIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJhbGxLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImNoYW5nZXNPYmoiLCJmb3JFYWNoIiwia2V5IiwiZnJvbSIsInRvIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJtYXBwaW5ncyI6IkFBQUEsNkJBQTZCOzs7OytCQXVDcEJBOzs7ZUFBQUE7Ozt1QkF0Q3lCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlsQyxTQUFTQSxtQkFBbUJDLElBQVksRUFBRUMsS0FBWTtJQUNwRCx3REFBd0Q7SUFDeEQsK0NBQStDO0lBQy9DLE1BQU1DLGdCQUFnQkMsSUFBQUEsYUFBTSxFQUFRLENBQUM7SUFFckNDLElBQUFBLGdCQUFTLEVBQUM7UUFDUixJQUFJRixjQUFjRyxPQUFPLEVBQUU7WUFDekIsK0NBQStDO1lBQy9DLE1BQU1DLFVBQVVDLE9BQU9DLElBQUksQ0FBQyxtQkFBS04sY0FBY0csT0FBTyxFQUFLSjtZQUMzRCxpREFBaUQ7WUFDakQsTUFBTVEsYUFBb0IsQ0FBQztZQUMzQix1QkFBdUI7WUFDdkJILFFBQVFJLE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ2Qsd0NBQXdDO2dCQUN4QyxJQUFJVCxjQUFjRyxPQUFPLENBQUNNLElBQUksS0FBS1YsS0FBSyxDQUFDVSxJQUFJLEVBQUU7b0JBQzdDLG9CQUFvQjtvQkFDcEJGLFVBQVUsQ0FBQ0UsSUFBSSxHQUFHO3dCQUNoQkMsTUFBTVYsY0FBY0csT0FBTyxDQUFDTSxJQUFJO3dCQUNoQ0UsSUFBSVosS0FBSyxDQUFDVSxJQUFJO29CQUNoQjtnQkFDRjtZQUNGO1lBRUEsaURBQWlEO1lBQ2pELElBQUlKLE9BQU9DLElBQUksQ0FBQ0MsWUFBWUssTUFBTSxFQUFFO2dCQUNsQ0MsUUFBUUMsR0FBRyxDQUFDLG9DQUFvQ2hCLE1BQU1TO1lBQ3hEO1FBQ0Y7UUFFQSxxRUFBcUU7UUFDckVQLGNBQWNHLE9BQU8sR0FBR0o7SUFDMUI7QUFDRiJ9