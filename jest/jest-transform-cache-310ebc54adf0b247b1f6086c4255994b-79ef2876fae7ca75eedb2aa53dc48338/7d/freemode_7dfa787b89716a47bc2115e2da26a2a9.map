{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/swiper/modules/free-mode/free-mode.js"],"sourcesContent":["import { elementTransitionEnd, now } from '../../shared/utils.js';\nexport default function freeMode({\n  swiper,\n  extendParams,\n  emit,\n  once\n}) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n  function onTouchStart() {\n    if (swiper.params.cssMode) return;\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n  function onTouchMove() {\n    if (swiper.params.cssMode) return;\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n  function onTouchEnd({\n    currentPos\n  }) {\n    if (swiper.params.cssMode) return;\n    const {\n      params,\n      wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}"],"names":["freeMode","swiper","extendParams","emit","once","enabled","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","sticky","minimumVelocity","onTouchStart","params","cssMode","translate","getTranslate","setTranslate","setTransition","touchEventsData","velocities","length","onTouchEnd","currentPos","rtl","onTouchMove","data","touches","push","position","isHorizontal","time","touchStartTime","now","wrapperEl","rtlTranslate","snapGrid","touchEndTime","timeDiff","minTranslate","slideTo","activeIndex","maxTranslate","slides","lastMoveEvent","pop","velocityEvent","distance","velocity","Math","abs","momentumDuration","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","needsLoopFix","allowMomentumBounce","loop","centeredSlides","nextSlide","j","swipeDirection","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","transitionStart","animating","elementTransitionEnd","destroyed","setTimeout","transitionEnd","updateActiveIndex","updateSlidesClasses","longSwipesMs","Object","assign"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}