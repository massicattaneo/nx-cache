654ec384b7c61aadc60ff577f86e6ed4
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "labelEnd", {
    enumerable: true,
    get: function() {
        return labelEnd;
    }
});
const _micromarkfactorydestination = require("micromark-factory-destination");
const _micromarkfactorylabel = require("micromark-factory-label");
const _micromarkfactorytitle = require("micromark-factory-title");
const _micromarkfactorywhitespace = require("micromark-factory-whitespace");
const _micromarkutilcharacter = require("micromark-util-character");
const _micromarkutilchunked = require("micromark-util-chunked");
const _micromarkutilnormalizeidentifier = require("micromark-util-normalize-identifier");
const _micromarkutilresolveall = require("micromark-util-resolve-all");
const labelEnd = {
    name: 'labelEnd',
    tokenize: tokenizeLabelEnd,
    resolveTo: resolveToLabelEnd,
    resolveAll: resolveAllLabelEnd
};
/** @type {Construct} */ const resourceConstruct = {
    tokenize: tokenizeResource
};
/** @type {Construct} */ const referenceFullConstruct = {
    tokenize: tokenizeReferenceFull
};
/** @type {Construct} */ const referenceCollapsedConstruct = {
    tokenize: tokenizeReferenceCollapsed
};
/** @type {Resolver} */ function resolveAllLabelEnd(events) {
    let index = -1;
    while(++index < events.length){
        const token = events[index][1];
        if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {
            // Remove the marker.
            events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);
            token.type = 'data';
            index++;
        }
    }
    return events;
}
/** @type {Resolver} */ function resolveToLabelEnd(events, context) {
    let index = events.length;
    let offset = 0;
    /** @type {Token} */ let token;
    /** @type {number | undefined} */ let open;
    /** @type {number | undefined} */ let close;
    /** @type {Array<Event>} */ let media;
    // Find an opening.
    while(index--){
        token = events[index][1];
        if (open) {
            // If we see another link, or inactive link label, weâ€™ve been here before.
            if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {
                break;
            }
            // Mark other link openings as inactive, as we canâ€™t have links in
            // links.
            if (events[index][0] === 'enter' && token.type === 'labelLink') {
                token._inactive = true;
            }
        } else if (close) {
            if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {
                open = index;
                if (token.type !== 'labelLink') {
                    offset = 2;
                    break;
                }
            }
        } else if (token.type === 'labelEnd') {
            close = index;
        }
    }
    const group = {
        type: events[open][1].type === 'labelLink' ? 'link' : 'image',
        start: Object.assign({}, events[open][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
    };
    const label = {
        type: 'label',
        start: Object.assign({}, events[open][1].start),
        end: Object.assign({}, events[close][1].end)
    };
    const text = {
        type: 'labelText',
        start: Object.assign({}, events[open + offset + 2][1].end),
        end: Object.assign({}, events[close - 2][1].start)
    };
    media = [
        [
            'enter',
            group,
            context
        ],
        [
            'enter',
            label,
            context
        ]
    ];
    // Opening marker.
    media = (0, _micromarkutilchunked.push)(media, events.slice(open + 1, open + offset + 3));
    // Text open.
    media = (0, _micromarkutilchunked.push)(media, [
        [
            'enter',
            text,
            context
        ]
    ]);
    // Always populated by defaults.
    // Between.
    media = (0, _micromarkutilchunked.push)(media, (0, _micromarkutilresolveall.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
    // Text close, marker close, label close.
    media = (0, _micromarkutilchunked.push)(media, [
        [
            'exit',
            text,
            context
        ],
        events[close - 2],
        events[close - 1],
        [
            'exit',
            label,
            context
        ]
    ]);
    // Reference, resource, or so.
    media = (0, _micromarkutilchunked.push)(media, events.slice(close + 1));
    // Media close.
    media = (0, _micromarkutilchunked.push)(media, [
        [
            'exit',
            group,
            context
        ]
    ]);
    (0, _micromarkutilchunked.splice)(events, open, events.length, media);
    return events;
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeLabelEnd(effects, ok, nok) {
    const self = this;
    let index = self.events.length;
    /** @type {Token} */ let labelStart;
    /** @type {boolean} */ let defined;
    // Find an opening.
    while(index--){
        if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {
            labelStart = self.events[index][1];
            break;
        }
    }
    return start;
    /**
   * Start of label end.
   *
   * ```markdown
   * > | [a](b) c
   *       ^
   * > | [a][b] c
   *       ^
   * > | [a][] b
   *       ^
   * > | [a] b
   * ```
   *
   * @type {State}
   */ function start(code) {
        // If there is not an okay opening.
        if (!labelStart) {
            return nok(code);
        }
        // If the corresponding label (link) start is marked as inactive,
        // it means weâ€™d be wrapping a link, like this:
        //
        // ```markdown
        // > | a [b [c](d) e](f) g.
        //                  ^
        // ```
        //
        // We canâ€™t have that, so itâ€™s just balanced brackets.
        if (labelStart._inactive) {
            return labelEndNok(code);
        }
        defined = self.parser.defined.includes((0, _micromarkutilnormalizeidentifier.normalizeIdentifier)(self.sliceSerialize({
            start: labelStart.end,
            end: self.now()
        })));
        effects.enter('labelEnd');
        effects.enter('labelMarker');
        effects.consume(code);
        effects.exit('labelMarker');
        effects.exit('labelEnd');
        return after;
    }
    /**
   * After `]`.
   *
   * ```markdown
   * > | [a](b) c
   *       ^
   * > | [a][b] c
   *       ^
   * > | [a][] b
   *       ^
   * > | [a] b
   *       ^
   * ```
   *
   * @type {State}
   */ function after(code) {
        // Note: `markdown-rs` also parses GFM footnotes here, which for us is in
        // an extension.
        // Resource (`[asd](fgh)`)?
        if (code === 40) {
            return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);
        }
        // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?
        if (code === 91) {
            return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);
        }
        // Shortcut (`[asd]`) reference?
        return defined ? labelEndOk(code) : labelEndNok(code);
    }
    /**
   * After `]`, at `[`, but not at a full reference.
   *
   * > ðŸ‘‰ **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] b
   *        ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */ function referenceNotFull(code) {
        return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);
    }
    /**
   * Done, we found something.
   *
   * ```markdown
   * > | [a](b) c
   *           ^
   * > | [a][b] c
   *           ^
   * > | [a][] b
   *          ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */ function labelEndOk(code) {
        // Note: `markdown-rs` does a bunch of stuff here.
        return ok(code);
    }
    /**
   * Done, itâ€™s nothing.
   *
   * There was an okay opening, but we didnâ€™t match anything.
   *
   * ```markdown
   * > | [a](b c
   *        ^
   * > | [a][b c
   *        ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */ function labelEndNok(code) {
        labelStart._balanced = true;
        return nok(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeResource(effects, ok, nok) {
    return resourceStart;
    /**
   * At a resource.
   *
   * ```markdown
   * > | [a](b) c
   *        ^
   * ```
   *
   * @type {State}
   */ function resourceStart(code) {
        effects.enter('resource');
        effects.enter('resourceMarker');
        effects.consume(code);
        effects.exit('resourceMarker');
        return resourceBefore;
    }
    /**
   * In resource, after `(`, at optional whitespace.
   *
   * ```markdown
   * > | [a](b) c
   *         ^
   * ```
   *
   * @type {State}
   */ function resourceBefore(code) {
        return (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkfactorywhitespace.factoryWhitespace)(effects, resourceOpen)(code) : resourceOpen(code);
    }
    /**
   * In resource, after optional whitespace, at `)` or a destination.
   *
   * ```markdown
   * > | [a](b) c
   *         ^
   * ```
   *
   * @type {State}
   */ function resourceOpen(code) {
        if (code === 41) {
            return resourceEnd(code);
        }
        return (0, _micromarkfactorydestination.factoryDestination)(effects, resourceDestinationAfter, resourceDestinationMissing, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 32)(code);
    }
    /**
   * In resource, after destination, at optional whitespace.
   *
   * ```markdown
   * > | [a](b) c
   *          ^
   * ```
   *
   * @type {State}
   */ function resourceDestinationAfter(code) {
        return (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkfactorywhitespace.factoryWhitespace)(effects, resourceBetween)(code) : resourceEnd(code);
    }
    /**
   * At invalid destination.
   *
   * ```markdown
   * > | [a](<<) b
   *         ^
   * ```
   *
   * @type {State}
   */ function resourceDestinationMissing(code) {
        return nok(code);
    }
    /**
   * In resource, after destination and whitespace, at `(` or title.
   *
   * ```markdown
   * > | [a](b ) c
   *           ^
   * ```
   *
   * @type {State}
   */ function resourceBetween(code) {
        if (code === 34 || code === 39 || code === 40) {
            return (0, _micromarkfactorytitle.factoryTitle)(effects, resourceTitleAfter, nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);
        }
        return resourceEnd(code);
    }
    /**
   * In resource, after title, at optional whitespace.
   *
   * ```markdown
   * > | [a](b "c") d
   *              ^
   * ```
   *
   * @type {State}
   */ function resourceTitleAfter(code) {
        return (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkfactorywhitespace.factoryWhitespace)(effects, resourceEnd)(code) : resourceEnd(code);
    }
    /**
   * In resource, at `)`.
   *
   * ```markdown
   * > | [a](b) d
   *          ^
   * ```
   *
   * @type {State}
   */ function resourceEnd(code) {
        if (code === 41) {
            effects.enter('resourceMarker');
            effects.consume(code);
            effects.exit('resourceMarker');
            effects.exit('resource');
            return ok;
        }
        return nok(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeReferenceFull(effects, ok, nok) {
    const self = this;
    return referenceFull;
    /**
   * In a reference (full), at the `[`.
   *
   * ```markdown
   * > | [a][b] d
   *        ^
   * ```
   *
   * @type {State}
   */ function referenceFull(code) {
        return _micromarkfactorylabel.factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, 'reference', 'referenceMarker', 'referenceString')(code);
    }
    /**
   * In a reference (full), after `]`.
   *
   * ```markdown
   * > | [a][b] d
   *          ^
   * ```
   *
   * @type {State}
   */ function referenceFullAfter(code) {
        return self.parser.defined.includes((0, _micromarkutilnormalizeidentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);
    }
    /**
   * In reference (full) that was missing.
   *
   * ```markdown
   * > | [a][b d
   *        ^
   * ```
   *
   * @type {State}
   */ function referenceFullMissing(code) {
        return nok(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeReferenceCollapsed(effects, ok, nok) {
    return referenceCollapsedStart;
    /**
   * In reference (collapsed), at `[`.
   *
   * > ðŸ‘‰ **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] d
   *        ^
   * ```
   *
   * @type {State}
   */ function referenceCollapsedStart(code) {
        // We only attempt a collapsed label if thereâ€™s a `[`.
        effects.enter('reference');
        effects.enter('referenceMarker');
        effects.consume(code);
        effects.exit('referenceMarker');
        return referenceCollapsedOpen;
    }
    /**
   * In reference (collapsed), at `]`.
   *
   * > ðŸ‘‰ **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] d
   *         ^
   * ```
   *
   *  @type {State}
   */ function referenceCollapsedOpen(code) {
        if (code === 93) {
            effects.enter('referenceMarker');
            effects.consume(code);
            effects.exit('referenceMarker');
            effects.exit('reference');
            return ok;
        }
        return nok(code);
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9sYWJlbC1lbmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdH0gQ29uc3RydWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5SZXNvbHZlcn0gUmVzb2x2ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICovXG5cbmltcG9ydCB7ZmFjdG9yeURlc3RpbmF0aW9ufSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1kZXN0aW5hdGlvbidcbmltcG9ydCB7ZmFjdG9yeUxhYmVsfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1sYWJlbCdcbmltcG9ydCB7ZmFjdG9yeVRpdGxlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS10aXRsZSdcbmltcG9ydCB7ZmFjdG9yeVdoaXRlc3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXdoaXRlc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ09yU3BhY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7cHVzaCwgc3BsaWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaHVua2VkJ1xuaW1wb3J0IHtub3JtYWxpemVJZGVudGlmaWVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllcidcbmltcG9ydCB7cmVzb2x2ZUFsbH0gZnJvbSAnbWljcm9tYXJrLXV0aWwtcmVzb2x2ZS1hbGwnXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBsYWJlbEVuZCA9IHtcbiAgbmFtZTogJ2xhYmVsRW5kJyxcbiAgdG9rZW5pemU6IHRva2VuaXplTGFiZWxFbmQsXG4gIHJlc29sdmVUbzogcmVzb2x2ZVRvTGFiZWxFbmQsXG4gIHJlc29sdmVBbGw6IHJlc29sdmVBbGxMYWJlbEVuZFxufVxuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmNvbnN0IHJlc291cmNlQ29uc3RydWN0ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVSZXNvdXJjZVxufVxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5jb25zdCByZWZlcmVuY2VGdWxsQ29uc3RydWN0ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVSZWZlcmVuY2VGdWxsXG59XG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmNvbnN0IHJlZmVyZW5jZUNvbGxhcHNlZENvbnN0cnVjdCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplUmVmZXJlbmNlQ29sbGFwc2VkXG59XG5cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5mdW5jdGlvbiByZXNvbHZlQWxsTGFiZWxFbmQoZXZlbnRzKSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IHRva2VuID0gZXZlbnRzW2luZGV4XVsxXVxuICAgIGlmIChcbiAgICAgIHRva2VuLnR5cGUgPT09ICdsYWJlbEltYWdlJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xhYmVsTGluaycgfHxcbiAgICAgIHRva2VuLnR5cGUgPT09ICdsYWJlbEVuZCdcbiAgICApIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbWFya2VyLlxuICAgICAgZXZlbnRzLnNwbGljZShpbmRleCArIDEsIHRva2VuLnR5cGUgPT09ICdsYWJlbEltYWdlJyA/IDQgOiAyKVxuICAgICAgdG9rZW4udHlwZSA9ICdkYXRhJ1xuICAgICAgaW5kZXgrK1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzXG59XG5cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG5mdW5jdGlvbiByZXNvbHZlVG9MYWJlbEVuZChldmVudHMsIGNvbnRleHQpIHtcbiAgbGV0IGluZGV4ID0gZXZlbnRzLmxlbmd0aFxuICBsZXQgb2Zmc2V0ID0gMFxuICAvKiogQHR5cGUge1Rva2VufSAqL1xuICBsZXQgdG9rZW5cbiAgLyoqIEB0eXBlIHtudW1iZXIgfCB1bmRlZmluZWR9ICovXG4gIGxldCBvcGVuXG4gIC8qKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgY2xvc2VcbiAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gIGxldCBtZWRpYVxuXG4gIC8vIEZpbmQgYW4gb3BlbmluZy5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB0b2tlbiA9IGV2ZW50c1tpbmRleF1bMV1cbiAgICBpZiAob3Blbikge1xuICAgICAgLy8gSWYgd2Ugc2VlIGFub3RoZXIgbGluaywgb3IgaW5hY3RpdmUgbGluayBsYWJlbCwgd2XigJl2ZSBiZWVuIGhlcmUgYmVmb3JlLlxuICAgICAgaWYgKFxuICAgICAgICB0b2tlbi50eXBlID09PSAnbGluaycgfHxcbiAgICAgICAgKHRva2VuLnR5cGUgPT09ICdsYWJlbExpbmsnICYmIHRva2VuLl9pbmFjdGl2ZSlcbiAgICAgICkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICAvLyBNYXJrIG90aGVyIGxpbmsgb3BlbmluZ3MgYXMgaW5hY3RpdmUsIGFzIHdlIGNhbuKAmXQgaGF2ZSBsaW5rcyBpblxuICAgICAgLy8gbGlua3MuXG4gICAgICBpZiAoZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJyAmJiB0b2tlbi50eXBlID09PSAnbGFiZWxMaW5rJykge1xuICAgICAgICB0b2tlbi5faW5hY3RpdmUgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjbG9zZSkge1xuICAgICAgaWYgKFxuICAgICAgICBldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInICYmXG4gICAgICAgICh0b2tlbi50eXBlID09PSAnbGFiZWxJbWFnZScgfHwgdG9rZW4udHlwZSA9PT0gJ2xhYmVsTGluaycpICYmXG4gICAgICAgICF0b2tlbi5fYmFsYW5jZWRcbiAgICAgICkge1xuICAgICAgICBvcGVuID0gaW5kZXhcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdsYWJlbExpbmsnKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gMlxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdsYWJlbEVuZCcpIHtcbiAgICAgIGNsb3NlID0gaW5kZXhcbiAgICB9XG4gIH1cbiAgY29uc3QgZ3JvdXAgPSB7XG4gICAgdHlwZTogZXZlbnRzW29wZW5dWzFdLnR5cGUgPT09ICdsYWJlbExpbmsnID8gJ2xpbmsnIDogJ2ltYWdlJyxcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW29wZW5dWzFdLnN0YXJ0KSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uZW5kKVxuICB9XG4gIGNvbnN0IGxhYmVsID0ge1xuICAgIHR5cGU6ICdsYWJlbCcsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tvcGVuXVsxXS5zdGFydCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbY2xvc2VdWzFdLmVuZClcbiAgfVxuICBjb25zdCB0ZXh0ID0ge1xuICAgIHR5cGU6ICdsYWJlbFRleHQnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbb3BlbiArIG9mZnNldCArIDJdWzFdLmVuZCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbY2xvc2UgLSAyXVsxXS5zdGFydClcbiAgfVxuICBtZWRpYSA9IFtcbiAgICBbJ2VudGVyJywgZ3JvdXAsIGNvbnRleHRdLFxuICAgIFsnZW50ZXInLCBsYWJlbCwgY29udGV4dF1cbiAgXVxuXG4gIC8vIE9wZW5pbmcgbWFya2VyLlxuICBtZWRpYSA9IHB1c2gobWVkaWEsIGV2ZW50cy5zbGljZShvcGVuICsgMSwgb3BlbiArIG9mZnNldCArIDMpKVxuXG4gIC8vIFRleHQgb3Blbi5cbiAgbWVkaWEgPSBwdXNoKG1lZGlhLCBbWydlbnRlcicsIHRleHQsIGNvbnRleHRdXSlcblxuICAvLyBBbHdheXMgcG9wdWxhdGVkIGJ5IGRlZmF1bHRzLlxuXG4gIC8vIEJldHdlZW4uXG4gIG1lZGlhID0gcHVzaChcbiAgICBtZWRpYSxcbiAgICByZXNvbHZlQWxsKFxuICAgICAgY29udGV4dC5wYXJzZXIuY29uc3RydWN0cy5pbnNpZGVTcGFuLm51bGwsXG4gICAgICBldmVudHMuc2xpY2Uob3BlbiArIG9mZnNldCArIDQsIGNsb3NlIC0gMyksXG4gICAgICBjb250ZXh0XG4gICAgKVxuICApXG5cbiAgLy8gVGV4dCBjbG9zZSwgbWFya2VyIGNsb3NlLCBsYWJlbCBjbG9zZS5cbiAgbWVkaWEgPSBwdXNoKG1lZGlhLCBbXG4gICAgWydleGl0JywgdGV4dCwgY29udGV4dF0sXG4gICAgZXZlbnRzW2Nsb3NlIC0gMl0sXG4gICAgZXZlbnRzW2Nsb3NlIC0gMV0sXG4gICAgWydleGl0JywgbGFiZWwsIGNvbnRleHRdXG4gIF0pXG5cbiAgLy8gUmVmZXJlbmNlLCByZXNvdXJjZSwgb3Igc28uXG4gIG1lZGlhID0gcHVzaChtZWRpYSwgZXZlbnRzLnNsaWNlKGNsb3NlICsgMSkpXG5cbiAgLy8gTWVkaWEgY2xvc2UuXG4gIG1lZGlhID0gcHVzaChtZWRpYSwgW1snZXhpdCcsIGdyb3VwLCBjb250ZXh0XV0pXG4gIHNwbGljZShldmVudHMsIG9wZW4sIGV2ZW50cy5sZW5ndGgsIG1lZGlhKVxuICByZXR1cm4gZXZlbnRzXG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplTGFiZWxFbmQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgaW5kZXggPSBzZWxmLmV2ZW50cy5sZW5ndGhcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgbGV0IGxhYmVsU3RhcnRcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBsZXQgZGVmaW5lZFxuXG4gIC8vIEZpbmQgYW4gb3BlbmluZy5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBpZiAoXG4gICAgICAoc2VsZi5ldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsYWJlbEltYWdlJyB8fFxuICAgICAgICBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2xhYmVsTGluaycpICYmXG4gICAgICAhc2VsZi5ldmVudHNbaW5kZXhdWzFdLl9iYWxhbmNlZFxuICAgICkge1xuICAgICAgbGFiZWxTdGFydCA9IHNlbGYuZXZlbnRzW2luZGV4XVsxXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIGxhYmVsIGVuZC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXShiKSBjXG4gICAqICAgICAgIF5cbiAgICogPiB8IFthXVtiXSBjXG4gICAqICAgICAgIF5cbiAgICogPiB8IFthXVtdIGJcbiAgICogICAgICAgXlxuICAgKiA+IHwgW2FdIGJcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBub3QgYW4gb2theSBvcGVuaW5nLlxuICAgIGlmICghbGFiZWxTdGFydCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBjb3JyZXNwb25kaW5nIGxhYmVsIChsaW5rKSBzdGFydCBpcyBtYXJrZWQgYXMgaW5hY3RpdmUsXG4gICAgLy8gaXQgbWVhbnMgd2XigJlkIGJlIHdyYXBwaW5nIGEgbGluaywgbGlrZSB0aGlzOlxuICAgIC8vXG4gICAgLy8gYGBgbWFya2Rvd25cbiAgICAvLyA+IHwgYSBbYiBbY10oZCkgZV0oZikgZy5cbiAgICAvLyAgICAgICAgICAgICAgICAgIF5cbiAgICAvLyBgYGBcbiAgICAvL1xuICAgIC8vIFdlIGNhbuKAmXQgaGF2ZSB0aGF0LCBzbyBpdOKAmXMganVzdCBiYWxhbmNlZCBicmFja2V0cy5cbiAgICBpZiAobGFiZWxTdGFydC5faW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBsYWJlbEVuZE5vayhjb2RlKVxuICAgIH1cbiAgICBkZWZpbmVkID0gc2VsZi5wYXJzZXIuZGVmaW5lZC5pbmNsdWRlcyhcbiAgICAgIG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICAgIHNlbGYuc2xpY2VTZXJpYWxpemUoe1xuICAgICAgICAgIHN0YXJ0OiBsYWJlbFN0YXJ0LmVuZCxcbiAgICAgICAgICBlbmQ6IHNlbGYubm93KClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG4gICAgZWZmZWN0cy5lbnRlcignbGFiZWxFbmQnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmV4aXQoJ2xhYmVsRW5kJylcbiAgICByZXR1cm4gYWZ0ZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBgXWAuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV0oYikgY1xuICAgKiAgICAgICBeXG4gICAqID4gfCBbYV1bYl0gY1xuICAgKiAgICAgICBeXG4gICAqID4gfCBbYV1bXSBiXG4gICAqICAgICAgIF5cbiAgICogPiB8IFthXSBiXG4gICAqICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICAvLyBOb3RlOiBgbWFya2Rvd24tcnNgIGFsc28gcGFyc2VzIEdGTSBmb290bm90ZXMgaGVyZSwgd2hpY2ggZm9yIHVzIGlzIGluXG4gICAgLy8gYW4gZXh0ZW5zaW9uLlxuXG4gICAgLy8gUmVzb3VyY2UgKGBbYXNkXShmZ2gpYCk/XG4gICAgaWYgKGNvZGUgPT09IDQwKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICByZXNvdXJjZUNvbnN0cnVjdCxcbiAgICAgICAgbGFiZWxFbmRPayxcbiAgICAgICAgZGVmaW5lZCA/IGxhYmVsRW5kT2sgOiBsYWJlbEVuZE5va1xuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIC8vIEZ1bGwgKGBbYXNkXVtmZ2hdYCkgb3IgY29sbGFwc2VkIChgW2FzZF1bXWApIHJlZmVyZW5jZT9cbiAgICBpZiAoY29kZSA9PT0gOTEpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIHJlZmVyZW5jZUZ1bGxDb25zdHJ1Y3QsXG4gICAgICAgIGxhYmVsRW5kT2ssXG4gICAgICAgIGRlZmluZWQgPyByZWZlcmVuY2VOb3RGdWxsIDogbGFiZWxFbmROb2tcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dCAoYFthc2RdYCkgcmVmZXJlbmNlP1xuICAgIHJldHVybiBkZWZpbmVkID8gbGFiZWxFbmRPayhjb2RlKSA6IGxhYmVsRW5kTm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgYF1gLCBhdCBgW2AsIGJ1dCBub3QgYXQgYSBmdWxsIHJlZmVyZW5jZS5cbiAgICpcbiAgICogPiDwn5GJICoqTm90ZSoqOiB3ZSBvbmx5IGdldCBoZXJlIGlmIHRoZSBsYWJlbCBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW2FdW10gYlxuICAgKiAgICAgICAgXlxuICAgKiA+IHwgW2FdIGJcbiAgICogICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHJlZmVyZW5jZU5vdEZ1bGwoY29kZSkge1xuICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICByZWZlcmVuY2VDb2xsYXBzZWRDb25zdHJ1Y3QsXG4gICAgICBsYWJlbEVuZE9rLFxuICAgICAgbGFiZWxFbmROb2tcbiAgICApKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogRG9uZSwgd2UgZm91bmQgc29tZXRoaW5nLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW2FdKGIpIGNcbiAgICogICAgICAgICAgIF5cbiAgICogPiB8IFthXVtiXSBjXG4gICAqICAgICAgICAgICBeXG4gICAqID4gfCBbYV1bXSBiXG4gICAqICAgICAgICAgIF5cbiAgICogPiB8IFthXSBiXG4gICAqICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBsYWJlbEVuZE9rKGNvZGUpIHtcbiAgICAvLyBOb3RlOiBgbWFya2Rvd24tcnNgIGRvZXMgYSBidW5jaCBvZiBzdHVmZiBoZXJlLlxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIERvbmUsIGl04oCZcyBub3RoaW5nLlxuICAgKlxuICAgKiBUaGVyZSB3YXMgYW4gb2theSBvcGVuaW5nLCBidXQgd2UgZGlkbuKAmXQgbWF0Y2ggYW55dGhpbmcuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV0oYiBjXG4gICAqICAgICAgICBeXG4gICAqID4gfCBbYV1bYiBjXG4gICAqICAgICAgICBeXG4gICAqID4gfCBbYV0gYlxuICAgKiAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gbGFiZWxFbmROb2soY29kZSkge1xuICAgIGxhYmVsU3RhcnQuX2JhbGFuY2VkID0gdHJ1ZVxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVJlc291cmNlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHJlc291cmNlU3RhcnRcblxuICAvKipcbiAgICogQXQgYSByZXNvdXJjZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXShiKSBjXG4gICAqICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiByZXNvdXJjZVN0YXJ0KGNvZGUpIHtcbiAgICBlZmZlY3RzLmVudGVyKCdyZXNvdXJjZScpXG4gICAgZWZmZWN0cy5lbnRlcigncmVzb3VyY2VNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgncmVzb3VyY2VNYXJrZXInKVxuICAgIHJldHVybiByZXNvdXJjZUJlZm9yZVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHJlc291cmNlLCBhZnRlciBgKGAsIGF0IG9wdGlvbmFsIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV0oYikgY1xuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHJlc291cmNlQmVmb3JlKGNvZGUpIHtcbiAgICByZXR1cm4gbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICAgPyBmYWN0b3J5V2hpdGVzcGFjZShlZmZlY3RzLCByZXNvdXJjZU9wZW4pKGNvZGUpXG4gICAgICA6IHJlc291cmNlT3Blbihjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHJlc291cmNlLCBhZnRlciBvcHRpb25hbCB3aGl0ZXNwYWNlLCBhdCBgKWAgb3IgYSBkZXN0aW5hdGlvbi5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXShiKSBjXG4gICAqICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb3VyY2VPcGVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDEpIHtcbiAgICAgIHJldHVybiByZXNvdXJjZUVuZChjb2RlKVxuICAgIH1cbiAgICByZXR1cm4gZmFjdG9yeURlc3RpbmF0aW9uKFxuICAgICAgZWZmZWN0cyxcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25BZnRlcixcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25NaXNzaW5nLFxuICAgICAgJ3Jlc291cmNlRGVzdGluYXRpb24nLFxuICAgICAgJ3Jlc291cmNlRGVzdGluYXRpb25MaXRlcmFsJyxcbiAgICAgICdyZXNvdXJjZURlc3RpbmF0aW9uTGl0ZXJhbE1hcmtlcicsXG4gICAgICAncmVzb3VyY2VEZXN0aW5hdGlvblJhdycsXG4gICAgICAncmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZycsXG4gICAgICAzMlxuICAgICkoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiByZXNvdXJjZSwgYWZ0ZXIgZGVzdGluYXRpb24sIGF0IG9wdGlvbmFsIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV0oYikgY1xuICAgKiAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiByZXNvdXJjZURlc3RpbmF0aW9uQWZ0ZXIoY29kZSkge1xuICAgIHJldHVybiBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgICA/IGZhY3RvcnlXaGl0ZXNwYWNlKGVmZmVjdHMsIHJlc291cmNlQmV0d2VlbikoY29kZSlcbiAgICAgIDogcmVzb3VyY2VFbmQoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBdCBpbnZhbGlkIGRlc3RpbmF0aW9uLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW2FdKDw8KSBiXG4gICAqICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb3VyY2VEZXN0aW5hdGlvbk1pc3NpbmcoY29kZSkge1xuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiByZXNvdXJjZSwgYWZ0ZXIgZGVzdGluYXRpb24gYW5kIHdoaXRlc3BhY2UsIGF0IGAoYCBvciB0aXRsZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXShiICkgY1xuICAgKiAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb3VyY2VCZXR3ZWVuKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gMzQgfHwgY29kZSA9PT0gMzkgfHwgY29kZSA9PT0gNDApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5VGl0bGUoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHJlc291cmNlVGl0bGVBZnRlcixcbiAgICAgICAgbm9rLFxuICAgICAgICAncmVzb3VyY2VUaXRsZScsXG4gICAgICAgICdyZXNvdXJjZVRpdGxlTWFya2VyJyxcbiAgICAgICAgJ3Jlc291cmNlVGl0bGVTdHJpbmcnXG4gICAgICApKGNvZGUpXG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZUVuZChjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHJlc291cmNlLCBhZnRlciB0aXRsZSwgYXQgb3B0aW9uYWwgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXShiIFwiY1wiKSBkXG4gICAqICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiByZXNvdXJjZVRpdGxlQWZ0ZXIoY29kZSkge1xuICAgIHJldHVybiBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgICA/IGZhY3RvcnlXaGl0ZXNwYWNlKGVmZmVjdHMsIHJlc291cmNlRW5kKShjb2RlKVxuICAgICAgOiByZXNvdXJjZUVuZChjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHJlc291cmNlLCBhdCBgKWAuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV0oYikgZFxuICAgKiAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiByZXNvdXJjZUVuZChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDQxKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdyZXNvdXJjZU1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgncmVzb3VyY2VNYXJrZXInKVxuICAgICAgZWZmZWN0cy5leGl0KCdyZXNvdXJjZScpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplUmVmZXJlbmNlRnVsbChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHJldHVybiByZWZlcmVuY2VGdWxsXG5cbiAgLyoqXG4gICAqIEluIGEgcmVmZXJlbmNlIChmdWxsKSwgYXQgdGhlIGBbYC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXVtiXSBkXG4gICAqICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiByZWZlcmVuY2VGdWxsKGNvZGUpIHtcbiAgICByZXR1cm4gZmFjdG9yeUxhYmVsLmNhbGwoXG4gICAgICBzZWxmLFxuICAgICAgZWZmZWN0cyxcbiAgICAgIHJlZmVyZW5jZUZ1bGxBZnRlcixcbiAgICAgIHJlZmVyZW5jZUZ1bGxNaXNzaW5nLFxuICAgICAgJ3JlZmVyZW5jZScsXG4gICAgICAncmVmZXJlbmNlTWFya2VyJyxcbiAgICAgICdyZWZlcmVuY2VTdHJpbmcnXG4gICAgKShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIGEgcmVmZXJlbmNlIChmdWxsKSwgYWZ0ZXIgYF1gLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW2FdW2JdIGRcbiAgICogICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVmZXJlbmNlRnVsbEFmdGVyKGNvZGUpIHtcbiAgICByZXR1cm4gc2VsZi5wYXJzZXIuZGVmaW5lZC5pbmNsdWRlcyhcbiAgICAgIG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICAgIHNlbGYuc2xpY2VTZXJpYWxpemUoc2VsZi5ldmVudHNbc2VsZi5ldmVudHMubGVuZ3RoIC0gMV1bMV0pLnNsaWNlKDEsIC0xKVxuICAgICAgKVxuICAgIClcbiAgICAgID8gb2soY29kZSlcbiAgICAgIDogbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gcmVmZXJlbmNlIChmdWxsKSB0aGF0IHdhcyBtaXNzaW5nLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW2FdW2IgZFxuICAgKiAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVmZXJlbmNlRnVsbE1pc3NpbmcoY29kZSkge1xuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVJlZmVyZW5jZUNvbGxhcHNlZChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIHJldHVybiByZWZlcmVuY2VDb2xsYXBzZWRTdGFydFxuXG4gIC8qKlxuICAgKiBJbiByZWZlcmVuY2UgKGNvbGxhcHNlZCksIGF0IGBbYC5cbiAgICpcbiAgICogPiDwn5GJICoqTm90ZSoqOiB3ZSBvbmx5IGdldCBoZXJlIGlmIHRoZSBsYWJlbCBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW2FdW10gZFxuICAgKiAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVmZXJlbmNlQ29sbGFwc2VkU3RhcnQoY29kZSkge1xuICAgIC8vIFdlIG9ubHkgYXR0ZW1wdCBhIGNvbGxhcHNlZCBsYWJlbCBpZiB0aGVyZeKAmXMgYSBgW2AuXG5cbiAgICBlZmZlY3RzLmVudGVyKCdyZWZlcmVuY2UnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ3JlZmVyZW5jZU1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdyZWZlcmVuY2VNYXJrZXInKVxuICAgIHJldHVybiByZWZlcmVuY2VDb2xsYXBzZWRPcGVuXG4gIH1cblxuICAvKipcbiAgICogSW4gcmVmZXJlbmNlIChjb2xsYXBzZWQpLCBhdCBgXWAuXG4gICAqXG4gICAqID4g8J+RiSAqKk5vdGUqKjogd2Ugb25seSBnZXQgaGVyZSBpZiB0aGUgbGFiZWwgaXMgZGVmaW5lZC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXVtdIGRcbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiAgQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVmZXJlbmNlQ29sbGFwc2VkT3Blbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdyZWZlcmVuY2VNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3JlZmVyZW5jZU1hcmtlcicpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3JlZmVyZW5jZScpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG4iXSwibmFtZXMiOlsibGFiZWxFbmQiLCJuYW1lIiwidG9rZW5pemUiLCJ0b2tlbml6ZUxhYmVsRW5kIiwicmVzb2x2ZVRvIiwicmVzb2x2ZVRvTGFiZWxFbmQiLCJyZXNvbHZlQWxsIiwicmVzb2x2ZUFsbExhYmVsRW5kIiwicmVzb3VyY2VDb25zdHJ1Y3QiLCJ0b2tlbml6ZVJlc291cmNlIiwicmVmZXJlbmNlRnVsbENvbnN0cnVjdCIsInRva2VuaXplUmVmZXJlbmNlRnVsbCIsInJlZmVyZW5jZUNvbGxhcHNlZENvbnN0cnVjdCIsInRva2VuaXplUmVmZXJlbmNlQ29sbGFwc2VkIiwiZXZlbnRzIiwiaW5kZXgiLCJsZW5ndGgiLCJ0b2tlbiIsInR5cGUiLCJzcGxpY2UiLCJjb250ZXh0Iiwib2Zmc2V0Iiwib3BlbiIsImNsb3NlIiwibWVkaWEiLCJfaW5hY3RpdmUiLCJfYmFsYW5jZWQiLCJncm91cCIsInN0YXJ0IiwiT2JqZWN0IiwiYXNzaWduIiwiZW5kIiwibGFiZWwiLCJ0ZXh0IiwicHVzaCIsInNsaWNlIiwicGFyc2VyIiwiY29uc3RydWN0cyIsImluc2lkZVNwYW4iLCJudWxsIiwiZWZmZWN0cyIsIm9rIiwibm9rIiwic2VsZiIsImxhYmVsU3RhcnQiLCJkZWZpbmVkIiwiY29kZSIsImxhYmVsRW5kTm9rIiwiaW5jbHVkZXMiLCJub3JtYWxpemVJZGVudGlmaWVyIiwic2xpY2VTZXJpYWxpemUiLCJub3ciLCJlbnRlciIsImNvbnN1bWUiLCJleGl0IiwiYWZ0ZXIiLCJhdHRlbXB0IiwibGFiZWxFbmRPayIsInJlZmVyZW5jZU5vdEZ1bGwiLCJyZXNvdXJjZVN0YXJ0IiwicmVzb3VyY2VCZWZvcmUiLCJtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlIiwiZmFjdG9yeVdoaXRlc3BhY2UiLCJyZXNvdXJjZU9wZW4iLCJyZXNvdXJjZUVuZCIsImZhY3RvcnlEZXN0aW5hdGlvbiIsInJlc291cmNlRGVzdGluYXRpb25BZnRlciIsInJlc291cmNlRGVzdGluYXRpb25NaXNzaW5nIiwicmVzb3VyY2VCZXR3ZWVuIiwiZmFjdG9yeVRpdGxlIiwicmVzb3VyY2VUaXRsZUFmdGVyIiwicmVmZXJlbmNlRnVsbCIsImZhY3RvcnlMYWJlbCIsImNhbGwiLCJyZWZlcmVuY2VGdWxsQWZ0ZXIiLCJyZWZlcmVuY2VGdWxsTWlzc2luZyIsInJlZmVyZW5jZUNvbGxhcHNlZFN0YXJ0IiwicmVmZXJlbmNlQ29sbGFwc2VkT3BlbiJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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