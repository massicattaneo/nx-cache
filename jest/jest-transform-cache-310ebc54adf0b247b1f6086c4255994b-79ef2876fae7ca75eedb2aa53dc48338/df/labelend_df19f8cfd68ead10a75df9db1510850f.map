{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-core-commonmark/lib/label-end.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  while (++index < events.length) {\n    const token = events[index][1]\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code)\n    }\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n    return nok(code)\n  }\n}\n"],"names":["labelEnd","name","tokenize","tokenizeLabelEnd","resolveTo","resolveToLabelEnd","resolveAll","resolveAllLabelEnd","resourceConstruct","tokenizeResource","referenceFullConstruct","tokenizeReferenceFull","referenceCollapsedConstruct","tokenizeReferenceCollapsed","events","index","length","token","type","splice","context","offset","open","close","media","_inactive","_balanced","group","start","Object","assign","end","label","text","push","slice","parser","constructs","insideSpan","null","effects","ok","nok","self","labelStart","defined","code","labelEndNok","includes","normalizeIdentifier","sliceSerialize","now","enter","consume","exit","after","attempt","labelEndOk","referenceNotFull","resourceStart","resourceBefore","markdownLineEndingOrSpace","factoryWhitespace","resourceOpen","resourceEnd","factoryDestination","resourceDestinationAfter","resourceDestinationMissing","resourceBetween","factoryTitle","resourceTitleAfter","referenceFull","factoryLabel","call","referenceFullAfter","referenceFullMissing","referenceCollapsedStart","referenceCollapsedOpen"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}