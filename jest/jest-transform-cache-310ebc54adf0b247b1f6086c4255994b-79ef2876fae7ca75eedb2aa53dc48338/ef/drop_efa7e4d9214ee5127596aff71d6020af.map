{"version":3,"sources":["../../../src/actions/dragDrop/drop.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\n\nimport type {\n\tAction,\n\tDragDropManager,\n\tDragDropMonitor,\n\tDropPayload,\n\tHandlerRegistry,\n\tIdentifier,\n} from '../../interfaces.js'\nimport { isObject } from '../../utils/js_utils.js'\nimport { DROP } from './types.js'\n\nexport function createDrop(manager: DragDropManager) {\n\treturn function drop(options = {}): void {\n\t\tconst monitor = manager.getMonitor()\n\t\tconst registry = manager.getRegistry()\n\t\tverifyInvariants(monitor)\n\t\tconst targetIds = getDroppableTargets(monitor)\n\n\t\t// Multiple actions are dispatched here, which is why this doesn't return an action\n\t\ttargetIds.forEach((targetId, index) => {\n\t\t\tconst dropResult = determineDropResult(targetId, index, registry, monitor)\n\t\t\tconst action: Action<DropPayload> = {\n\t\t\t\ttype: DROP,\n\t\t\t\tpayload: {\n\t\t\t\t\tdropResult: {\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\t...dropResult,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tmanager.dispatch(action)\n\t\t})\n\t}\n}\n\nfunction verifyInvariants(monitor: DragDropMonitor) {\n\tinvariant(monitor.isDragging(), 'Cannot call drop while not dragging.')\n\tinvariant(\n\t\t!monitor.didDrop(),\n\t\t'Cannot call drop twice during one drag operation.',\n\t)\n}\n\nfunction determineDropResult(\n\ttargetId: Identifier,\n\tindex: number,\n\tregistry: HandlerRegistry,\n\tmonitor: DragDropMonitor,\n) {\n\tconst target = registry.getTarget(targetId)\n\tlet dropResult = target ? target.drop(monitor, targetId) : undefined\n\tverifyDropResultType(dropResult)\n\tif (typeof dropResult === 'undefined') {\n\t\tdropResult = index === 0 ? {} : monitor.getDropResult()\n\t}\n\treturn dropResult\n}\n\nfunction verifyDropResultType(dropResult: any) {\n\tinvariant(\n\t\ttypeof dropResult === 'undefined' || isObject(dropResult),\n\t\t'Drop result must either be an object or undefined.',\n\t)\n}\n\nfunction getDroppableTargets(monitor: DragDropMonitor) {\n\tconst targetIds = monitor\n\t\t.getTargetIds()\n\t\t.filter(monitor.canDropOnTarget, monitor)\n\ttargetIds.reverse()\n\treturn targetIds\n}\n"],"names":["createDrop","_defineProperty","obj","key","value","manager","drop","options","monitor","getMonitor","registry","getRegistry","verifyInvariants","targetIds","getDroppableTargets","forEach","targetId","index","dropResult","determineDropResult","action","type","DROP","payload","_objectSpread","dispatch","invariant","isDragging","didDrop","target","getTarget","undefined","verifyDropResultType","getDropResult","isObject","getTargetIds","filter","canDropOnTarget","reverse"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAagBA;;;eAAAA;;;2BAbU;0BAUD;uBACJ;AAXrB,SAAAC,gBAAAC,GAAA,EAAAC,GAAA,EAAAC,KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaO,SAASJ,WAAWK,OAAwB;IAClD,OAAO,SAASC,KAAKC,UAAU,CAAA,CAAE;QAChC,MAAMC,UAAUH,QAAQI,UAAU;QAClC,MAAMC,WAAWL,QAAQM,WAAW;QACpCC,iBAAiBJ;QACjB,MAAMK,YAAYC,oBAAoBN;QAEtC,mFAAmF;QACnFK,UAAUE,OAAO,CAAC,CAACC,UAAUC;YAC5B,MAAMC,aAAaC,oBAAoBH,UAAUC,OAAOP,UAAUF;YAClE,MAAMY,SAA8B;gBACnCC,MAAMC,WAAI;gBACVC,SAAS;oBACRL,YAAYM,cAAA,CAAA,GACRjB,SACAW;;;YAINb,QAAQoB,QAAQ,CAACL;;;;AAKpB,SAASR,iBAAiBJ,OAAwB;IACjDkB,IAAAA,oBAAS,EAAClB,QAAQmB,UAAU,IAAI;IAChCD,IAAAA,oBAAS,EACR,CAAClB,QAAQoB,OAAO,IAChB;;AAIF,SAAST,oBACRH,QAAoB,EACpBC,KAAa,EACbP,QAAyB,EACzBF,OAAwB;IAExB,MAAMqB,SAASnB,SAASoB,SAAS,CAACd;IAClC,IAAIE,aAAaW,SAASA,OAAOvB,IAAI,CAACE,SAASQ,YAAYe;IAC3DC,qBAAqBd;IACrB,IAAI,OAAOA,eAAe,aAAa;QACtCA,aAAaD,UAAU,IAAI,CAAA,IAAKT,QAAQyB,aAAa;;IAEtD,OAAOf;;AAGR,SAASc,qBAAqBd,UAAe;IAC5CQ,IAAAA,oBAAS,EACR,OAAOR,eAAe,eAAegB,IAAAA,kBAAQ,EAAChB,aAC9C;;AAIF,SAASJ,oBAAoBN,OAAwB;IACpD,MAAMK,YAAYL,QAChB2B,YAAY,GACZC,MAAM,CAAC5B,QAAQ6B,eAAe,EAAE7B;IAClCK,UAAUyB,OAAO;IACjB,OAAOzB"}