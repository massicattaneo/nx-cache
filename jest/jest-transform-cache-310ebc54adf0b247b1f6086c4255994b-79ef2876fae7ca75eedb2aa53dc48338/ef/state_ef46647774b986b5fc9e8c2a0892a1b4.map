{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/mdast-util-to-hast/lib/state.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: 'â†©'}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the `â†©`\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `â†©` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > ðŸ‘‰ **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a nodeâ€™s positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {visit} from 'unist-util-visit'\nimport {position} from 'unist-util-position'\nimport {handlers as defaultHandlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map()\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map()\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map()\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {...defaultHandlers, ...settings.handlers}\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  }\n\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById\n      const id = String(node.identifier).toUpperCase()\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node)\n      }\n    }\n  })\n\n  return state\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n  function one(node, parent) {\n    const type = node.type\n    const handle = state.handlers[type]\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent)\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {children, ...shallow} = node\n        const result = structuredClone(shallow)\n        // @ts-expect-error: TS doesnâ€™t understandâ€¦\n        result.children = state.all(node)\n        // @ts-expect-error: TS doesnâ€™t understandâ€¦\n        return result\n      }\n\n      // @ts-expect-error: itâ€™s custom.\n      return structuredClone(node)\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\n\n    return unknown(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = []\n\n    if ('children' in parent) {\n      const nodes = parent.children\n      let index = -1\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent)\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value)\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0]\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value)\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result)\n          } else {\n            values.push(result)\n          }\n        }\n      }\n    }\n\n    return values\n  }\n}\n\n/**\n * Copy a nodeâ€™s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result]\n        result = {type: 'element', tagName: hName, properties: {}, children}\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties))\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastElement | HastText} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: state.all(node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0\n  let code = value.charCodeAt(index)\n\n  while (code === 9 || code === 32) {\n    index++\n    code = value.charCodeAt(index)\n  }\n\n  return value.slice(index)\n}\n"],"names":["createState","wrap","own","hasOwnProperty","emptyOptions","tree","options","settings","definitionById","Map","footnoteById","footnoteCounts","handlers","defaultHandlers","state","all","applyData","footnoteOrder","one","patch","visit","node","type","map","id","String","identifier","toUpperCase","has","set","parent","handle","call","passThrough","includes","children","shallow","result","structuredClone","unknown","unknownHandler","defaultUnknownHandler","values","nodes","index","length","Array","isArray","value","trimMarkdownSpaceStart","head","push","from","to","position","data","hName","hChildren","hProperties","tagName","properties","Object","assign","undefined","loose","code","charCodeAt","slice"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}