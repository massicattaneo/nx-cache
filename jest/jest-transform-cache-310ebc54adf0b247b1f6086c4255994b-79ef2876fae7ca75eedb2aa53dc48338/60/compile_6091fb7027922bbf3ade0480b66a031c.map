{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark/lib/compile.js"],"sourcesContent":["/**\n * While micromark is a lexer/tokenizer, the common case of going from markdown\n * to html is currently built in as this module, even though the parts can be\n * used separately to build ASTs, CSTs, or many other output formats.\n *\n * Having an HTML compiler built in is useful because it allows us to check for\n * compliancy to CommonMark, the de facto norm of markdown, specified in roughly\n * 600 input/output cases.\n *\n * This module has an interface that accepts lists of events instead of the\n * whole at once, however, because markdown can’t be truly streaming, we buffer\n * events before processing and outputting the final result.\n */\n\n/**\n * @typedef {import('micromark-util-types').Compile} Compile\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').CompileData} CompileData\n * @typedef {import('micromark-util-types').CompileOptions} CompileOptions\n * @typedef {import('micromark-util-types').Definition} Definition\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Handle} Handle\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').NormalizedHtmlExtension} NormalizedHtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef Media\n * @property {boolean | undefined} [image]\n * @property {string | undefined} [labelId]\n * @property {string | undefined} [label]\n * @property {string | undefined} [referenceId]\n * @property {string | undefined} [destination]\n * @property {string | undefined} [title]\n */\n\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {push} from 'micromark-util-chunked'\nimport {combineHtmlExtensions} from 'micromark-util-combine-extensions'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {encode as _encode} from 'micromark-util-encode'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * These two are allowlists of safe protocols for full URLs in respectively the\n * `href` (on `<a>`) and `src` (on `<img>`) attributes.\n * They are based on what is allowed on GitHub,\n * <https://github.com/syntax-tree/hast-util-sanitize/blob/9275b21/lib/github.json#L31>\n */\nconst protocolHref = /^(https?|ircs?|mailto|xmpp)$/i\nconst protocolSrc = /^https?$/i\n\n/**\n * @param {CompileOptions | null | undefined} [options]\n * @returns {Compile}\n */\nexport function compile(options) {\n  const settings = options || {}\n\n  /**\n   * Tags is needed because according to markdown, links and emphasis and\n   * whatnot can exist in images, however, as HTML doesn’t allow content in\n   * images, the tags are ignored in the `alt` attribute, but the content\n   * remains.\n   *\n   * @type {boolean | undefined}\n   */\n  let tags = true\n\n  /**\n   * An object to track identifiers to media (URLs and titles) defined with\n   * definitions.\n   *\n   * @type {Record<string, Definition>}\n   */\n  const definitions = {}\n\n  /**\n   * A lot of the handlers need to capture some of the output data, modify it\n   * somehow, and then deal with it.\n   * We do that by tracking a stack of buffers, that can be opened (with\n   * `buffer`) and closed (with `resume`) to access them.\n   *\n   * @type {Array<Array<string>>}\n   */\n  const buffers = [[]]\n\n  /**\n   * As we can have links in images and the other way around, where the deepest\n   * ones are closed first, we need to track which one we’re in.\n   *\n   * @type {Array<Media>}\n   */\n  const mediaStack = []\n\n  /**\n   * Same as `mediaStack` for tightness, which is specific to lists.\n   * We need to track if we’re currently in a tight or loose container.\n   *\n   * @type {Array<boolean>}\n   */\n  const tightStack = []\n\n  /** @type {HtmlExtension} */\n  const defaultHandlers = {\n    enter: {\n      blockQuote: onenterblockquote,\n      codeFenced: onentercodefenced,\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: onentercodeindented,\n      codeText: onentercodetext,\n      content: onentercontent,\n      definition: onenterdefinition,\n      definitionDestinationString: onenterdefinitiondestinationstring,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: onenteremphasis,\n      htmlFlow: onenterhtmlflow,\n      htmlText: onenterhtml,\n      image: onenterimage,\n      label: buffer,\n      link: onenterlink,\n      listItemMarker: onenterlistitemmarker,\n      listItemValue: onenterlistitemvalue,\n      listOrdered: onenterlistordered,\n      listUnordered: onenterlistunordered,\n      paragraph: onenterparagraph,\n      reference: buffer,\n      resource: onenterresource,\n      resourceDestinationString: onenterresourcedestinationstring,\n      resourceTitleString: buffer,\n      setextHeading: onentersetextheading,\n      strong: onenterstrong\n    },\n    exit: {\n      atxHeading: onexitatxheading,\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: onexitblockquote,\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: onexitflowcode,\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onresumedrop,\n      codeFlowValue: onexitcodeflowvalue,\n      codeIndented: onexitflowcode,\n      codeText: onexitcodetext,\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: onexitdefinition,\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: onexitemphasis,\n      hardBreakEscape: onexithardbreak,\n      hardBreakTrailing: onexithardbreak,\n      htmlFlow: onexithtml,\n      htmlFlowData: onexitdata,\n      htmlText: onexithtml,\n      htmlTextData: onexitdata,\n      image: onexitmedia,\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: onexitmedia,\n      listOrdered: onexitlistordered,\n      listUnordered: onexitlistunordered,\n      paragraph: onexitparagraph,\n      reference: onresumedrop,\n      referenceString: onexitreferencestring,\n      resource: onresumedrop,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      setextHeading: onexitsetextheading,\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: onexitstrong,\n      thematicBreak: onexitthematicbreak\n    }\n  }\n\n  /**\n   * Combine the HTML extensions with the default handlers.\n   * An HTML extension is an object whose fields are either `enter` or `exit`\n   * (reflecting whether a token is entered or exited).\n   * The values at such objects are names of tokens mapping to handlers.\n   * Handlers are called, respectively when a token is opener or closed, with\n   * that token, and a context as `this`.\n   */\n  const handlers =\n    /** @type {NormalizedHtmlExtension} */\n    combineHtmlExtensions(\n      [defaultHandlers].concat(settings.htmlExtensions || [])\n    )\n\n  /**\n   * Handlers do often need to keep track of some state.\n   * That state is provided here as a key-value store (an object).\n   *\n   * @type {CompileData}\n   */\n  const data = {\n    tightStack,\n    definitions\n  }\n\n  /**\n   * The context for handlers references a couple of useful functions.\n   * In handlers from extensions, those can be accessed at `this`.\n   * For the handlers here, they can be accessed directly.\n   *\n   * @type {Omit<CompileContext, 'sliceSerialize'>}\n   */\n  const context = {\n    lineEndingIfNeeded,\n    options: settings,\n    encode,\n    raw,\n    tag,\n    buffer,\n    resume,\n    setData,\n    getData\n  }\n\n  /**\n   * Generally, micromark copies line endings (`'\\r'`, `'\\n'`, `'\\r\\n'`) in the\n   * markdown document over to the compiled HTML.\n   * In some cases, such as `> a`, CommonMark requires that extra line endings\n   * are added: `<blockquote>\\n<p>a</p>\\n</blockquote>`.\n   * This variable hold the default line ending when given (or `undefined`),\n   * and in the latter case will be updated to the first found line ending if\n   * there is one.\n   */\n  let lineEndingStyle = settings.defaultLineEnding\n\n  // Return the function that handles a slice of events.\n  return compile\n\n  /**\n   * Deal w/ a slice of events.\n   * Return either the empty string if there’s nothing of note to return, or the\n   * result when done.\n   *\n   * @param {Array<Event>} events\n   * @returns {string}\n   */\n  function compile(events) {\n    let index = -1\n    let start = 0\n    /** @type {Array<number>} */\n    const listStack = []\n    // As definitions can come after references, we need to figure out the media\n    // (urls and titles) defined by them before handling the references.\n    // So, we do sort of what HTML does: put metadata at the start (in head), and\n    // then put content after (`body`).\n    /** @type {Array<Event>} */\n    let head = []\n    /** @type {Array<Event>} */\n    let body = []\n    while (++index < events.length) {\n      // Figure out the line ending style used in the document.\n      if (\n        !lineEndingStyle &&\n        (events[index][1].type === 'lineEnding' ||\n          events[index][1].type === 'lineEndingBlank')\n      ) {\n        // @ts-expect-error Hush, it’s a line ending.\n        lineEndingStyle = events[index][2].sliceSerialize(events[index][1])\n      }\n\n      // Preprocess lists to infer whether the list is loose or not.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          prepareList(events.slice(listStack.pop(), index))\n        }\n      }\n\n      // Move definitions to the front.\n      if (events[index][1].type === 'definition') {\n        if (events[index][0] === 'enter') {\n          body = push(body, events.slice(start, index))\n          start = index\n        } else {\n          head = push(head, events.slice(start, index + 1))\n          start = index + 1\n        }\n      }\n    }\n    head = push(head, body)\n    head = push(head, events.slice(start))\n    index = -1\n    const result = head\n\n    // Handle the start of the document, if defined.\n    if (handlers.enter.null) {\n      handlers.enter.null.call(context)\n    }\n\n    // Handle all events.\n    while (++index < events.length) {\n      const handles = handlers[result[index][0]]\n      const kind = result[index][1].type\n      const handle = handles[kind]\n      if (hasOwnProperty.call(handles, kind) && handle) {\n        handle.call(\n          Object.assign(\n            {\n              sliceSerialize: result[index][2].sliceSerialize\n            },\n            context\n          ),\n          result[index][1]\n        )\n      }\n    }\n\n    // Handle the end of the document, if defined.\n    if (handlers.exit.null) {\n      handlers.exit.null.call(context)\n    }\n    return buffers[0].join('')\n  }\n\n  /**\n   * Figure out whether lists are loose or not.\n   *\n   * @param {Array<Event>} slice\n   * @returns {undefined}\n   */\n  function prepareList(slice) {\n    const length = slice.length\n    let index = 0 // Skip open.\n    let containerBalance = 0\n    let loose = false\n    /** @type {boolean | undefined} */\n    let atMarker\n    while (++index < length) {\n      const event = slice[index]\n      if (event[1]._container) {\n        atMarker = undefined\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n      } else\n        switch (event[1].type) {\n          case 'listItemPrefix': {\n            if (event[0] === 'exit') {\n              atMarker = true\n            }\n            break\n          }\n          case 'linePrefix': {\n            // Ignore\n\n            break\n          }\n          case 'lineEndingBlank': {\n            if (event[0] === 'enter' && !containerBalance) {\n              if (atMarker) {\n                atMarker = undefined\n              } else {\n                loose = true\n              }\n            }\n            break\n          }\n          default: {\n            atMarker = undefined\n          }\n        }\n    }\n    slice[0][1]._loose = loose\n  }\n\n  /**\n   * @type {CompileContext['setData']}\n   */\n  function setData(key, value) {\n    // @ts-expect-error: assume `value` is omitted (`undefined` is passed) only\n    // if allowed.\n    data[key] = value\n  }\n\n  /**\n   * @type {CompileContext['getData']}\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /** @type {CompileContext['buffer']} */\n  function buffer() {\n    buffers.push([])\n  }\n\n  /** @type {CompileContext['resume']} */\n  function resume() {\n    const buf = buffers.pop()\n    return buf.join('')\n  }\n\n  /** @type {CompileContext['tag']} */\n  function tag(value) {\n    if (!tags) return\n    setData('lastWasTag', true)\n    buffers[buffers.length - 1].push(value)\n  }\n\n  /** @type {CompileContext['raw']} */\n  function raw(value) {\n    setData('lastWasTag')\n    buffers[buffers.length - 1].push(value)\n  }\n\n  /**\n   * Output an extra line ending.\n   *\n   * @returns {undefined}\n   */\n  function lineEnding() {\n    raw(lineEndingStyle || '\\n')\n  }\n\n  /** @type {CompileContext['lineEndingIfNeeded']} */\n  function lineEndingIfNeeded() {\n    const buffer = buffers[buffers.length - 1]\n    const slice = buffer[buffer.length - 1]\n    const previous = slice ? slice.charCodeAt(slice.length - 1) : null\n    if (previous === 10 || previous === 13 || previous === null) {\n      return\n    }\n    lineEnding()\n  }\n\n  /** @type {CompileContext['encode']} */\n  function encode(value) {\n    return getData('ignoreEncode') ? value : _encode(value)\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @returns {undefined}\n   */\n  function onresumedrop() {\n    resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered(token) {\n    tightStack.push(!token._loose)\n    lineEndingIfNeeded()\n    tag('<ol')\n    setData('expectFirstItem', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistunordered(token) {\n    tightStack.push(!token._loose)\n    lineEndingIfNeeded()\n    tag('<ul')\n    setData('expectFirstItem', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectFirstItem')) {\n      const value = Number.parseInt(this.sliceSerialize(token), 10)\n      if (value !== 1) {\n        tag(' start=\"' + encode(String(value)) + '\"')\n      }\n    }\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterlistitemmarker() {\n    if (getData('expectFirstItem')) {\n      tag('>')\n    } else {\n      onexitlistitem()\n    }\n    lineEndingIfNeeded()\n    tag('<li>')\n    setData('expectFirstItem')\n    // “Hack” to prevent a line ending from showing up if the item is empty.\n    setData('lastWasTag')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistordered() {\n    onexitlistitem()\n    tightStack.pop()\n    lineEnding()\n    tag('</ol>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistunordered() {\n    onexitlistitem()\n    tightStack.pop()\n    lineEnding()\n    tag('</ul>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistitem() {\n    if (getData('lastWasTag') && !getData('slurpAllLineEndings')) {\n      lineEndingIfNeeded()\n    }\n    tag('</li>')\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterblockquote() {\n    tightStack.push(false)\n    lineEndingIfNeeded()\n    tag('<blockquote>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitblockquote() {\n    tightStack.pop()\n    lineEndingIfNeeded()\n    tag('</blockquote>')\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterparagraph() {\n    if (!tightStack[tightStack.length - 1]) {\n      lineEndingIfNeeded()\n      tag('<p>')\n    }\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitparagraph() {\n    if (tightStack[tightStack.length - 1]) {\n      setData('slurpAllLineEndings', true)\n    } else {\n      tag('</p>')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercodefenced() {\n    lineEndingIfNeeded()\n    tag('<pre><code')\n    setData('fencesCount', 0)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const value = resume()\n    tag(' class=\"language-' + value + '\"')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    const count = getData('fencesCount') || 0\n    if (!count) {\n      tag('>')\n      setData('slurpOneLineEnding', true)\n    }\n    setData('fencesCount', count + 1)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercodeindented() {\n    lineEndingIfNeeded()\n    tag('<pre><code>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitflowcode() {\n    const count = getData('fencesCount')\n\n    // One special case is if we are inside a container, and the fenced code was\n    // not closed (meaning it runs to the end).\n    // In that case, the following line ending, is considered *outside* the\n    // fenced code and block quote by micromark, but CM wants to treat that\n    // ending as part of the code.\n    if (\n      count !== undefined &&\n      count < 2 &&\n      data.tightStack.length > 0 &&\n      !getData('lastWasTag')\n    ) {\n      lineEnding()\n    }\n\n    // But in most cases, it’s simpler: when we’ve seen some data, emit an extra\n    // line ending when needed.\n    if (getData('flowCodeSeenData')) {\n      lineEndingIfNeeded()\n    }\n    tag('</code></pre>')\n    if (count !== undefined && count < 2) lineEndingIfNeeded()\n    setData('flowCodeSeenData')\n    setData('fencesCount')\n    setData('slurpOneLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterimage() {\n    mediaStack.push({\n      image: true\n    })\n    tags = undefined // Disallow tags.\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlink() {\n    mediaStack.push({})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlabeltext(token) {\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlabel() {\n    mediaStack[mediaStack.length - 1].label = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitreferencestring(token) {\n    mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterresource() {\n    buffer() // We can have line endings in the resource, ignore them.\n    mediaStack[mediaStack.length - 1].destination = ''\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterresourcedestinationstring() {\n    buffer()\n    // Ignore encoding the result, as we’ll first percent encode the url and\n    // encode manually after.\n    setData('ignoreEncode', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitresourcedestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume()\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitresourcetitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitmedia() {\n    let index = mediaStack.length - 1 // Skip current.\n    const media = mediaStack[index]\n    const id = media.referenceId || media.labelId\n    const context =\n      media.destination === undefined\n        ? definitions[normalizeIdentifier(id)]\n        : media\n    tags = true\n    while (index--) {\n      if (mediaStack[index].image) {\n        tags = undefined\n        break\n      }\n    }\n    if (media.image) {\n      tag(\n        '<img src=\"' +\n          sanitizeUri(\n            context.destination,\n            settings.allowDangerousProtocol ? undefined : protocolSrc\n          ) +\n          '\" alt=\"'\n      )\n      raw(media.label)\n      tag('\"')\n    } else {\n      tag(\n        '<a href=\"' +\n          sanitizeUri(\n            context.destination,\n            settings.allowDangerousProtocol ? undefined : protocolHref\n          ) +\n          '\"'\n      )\n    }\n    tag(context.title ? ' title=\"' + context.title + '\"' : '')\n    if (media.image) {\n      tag(' />')\n    } else {\n      tag('>')\n      raw(media.label)\n      tag('</a>')\n    }\n    mediaStack.pop()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterdefinition() {\n    buffer()\n    mediaStack.push({})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    resume()\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterdefinitiondestinationstring() {\n    buffer()\n    setData('ignoreEncode', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume()\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinition() {\n    const media = mediaStack[mediaStack.length - 1]\n    const id = normalizeIdentifier(media.labelId)\n    resume()\n    if (!hasOwnProperty.call(definitions, id)) {\n      definitions[id] = mediaStack[mediaStack.length - 1]\n    }\n    mediaStack.pop()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercontent() {\n    setData('slurpAllLineEndings', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    // Exit for further sequences.\n    if (getData('headingRank')) return\n    setData('headingRank', this.sliceSerialize(token).length)\n    lineEndingIfNeeded()\n    tag('<h' + getData('headingRank') + '>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentersetextheading() {\n    buffer()\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('slurpAllLineEndings', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheading() {\n    tag('</h' + getData('headingRank') + '>')\n    setData('headingRank')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    setData(\n      'headingRank',\n      this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    const value = resume()\n    lineEndingIfNeeded()\n    tag('<h' + getData('headingRank') + '>')\n    raw(value)\n    tag('</h' + getData('headingRank') + '>')\n    setData('slurpAllLineEndings')\n    setData('headingRank')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdata(token) {\n    raw(encode(this.sliceSerialize(token)))\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlineending(token) {\n    if (getData('slurpAllLineEndings')) {\n      return\n    }\n    if (getData('slurpOneLineEnding')) {\n      setData('slurpOneLineEnding')\n      return\n    }\n    if (getData('inCodeText')) {\n      raw(' ')\n      return\n    }\n    raw(encode(this.sliceSerialize(token)))\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeflowvalue(token) {\n    raw(encode(this.sliceSerialize(token)))\n    setData('flowCodeSeenData', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexithardbreak() {\n    tag('<br />')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterhtmlflow() {\n    lineEndingIfNeeded()\n    onenterhtml()\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexithtml() {\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterhtml() {\n    if (settings.allowDangerousHtml) {\n      setData('ignoreEncode', true)\n    }\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenteremphasis() {\n    tag('<em>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterstrong() {\n    tag('<strong>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onentercodetext() {\n    setData('inCodeText', true)\n    tag('<code>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitcodetext() {\n    setData('inCodeText')\n    tag('</code>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitemphasis() {\n    tag('</em>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitstrong() {\n    tag('</strong>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitthematicbreak() {\n    lineEndingIfNeeded()\n    tag('<hr />')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @param {Token} token\n   * @returns {undefined}\n   */\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    let value = this.sliceSerialize(token)\n\n    // @ts-expect-error `decodeNamedCharacterReference` can return false for\n    // invalid named character references, but everything we’ve tokenized is\n    // valid.\n    value = getData('characterReferenceType')\n      ? decodeNumericCharacterReference(\n          value,\n          getData('characterReferenceType') ===\n            'characterReferenceMarkerNumeric'\n            ? 10\n            : 16\n        )\n      : decodeNamedCharacterReference(value)\n    raw(encode(value))\n    setData('characterReferenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    const uri = this.sliceSerialize(token)\n    tag(\n      '<a href=\"' +\n        sanitizeUri(\n          uri,\n          settings.allowDangerousProtocol ? undefined : protocolHref\n        ) +\n        '\">'\n    )\n    raw(encode(uri))\n    tag('</a>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    const uri = this.sliceSerialize(token)\n    tag('<a href=\"' + sanitizeUri('mailto:' + uri) + '\">')\n    raw(encode(uri))\n    tag('</a>')\n  }\n}\n"],"names":["compile","hasOwnProperty","protocolHref","protocolSrc","options","settings","tags","definitions","buffers","mediaStack","tightStack","defaultHandlers","enter","blockQuote","onenterblockquote","codeFenced","onentercodefenced","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","onentercodeindented","codeText","onentercodetext","content","onentercontent","definition","onenterdefinition","definitionDestinationString","onenterdefinitiondestinationstring","definitionLabelString","definitionTitleString","emphasis","onenteremphasis","htmlFlow","onenterhtmlflow","htmlText","onenterhtml","image","onenterimage","label","link","onenterlink","listItemMarker","onenterlistitemmarker","listItemValue","onenterlistitemvalue","listOrdered","onenterlistordered","listUnordered","onenterlistunordered","paragraph","onenterparagraph","reference","resource","onenterresource","resourceDestinationString","onenterresourcedestinationstring","resourceTitleString","setextHeading","onentersetextheading","strong","onenterstrong","exit","atxHeading","onexitatxheading","atxHeadingSequence","onexitatxheadingsequence","autolinkEmail","onexitautolinkemail","autolinkProtocol","onexitautolinkprotocol","onexitblockquote","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitflowcode","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onresumedrop","codeFlowValue","onexitcodeflowvalue","onexitcodetext","codeTextData","data","onexitdefinition","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexitemphasis","hardBreakEscape","onexithardbreak","hardBreakTrailing","onexithtml","htmlFlowData","htmlTextData","onexitmedia","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlistordered","onexitlistunordered","onexitparagraph","referenceString","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","onexitstrong","thematicBreak","onexitthematicbreak","handlers","combineHtmlExtensions","concat","htmlExtensions","context","lineEndingIfNeeded","encode","raw","tag","resume","setData","getData","lineEndingStyle","defaultLineEnding","events","index","start","listStack","head","body","length","type","sliceSerialize","push","prepareList","slice","pop","result","null","call","handles","kind","handle","Object","assign","join","containerBalance","loose","atMarker","event","_container","undefined","_loose","key","value","buf","previous","charCodeAt","_encode","token","Number","parseInt","String","onexitlistitem","count","labelId","referenceId","destination","title","media","id","normalizeIdentifier","sanitizeUri","allowDangerousProtocol","allowDangerousHtml","decodeNumericCharacterReference","decodeNamedCharacterReference","uri"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}