d761cd8596bb86978716906b7d3e9bcb
/**
 * While micromark is a lexer/tokenizer, the common case of going from markdown
 * to html is currently built in as this module, even though the parts can be
 * used separately to build ASTs, CSTs, or many other output formats.
 *
 * Having an HTML compiler built in is useful because it allows us to check for
 * compliancy to CommonMark, the de facto norm of markdown, specified in roughly
 * 600 input/output cases.
 *
 * This module has an interface that accepts lists of events instead of the
 * whole at once, however, because markdown can’t be truly streaming, we buffer
 * events before processing and outputting the final result.
 */ /**
 * @typedef {import('micromark-util-types').Compile} Compile
 * @typedef {import('micromark-util-types').CompileContext} CompileContext
 * @typedef {import('micromark-util-types').CompileData} CompileData
 * @typedef {import('micromark-util-types').CompileOptions} CompileOptions
 * @typedef {import('micromark-util-types').Definition} Definition
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Handle} Handle
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 * @typedef {import('micromark-util-types').NormalizedHtmlExtension} NormalizedHtmlExtension
 * @typedef {import('micromark-util-types').Token} Token
 */ /**
 * @typedef Media
 * @property {boolean | undefined} [image]
 * @property {string | undefined} [labelId]
 * @property {string | undefined} [label]
 * @property {string | undefined} [referenceId]
 * @property {string | undefined} [destination]
 * @property {string | undefined} [title]
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "compile", {
    enumerable: true,
    get: function() {
        return compile;
    }
});
const _decodenamedcharacterreference = require("decode-named-character-reference");
const _micromarkutilchunked = require("micromark-util-chunked");
const _micromarkutilcombineextensions = require("micromark-util-combine-extensions");
const _micromarkutildecodenumericcharacterreference = require("micromark-util-decode-numeric-character-reference");
const _micromarkutilencode = require("micromark-util-encode");
const _micromarkutilnormalizeidentifier = require("micromark-util-normalize-identifier");
const _micromarkutilsanitizeuri = require("micromark-util-sanitize-uri");
const hasOwnProperty = {}.hasOwnProperty;
/**
 * These two are allowlists of safe protocols for full URLs in respectively the
 * `href` (on `<a>`) and `src` (on `<img>`) attributes.
 * They are based on what is allowed on GitHub,
 * <https://github.com/syntax-tree/hast-util-sanitize/blob/9275b21/lib/github.json#L31>
 */ const protocolHref = /^(https?|ircs?|mailto|xmpp)$/i;
const protocolSrc = /^https?$/i;
function compile(options) {
    const settings = options || {};
    /**
   * Tags is needed because according to markdown, links and emphasis and
   * whatnot can exist in images, however, as HTML doesn’t allow content in
   * images, the tags are ignored in the `alt` attribute, but the content
   * remains.
   *
   * @type {boolean | undefined}
   */ let tags = true;
    /**
   * An object to track identifiers to media (URLs and titles) defined with
   * definitions.
   *
   * @type {Record<string, Definition>}
   */ const definitions = {};
    /**
   * A lot of the handlers need to capture some of the output data, modify it
   * somehow, and then deal with it.
   * We do that by tracking a stack of buffers, that can be opened (with
   * `buffer`) and closed (with `resume`) to access them.
   *
   * @type {Array<Array<string>>}
   */ const buffers = [
        []
    ];
    /**
   * As we can have links in images and the other way around, where the deepest
   * ones are closed first, we need to track which one we’re in.
   *
   * @type {Array<Media>}
   */ const mediaStack = [];
    /**
   * Same as `mediaStack` for tightness, which is specific to lists.
   * We need to track if we’re currently in a tight or loose container.
   *
   * @type {Array<boolean>}
   */ const tightStack = [];
    /** @type {HtmlExtension} */ const defaultHandlers = {
        enter: {
            blockQuote: onenterblockquote,
            codeFenced: onentercodefenced,
            codeFencedFenceInfo: buffer,
            codeFencedFenceMeta: buffer,
            codeIndented: onentercodeindented,
            codeText: onentercodetext,
            content: onentercontent,
            definition: onenterdefinition,
            definitionDestinationString: onenterdefinitiondestinationstring,
            definitionLabelString: buffer,
            definitionTitleString: buffer,
            emphasis: onenteremphasis,
            htmlFlow: onenterhtmlflow,
            htmlText: onenterhtml,
            image: onenterimage,
            label: buffer,
            link: onenterlink,
            listItemMarker: onenterlistitemmarker,
            listItemValue: onenterlistitemvalue,
            listOrdered: onenterlistordered,
            listUnordered: onenterlistunordered,
            paragraph: onenterparagraph,
            reference: buffer,
            resource: onenterresource,
            resourceDestinationString: onenterresourcedestinationstring,
            resourceTitleString: buffer,
            setextHeading: onentersetextheading,
            strong: onenterstrong
        },
        exit: {
            atxHeading: onexitatxheading,
            atxHeadingSequence: onexitatxheadingsequence,
            autolinkEmail: onexitautolinkemail,
            autolinkProtocol: onexitautolinkprotocol,
            blockQuote: onexitblockquote,
            characterEscapeValue: onexitdata,
            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
            characterReferenceValue: onexitcharacterreferencevalue,
            codeFenced: onexitflowcode,
            codeFencedFence: onexitcodefencedfence,
            codeFencedFenceInfo: onexitcodefencedfenceinfo,
            codeFencedFenceMeta: onresumedrop,
            codeFlowValue: onexitcodeflowvalue,
            codeIndented: onexitflowcode,
            codeText: onexitcodetext,
            codeTextData: onexitdata,
            data: onexitdata,
            definition: onexitdefinition,
            definitionDestinationString: onexitdefinitiondestinationstring,
            definitionLabelString: onexitdefinitionlabelstring,
            definitionTitleString: onexitdefinitiontitlestring,
            emphasis: onexitemphasis,
            hardBreakEscape: onexithardbreak,
            hardBreakTrailing: onexithardbreak,
            htmlFlow: onexithtml,
            htmlFlowData: onexitdata,
            htmlText: onexithtml,
            htmlTextData: onexitdata,
            image: onexitmedia,
            label: onexitlabel,
            labelText: onexitlabeltext,
            lineEnding: onexitlineending,
            link: onexitmedia,
            listOrdered: onexitlistordered,
            listUnordered: onexitlistunordered,
            paragraph: onexitparagraph,
            reference: onresumedrop,
            referenceString: onexitreferencestring,
            resource: onresumedrop,
            resourceDestinationString: onexitresourcedestinationstring,
            resourceTitleString: onexitresourcetitlestring,
            setextHeading: onexitsetextheading,
            setextHeadingLineSequence: onexitsetextheadinglinesequence,
            setextHeadingText: onexitsetextheadingtext,
            strong: onexitstrong,
            thematicBreak: onexitthematicbreak
        }
    };
    /**
   * Combine the HTML extensions with the default handlers.
   * An HTML extension is an object whose fields are either `enter` or `exit`
   * (reflecting whether a token is entered or exited).
   * The values at such objects are names of tokens mapping to handlers.
   * Handlers are called, respectively when a token is opener or closed, with
   * that token, and a context as `this`.
   */ const handlers = /** @type {NormalizedHtmlExtension} */ (0, _micromarkutilcombineextensions.combineHtmlExtensions)([
        defaultHandlers
    ].concat(settings.htmlExtensions || []));
    /**
   * Handlers do often need to keep track of some state.
   * That state is provided here as a key-value store (an object).
   *
   * @type {CompileData}
   */ const data = {
        tightStack,
        definitions
    };
    /**
   * The context for handlers references a couple of useful functions.
   * In handlers from extensions, those can be accessed at `this`.
   * For the handlers here, they can be accessed directly.
   *
   * @type {Omit<CompileContext, 'sliceSerialize'>}
   */ const context = {
        lineEndingIfNeeded,
        options: settings,
        encode,
        raw,
        tag,
        buffer,
        resume,
        setData,
        getData
    };
    /**
   * Generally, micromark copies line endings (`'\r'`, `'\n'`, `'\r\n'`) in the
   * markdown document over to the compiled HTML.
   * In some cases, such as `> a`, CommonMark requires that extra line endings
   * are added: `<blockquote>\n<p>a</p>\n</blockquote>`.
   * This variable hold the default line ending when given (or `undefined`),
   * and in the latter case will be updated to the first found line ending if
   * there is one.
   */ let lineEndingStyle = settings.defaultLineEnding;
    // Return the function that handles a slice of events.
    return compile;
    /**
   * Deal w/ a slice of events.
   * Return either the empty string if there’s nothing of note to return, or the
   * result when done.
   *
   * @param {Array<Event>} events
   * @returns {string}
   */ function compile(events) {
        let index = -1;
        let start = 0;
        /** @type {Array<number>} */ const listStack = [];
        // As definitions can come after references, we need to figure out the media
        // (urls and titles) defined by them before handling the references.
        // So, we do sort of what HTML does: put metadata at the start (in head), and
        // then put content after (`body`).
        /** @type {Array<Event>} */ let head = [];
        /** @type {Array<Event>} */ let body = [];
        while(++index < events.length){
            // Figure out the line ending style used in the document.
            if (!lineEndingStyle && (events[index][1].type === 'lineEnding' || events[index][1].type === 'lineEndingBlank')) {
                // @ts-expect-error Hush, it’s a line ending.
                lineEndingStyle = events[index][2].sliceSerialize(events[index][1]);
            }
            // Preprocess lists to infer whether the list is loose or not.
            if (events[index][1].type === 'listOrdered' || events[index][1].type === 'listUnordered') {
                if (events[index][0] === 'enter') {
                    listStack.push(index);
                } else {
                    prepareList(events.slice(listStack.pop(), index));
                }
            }
            // Move definitions to the front.
            if (events[index][1].type === 'definition') {
                if (events[index][0] === 'enter') {
                    body = (0, _micromarkutilchunked.push)(body, events.slice(start, index));
                    start = index;
                } else {
                    head = (0, _micromarkutilchunked.push)(head, events.slice(start, index + 1));
                    start = index + 1;
                }
            }
        }
        head = (0, _micromarkutilchunked.push)(head, body);
        head = (0, _micromarkutilchunked.push)(head, events.slice(start));
        index = -1;
        const result = head;
        // Handle the start of the document, if defined.
        if (handlers.enter.null) {
            handlers.enter.null.call(context);
        }
        // Handle all events.
        while(++index < events.length){
            const handles = handlers[result[index][0]];
            const kind = result[index][1].type;
            const handle = handles[kind];
            if (hasOwnProperty.call(handles, kind) && handle) {
                handle.call(Object.assign({
                    sliceSerialize: result[index][2].sliceSerialize
                }, context), result[index][1]);
            }
        }
        // Handle the end of the document, if defined.
        if (handlers.exit.null) {
            handlers.exit.null.call(context);
        }
        return buffers[0].join('');
    }
    /**
   * Figure out whether lists are loose or not.
   *
   * @param {Array<Event>} slice
   * @returns {undefined}
   */ function prepareList(slice) {
        const length = slice.length;
        let index = 0 // Skip open.
        ;
        let containerBalance = 0;
        let loose = false;
        /** @type {boolean | undefined} */ let atMarker;
        while(++index < length){
            const event = slice[index];
            if (event[1]._container) {
                atMarker = undefined;
                if (event[0] === 'enter') {
                    containerBalance++;
                } else {
                    containerBalance--;
                }
            } else switch(event[1].type){
                case 'listItemPrefix':
                    {
                        if (event[0] === 'exit') {
                            atMarker = true;
                        }
                        break;
                    }
                case 'linePrefix':
                    {
                        break;
                    }
                case 'lineEndingBlank':
                    {
                        if (event[0] === 'enter' && !containerBalance) {
                            if (atMarker) {
                                atMarker = undefined;
                            } else {
                                loose = true;
                            }
                        }
                        break;
                    }
                default:
                    {
                        atMarker = undefined;
                    }
            }
        }
        slice[0][1]._loose = loose;
    }
    /**
   * @type {CompileContext['setData']}
   */ function setData(key, value) {
        // @ts-expect-error: assume `value` is omitted (`undefined` is passed) only
        // if allowed.
        data[key] = value;
    }
    /**
   * @type {CompileContext['getData']}
   */ function getData(key) {
        return data[key];
    }
    /** @type {CompileContext['buffer']} */ function buffer() {
        buffers.push([]);
    }
    /** @type {CompileContext['resume']} */ function resume() {
        const buf = buffers.pop();
        return buf.join('');
    }
    /** @type {CompileContext['tag']} */ function tag(value) {
        if (!tags) return;
        setData('lastWasTag', true);
        buffers[buffers.length - 1].push(value);
    }
    /** @type {CompileContext['raw']} */ function raw(value) {
        setData('lastWasTag');
        buffers[buffers.length - 1].push(value);
    }
    /**
   * Output an extra line ending.
   *
   * @returns {undefined}
   */ function lineEnding() {
        raw(lineEndingStyle || '\n');
    }
    /** @type {CompileContext['lineEndingIfNeeded']} */ function lineEndingIfNeeded() {
        const buffer = buffers[buffers.length - 1];
        const slice = buffer[buffer.length - 1];
        const previous = slice ? slice.charCodeAt(slice.length - 1) : null;
        if (previous === 10 || previous === 13 || previous === null) {
            return;
        }
        lineEnding();
    }
    /** @type {CompileContext['encode']} */ function encode(value) {
        return getData('ignoreEncode') ? value : (0, _micromarkutilencode.encode)(value);
    }
    //
    // Handlers.
    //
    /**
   * @returns {undefined}
   */ function onresumedrop() {
        resume();
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterlistordered(token) {
        tightStack.push(!token._loose);
        lineEndingIfNeeded();
        tag('<ol');
        setData('expectFirstItem', true);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterlistunordered(token) {
        tightStack.push(!token._loose);
        lineEndingIfNeeded();
        tag('<ul');
        setData('expectFirstItem', true);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterlistitemvalue(token) {
        if (getData('expectFirstItem')) {
            const value = Number.parseInt(this.sliceSerialize(token), 10);
            if (value !== 1) {
                tag(' start="' + encode(String(value)) + '"');
            }
        }
    }
    /**
   * @returns {undefined}
   */ function onenterlistitemmarker() {
        if (getData('expectFirstItem')) {
            tag('>');
        } else {
            onexitlistitem();
        }
        lineEndingIfNeeded();
        tag('<li>');
        setData('expectFirstItem');
        // “Hack” to prevent a line ending from showing up if the item is empty.
        setData('lastWasTag');
    }
    /**
   * @returns {undefined}
   */ function onexitlistordered() {
        onexitlistitem();
        tightStack.pop();
        lineEnding();
        tag('</ol>');
    }
    /**
   * @returns {undefined}
   */ function onexitlistunordered() {
        onexitlistitem();
        tightStack.pop();
        lineEnding();
        tag('</ul>');
    }
    /**
   * @returns {undefined}
   */ function onexitlistitem() {
        if (getData('lastWasTag') && !getData('slurpAllLineEndings')) {
            lineEndingIfNeeded();
        }
        tag('</li>');
        setData('slurpAllLineEndings');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterblockquote() {
        tightStack.push(false);
        lineEndingIfNeeded();
        tag('<blockquote>');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitblockquote() {
        tightStack.pop();
        lineEndingIfNeeded();
        tag('</blockquote>');
        setData('slurpAllLineEndings');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterparagraph() {
        if (!tightStack[tightStack.length - 1]) {
            lineEndingIfNeeded();
            tag('<p>');
        }
        setData('slurpAllLineEndings');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitparagraph() {
        if (tightStack[tightStack.length - 1]) {
            setData('slurpAllLineEndings', true);
        } else {
            tag('</p>');
        }
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onentercodefenced() {
        lineEndingIfNeeded();
        tag('<pre><code');
        setData('fencesCount', 0);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitcodefencedfenceinfo() {
        const value = resume();
        tag(' class="language-' + value + '"');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitcodefencedfence() {
        const count = getData('fencesCount') || 0;
        if (!count) {
            tag('>');
            setData('slurpOneLineEnding', true);
        }
        setData('fencesCount', count + 1);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onentercodeindented() {
        lineEndingIfNeeded();
        tag('<pre><code>');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitflowcode() {
        const count = getData('fencesCount');
        // One special case is if we are inside a container, and the fenced code was
        // not closed (meaning it runs to the end).
        // In that case, the following line ending, is considered *outside* the
        // fenced code and block quote by micromark, but CM wants to treat that
        // ending as part of the code.
        if (count !== undefined && count < 2 && data.tightStack.length > 0 && !getData('lastWasTag')) {
            lineEnding();
        }
        // But in most cases, it’s simpler: when we’ve seen some data, emit an extra
        // line ending when needed.
        if (getData('flowCodeSeenData')) {
            lineEndingIfNeeded();
        }
        tag('</code></pre>');
        if (count !== undefined && count < 2) lineEndingIfNeeded();
        setData('flowCodeSeenData');
        setData('fencesCount');
        setData('slurpOneLineEnding');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterimage() {
        mediaStack.push({
            image: true
        });
        tags = undefined // Disallow tags.
        ;
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterlink() {
        mediaStack.push({});
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitlabeltext(token) {
        mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitlabel() {
        mediaStack[mediaStack.length - 1].label = resume();
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitreferencestring(token) {
        mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterresource() {
        buffer() // We can have line endings in the resource, ignore them.
        ;
        mediaStack[mediaStack.length - 1].destination = '';
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterresourcedestinationstring() {
        buffer();
        // Ignore encoding the result, as we’ll first percent encode the url and
        // encode manually after.
        setData('ignoreEncode', true);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitresourcedestinationstring() {
        mediaStack[mediaStack.length - 1].destination = resume();
        setData('ignoreEncode');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitresourcetitlestring() {
        mediaStack[mediaStack.length - 1].title = resume();
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitmedia() {
        let index = mediaStack.length - 1 // Skip current.
        ;
        const media = mediaStack[index];
        const id = media.referenceId || media.labelId;
        const context = media.destination === undefined ? definitions[(0, _micromarkutilnormalizeidentifier.normalizeIdentifier)(id)] : media;
        tags = true;
        while(index--){
            if (mediaStack[index].image) {
                tags = undefined;
                break;
            }
        }
        if (media.image) {
            tag('<img src="' + (0, _micromarkutilsanitizeuri.sanitizeUri)(context.destination, settings.allowDangerousProtocol ? undefined : protocolSrc) + '" alt="');
            raw(media.label);
            tag('"');
        } else {
            tag('<a href="' + (0, _micromarkutilsanitizeuri.sanitizeUri)(context.destination, settings.allowDangerousProtocol ? undefined : protocolHref) + '"');
        }
        tag(context.title ? ' title="' + context.title + '"' : '');
        if (media.image) {
            tag(' />');
        } else {
            tag('>');
            raw(media.label);
            tag('</a>');
        }
        mediaStack.pop();
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterdefinition() {
        buffer();
        mediaStack.push({});
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitdefinitionlabelstring(token) {
        // Discard label, use the source content instead.
        resume();
        mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onenterdefinitiondestinationstring() {
        buffer();
        setData('ignoreEncode', true);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitdefinitiondestinationstring() {
        mediaStack[mediaStack.length - 1].destination = resume();
        setData('ignoreEncode');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitdefinitiontitlestring() {
        mediaStack[mediaStack.length - 1].title = resume();
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitdefinition() {
        const media = mediaStack[mediaStack.length - 1];
        const id = (0, _micromarkutilnormalizeidentifier.normalizeIdentifier)(media.labelId);
        resume();
        if (!hasOwnProperty.call(definitions, id)) {
            definitions[id] = mediaStack[mediaStack.length - 1];
        }
        mediaStack.pop();
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onentercontent() {
        setData('slurpAllLineEndings', true);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitatxheadingsequence(token) {
        // Exit for further sequences.
        if (getData('headingRank')) return;
        setData('headingRank', this.sliceSerialize(token).length);
        lineEndingIfNeeded();
        tag('<h' + getData('headingRank') + '>');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onentersetextheading() {
        buffer();
        setData('slurpAllLineEndings');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitsetextheadingtext() {
        setData('slurpAllLineEndings', true);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitatxheading() {
        tag('</h' + getData('headingRank') + '>');
        setData('headingRank');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitsetextheadinglinesequence(token) {
        setData('headingRank', this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitsetextheading() {
        const value = resume();
        lineEndingIfNeeded();
        tag('<h' + getData('headingRank') + '>');
        raw(value);
        tag('</h' + getData('headingRank') + '>');
        setData('slurpAllLineEndings');
        setData('headingRank');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitdata(token) {
        raw(encode(this.sliceSerialize(token)));
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitlineending(token) {
        if (getData('slurpAllLineEndings')) {
            return;
        }
        if (getData('slurpOneLineEnding')) {
            setData('slurpOneLineEnding');
            return;
        }
        if (getData('inCodeText')) {
            raw(' ');
            return;
        }
        raw(encode(this.sliceSerialize(token)));
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitcodeflowvalue(token) {
        raw(encode(this.sliceSerialize(token)));
        setData('flowCodeSeenData', true);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexithardbreak() {
        tag('<br />');
    }
    /**
   * @returns {undefined}
   */ function onenterhtmlflow() {
        lineEndingIfNeeded();
        onenterhtml();
    }
    /**
   * @returns {undefined}
   */ function onexithtml() {
        setData('ignoreEncode');
    }
    /**
   * @returns {undefined}
   */ function onenterhtml() {
        if (settings.allowDangerousHtml) {
            setData('ignoreEncode', true);
        }
    }
    /**
   * @returns {undefined}
   */ function onenteremphasis() {
        tag('<em>');
    }
    /**
   * @returns {undefined}
   */ function onenterstrong() {
        tag('<strong>');
    }
    /**
   * @returns {undefined}
   */ function onentercodetext() {
        setData('inCodeText', true);
        tag('<code>');
    }
    /**
   * @returns {undefined}
   */ function onexitcodetext() {
        setData('inCodeText');
        tag('</code>');
    }
    /**
   * @returns {undefined}
   */ function onexitemphasis() {
        tag('</em>');
    }
    /**
   * @returns {undefined}
   */ function onexitstrong() {
        tag('</strong>');
    }
    /**
   * @returns {undefined}
   */ function onexitthematicbreak() {
        lineEndingIfNeeded();
        tag('<hr />');
    }
    /**
   * @this {CompileContext}
   * @param {Token} token
   * @returns {undefined}
   */ function onexitcharacterreferencemarker(token) {
        setData('characterReferenceType', token.type);
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitcharacterreferencevalue(token) {
        let value = this.sliceSerialize(token);
        // @ts-expect-error `decodeNamedCharacterReference` can return false for
        // invalid named character references, but everything we’ve tokenized is
        // valid.
        value = getData('characterReferenceType') ? (0, _micromarkutildecodenumericcharacterreference.decodeNumericCharacterReference)(value, getData('characterReferenceType') === 'characterReferenceMarkerNumeric' ? 10 : 16) : (0, _decodenamedcharacterreference.decodeNamedCharacterReference)(value);
        raw(encode(value));
        setData('characterReferenceType');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitautolinkprotocol(token) {
        const uri = this.sliceSerialize(token);
        tag('<a href="' + (0, _micromarkutilsanitizeuri.sanitizeUri)(uri, settings.allowDangerousProtocol ? undefined : protocolHref) + '">');
        raw(encode(uri));
        tag('</a>');
    }
    /**
   * @this {CompileContext}
   * @type {Handle}
   */ function onexitautolinkemail(token) {
        const uri = this.sliceSerialize(token);
        tag('<a href="' + (0, _micromarkutilsanitizeuri.sanitizeUri)('mailto:' + uri) + '">');
        raw(encode(uri));
        tag('</a>');
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL2NvbXBpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBXaGlsZSBtaWNyb21hcmsgaXMgYSBsZXhlci90b2tlbml6ZXIsIHRoZSBjb21tb24gY2FzZSBvZiBnb2luZyBmcm9tIG1hcmtkb3duXG4gKiB0byBodG1sIGlzIGN1cnJlbnRseSBidWlsdCBpbiBhcyB0aGlzIG1vZHVsZSwgZXZlbiB0aG91Z2ggdGhlIHBhcnRzIGNhbiBiZVxuICogdXNlZCBzZXBhcmF0ZWx5IHRvIGJ1aWxkIEFTVHMsIENTVHMsIG9yIG1hbnkgb3RoZXIgb3V0cHV0IGZvcm1hdHMuXG4gKlxuICogSGF2aW5nIGFuIEhUTUwgY29tcGlsZXIgYnVpbHQgaW4gaXMgdXNlZnVsIGJlY2F1c2UgaXQgYWxsb3dzIHVzIHRvIGNoZWNrIGZvclxuICogY29tcGxpYW5jeSB0byBDb21tb25NYXJrLCB0aGUgZGUgZmFjdG8gbm9ybSBvZiBtYXJrZG93biwgc3BlY2lmaWVkIGluIHJvdWdobHlcbiAqIDYwMCBpbnB1dC9vdXRwdXQgY2FzZXMuXG4gKlxuICogVGhpcyBtb2R1bGUgaGFzIGFuIGludGVyZmFjZSB0aGF0IGFjY2VwdHMgbGlzdHMgb2YgZXZlbnRzIGluc3RlYWQgb2YgdGhlXG4gKiB3aG9sZSBhdCBvbmNlLCBob3dldmVyLCBiZWNhdXNlIG1hcmtkb3duIGNhbuKAmXQgYmUgdHJ1bHkgc3RyZWFtaW5nLCB3ZSBidWZmZXJcbiAqIGV2ZW50cyBiZWZvcmUgcHJvY2Vzc2luZyBhbmQgb3V0cHV0dGluZyB0aGUgZmluYWwgcmVzdWx0LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db21waWxlfSBDb21waWxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbXBpbGVDb250ZXh0fSBDb21waWxlQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db21waWxlRGF0YX0gQ29tcGlsZURhdGFcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29tcGlsZU9wdGlvbnN9IENvbXBpbGVPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkRlZmluaXRpb259IERlZmluaXRpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkhhbmRsZX0gSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkh0bWxFeHRlbnNpb259IEh0bWxFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuTm9ybWFsaXplZEh0bWxFeHRlbnNpb259IE5vcm1hbGl6ZWRIdG1sRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgTWVkaWFcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2ltYWdlXVxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtsYWJlbElkXVxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtsYWJlbF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbcmVmZXJlbmNlSWRdXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gW2Rlc3RpbmF0aW9uXVxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFt0aXRsZV1cbiAqL1xuXG5pbXBvcnQge2RlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdkZWNvZGUtbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZSdcbmltcG9ydCB7cHVzaH0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2h1bmtlZCdcbmltcG9ydCB7Y29tYmluZUh0bWxFeHRlbnNpb25zfSBmcm9tICdtaWNyb21hcmstdXRpbC1jb21iaW5lLWV4dGVuc2lvbnMnXG5pbXBvcnQge2RlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWRlY29kZS1udW1lcmljLWNoYXJhY3Rlci1yZWZlcmVuY2UnXG5pbXBvcnQge2VuY29kZSBhcyBfZW5jb2RlfSBmcm9tICdtaWNyb21hcmstdXRpbC1lbmNvZGUnXG5pbXBvcnQge25vcm1hbGl6ZUlkZW50aWZpZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLW5vcm1hbGl6ZS1pZGVudGlmaWVyJ1xuaW1wb3J0IHtzYW5pdGl6ZVVyaX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtc2FuaXRpemUtdXJpJ1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vKipcbiAqIFRoZXNlIHR3byBhcmUgYWxsb3dsaXN0cyBvZiBzYWZlIHByb3RvY29scyBmb3IgZnVsbCBVUkxzIGluIHJlc3BlY3RpdmVseSB0aGVcbiAqIGBocmVmYCAob24gYDxhPmApIGFuZCBgc3JjYCAob24gYDxpbWc+YCkgYXR0cmlidXRlcy5cbiAqIFRoZXkgYXJlIGJhc2VkIG9uIHdoYXQgaXMgYWxsb3dlZCBvbiBHaXRIdWIsXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL3N5bnRheC10cmVlL2hhc3QtdXRpbC1zYW5pdGl6ZS9ibG9iLzkyNzViMjEvbGliL2dpdGh1Yi5qc29uI0wzMT5cbiAqL1xuY29uc3QgcHJvdG9jb2xIcmVmID0gL14oaHR0cHM/fGlyY3M/fG1haWx0b3x4bXBwKSQvaVxuY29uc3QgcHJvdG9jb2xTcmMgPSAvXmh0dHBzPyQvaVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGlsZU9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtDb21waWxlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZShvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gb3B0aW9ucyB8fCB7fVxuXG4gIC8qKlxuICAgKiBUYWdzIGlzIG5lZWRlZCBiZWNhdXNlIGFjY29yZGluZyB0byBtYXJrZG93biwgbGlua3MgYW5kIGVtcGhhc2lzIGFuZFxuICAgKiB3aGF0bm90IGNhbiBleGlzdCBpbiBpbWFnZXMsIGhvd2V2ZXIsIGFzIEhUTUwgZG9lc27igJl0IGFsbG93IGNvbnRlbnQgaW5cbiAgICogaW1hZ2VzLCB0aGUgdGFncyBhcmUgaWdub3JlZCBpbiB0aGUgYGFsdGAgYXR0cmlidXRlLCBidXQgdGhlIGNvbnRlbnRcbiAgICogcmVtYWlucy5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9XG4gICAqL1xuICBsZXQgdGFncyA9IHRydWVcblxuICAvKipcbiAgICogQW4gb2JqZWN0IHRvIHRyYWNrIGlkZW50aWZpZXJzIHRvIG1lZGlhIChVUkxzIGFuZCB0aXRsZXMpIGRlZmluZWQgd2l0aFxuICAgKiBkZWZpbml0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge1JlY29yZDxzdHJpbmcsIERlZmluaXRpb24+fVxuICAgKi9cbiAgY29uc3QgZGVmaW5pdGlvbnMgPSB7fVxuXG4gIC8qKlxuICAgKiBBIGxvdCBvZiB0aGUgaGFuZGxlcnMgbmVlZCB0byBjYXB0dXJlIHNvbWUgb2YgdGhlIG91dHB1dCBkYXRhLCBtb2RpZnkgaXRcbiAgICogc29tZWhvdywgYW5kIHRoZW4gZGVhbCB3aXRoIGl0LlxuICAgKiBXZSBkbyB0aGF0IGJ5IHRyYWNraW5nIGEgc3RhY2sgb2YgYnVmZmVycywgdGhhdCBjYW4gYmUgb3BlbmVkICh3aXRoXG4gICAqIGBidWZmZXJgKSBhbmQgY2xvc2VkICh3aXRoIGByZXN1bWVgKSB0byBhY2Nlc3MgdGhlbS5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PEFycmF5PHN0cmluZz4+fVxuICAgKi9cbiAgY29uc3QgYnVmZmVycyA9IFtbXV1cblxuICAvKipcbiAgICogQXMgd2UgY2FuIGhhdmUgbGlua3MgaW4gaW1hZ2VzIGFuZCB0aGUgb3RoZXIgd2F5IGFyb3VuZCwgd2hlcmUgdGhlIGRlZXBlc3RcbiAgICogb25lcyBhcmUgY2xvc2VkIGZpcnN0LCB3ZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9uZSB3ZeKAmXJlIGluLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8TWVkaWE+fVxuICAgKi9cbiAgY29uc3QgbWVkaWFTdGFjayA9IFtdXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYG1lZGlhU3RhY2tgIGZvciB0aWdodG5lc3MsIHdoaWNoIGlzIHNwZWNpZmljIHRvIGxpc3RzLlxuICAgKiBXZSBuZWVkIHRvIHRyYWNrIGlmIHdl4oCZcmUgY3VycmVudGx5IGluIGEgdGlnaHQgb3IgbG9vc2UgY29udGFpbmVyLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8Ym9vbGVhbj59XG4gICAqL1xuICBjb25zdCB0aWdodFN0YWNrID0gW11cblxuICAvKiogQHR5cGUge0h0bWxFeHRlbnNpb259ICovXG4gIGNvbnN0IGRlZmF1bHRIYW5kbGVycyA9IHtcbiAgICBlbnRlcjoge1xuICAgICAgYmxvY2tRdW90ZTogb25lbnRlcmJsb2NrcXVvdGUsXG4gICAgICBjb2RlRmVuY2VkOiBvbmVudGVyY29kZWZlbmNlZCxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZUluZm86IGJ1ZmZlcixcbiAgICAgIGNvZGVGZW5jZWRGZW5jZU1ldGE6IGJ1ZmZlcixcbiAgICAgIGNvZGVJbmRlbnRlZDogb25lbnRlcmNvZGVpbmRlbnRlZCxcbiAgICAgIGNvZGVUZXh0OiBvbmVudGVyY29kZXRleHQsXG4gICAgICBjb250ZW50OiBvbmVudGVyY29udGVudCxcbiAgICAgIGRlZmluaXRpb246IG9uZW50ZXJkZWZpbml0aW9uLFxuICAgICAgZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nOiBvbmVudGVyZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBidWZmZXIsXG4gICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIGVtcGhhc2lzOiBvbmVudGVyZW1waGFzaXMsXG4gICAgICBodG1sRmxvdzogb25lbnRlcmh0bWxmbG93LFxuICAgICAgaHRtbFRleHQ6IG9uZW50ZXJodG1sLFxuICAgICAgaW1hZ2U6IG9uZW50ZXJpbWFnZSxcbiAgICAgIGxhYmVsOiBidWZmZXIsXG4gICAgICBsaW5rOiBvbmVudGVybGluayxcbiAgICAgIGxpc3RJdGVtTWFya2VyOiBvbmVudGVybGlzdGl0ZW1tYXJrZXIsXG4gICAgICBsaXN0SXRlbVZhbHVlOiBvbmVudGVybGlzdGl0ZW12YWx1ZSxcbiAgICAgIGxpc3RPcmRlcmVkOiBvbmVudGVybGlzdG9yZGVyZWQsXG4gICAgICBsaXN0VW5vcmRlcmVkOiBvbmVudGVybGlzdHVub3JkZXJlZCxcbiAgICAgIHBhcmFncmFwaDogb25lbnRlcnBhcmFncmFwaCxcbiAgICAgIHJlZmVyZW5jZTogYnVmZmVyLFxuICAgICAgcmVzb3VyY2U6IG9uZW50ZXJyZXNvdXJjZSxcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25TdHJpbmc6IG9uZW50ZXJyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgcmVzb3VyY2VUaXRsZVN0cmluZzogYnVmZmVyLFxuICAgICAgc2V0ZXh0SGVhZGluZzogb25lbnRlcnNldGV4dGhlYWRpbmcsXG4gICAgICBzdHJvbmc6IG9uZW50ZXJzdHJvbmdcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIGF0eEhlYWRpbmc6IG9uZXhpdGF0eGhlYWRpbmcsXG4gICAgICBhdHhIZWFkaW5nU2VxdWVuY2U6IG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSxcbiAgICAgIGF1dG9saW5rRW1haWw6IG9uZXhpdGF1dG9saW5rZW1haWwsXG4gICAgICBhdXRvbGlua1Byb3RvY29sOiBvbmV4aXRhdXRvbGlua3Byb3RvY29sLFxuICAgICAgYmxvY2tRdW90ZTogb25leGl0YmxvY2txdW90ZSxcbiAgICAgIGNoYXJhY3RlckVzY2FwZVZhbHVlOiBvbmV4aXRkYXRhLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWw6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWM6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZVZhbHVlOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSxcbiAgICAgIGNvZGVGZW5jZWQ6IG9uZXhpdGZsb3djb2RlLFxuICAgICAgY29kZUZlbmNlZEZlbmNlOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2UsXG4gICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvLFxuICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogb25yZXN1bWVkcm9wLFxuICAgICAgY29kZUZsb3dWYWx1ZTogb25leGl0Y29kZWZsb3d2YWx1ZSxcbiAgICAgIGNvZGVJbmRlbnRlZDogb25leGl0Zmxvd2NvZGUsXG4gICAgICBjb2RlVGV4dDogb25leGl0Y29kZXRleHQsXG4gICAgICBjb2RlVGV4dERhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBkYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgZGVmaW5pdGlvbjogb25leGl0ZGVmaW5pdGlvbixcbiAgICAgIGRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZzogb25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmcsXG4gICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZyxcbiAgICAgIGVtcGhhc2lzOiBvbmV4aXRlbXBoYXNpcyxcbiAgICAgIGhhcmRCcmVha0VzY2FwZTogb25leGl0aGFyZGJyZWFrLFxuICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IG9uZXhpdGhhcmRicmVhayxcbiAgICAgIGh0bWxGbG93OiBvbmV4aXRodG1sLFxuICAgICAgaHRtbEZsb3dEYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgaHRtbFRleHQ6IG9uZXhpdGh0bWwsXG4gICAgICBodG1sVGV4dERhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBpbWFnZTogb25leGl0bWVkaWEsXG4gICAgICBsYWJlbDogb25leGl0bGFiZWwsXG4gICAgICBsYWJlbFRleHQ6IG9uZXhpdGxhYmVsdGV4dCxcbiAgICAgIGxpbmVFbmRpbmc6IG9uZXhpdGxpbmVlbmRpbmcsXG4gICAgICBsaW5rOiBvbmV4aXRtZWRpYSxcbiAgICAgIGxpc3RPcmRlcmVkOiBvbmV4aXRsaXN0b3JkZXJlZCxcbiAgICAgIGxpc3RVbm9yZGVyZWQ6IG9uZXhpdGxpc3R1bm9yZGVyZWQsXG4gICAgICBwYXJhZ3JhcGg6IG9uZXhpdHBhcmFncmFwaCxcbiAgICAgIHJlZmVyZW5jZTogb25yZXN1bWVkcm9wLFxuICAgICAgcmVmZXJlbmNlU3RyaW5nOiBvbmV4aXRyZWZlcmVuY2VzdHJpbmcsXG4gICAgICByZXNvdXJjZTogb25yZXN1bWVkcm9wLFxuICAgICAgcmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZzogb25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZyxcbiAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IG9uZXhpdHJlc291cmNldGl0bGVzdHJpbmcsXG4gICAgICBzZXRleHRIZWFkaW5nOiBvbmV4aXRzZXRleHRoZWFkaW5nLFxuICAgICAgc2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZTogb25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSxcbiAgICAgIHNldGV4dEhlYWRpbmdUZXh0OiBvbmV4aXRzZXRleHRoZWFkaW5ndGV4dCxcbiAgICAgIHN0cm9uZzogb25leGl0c3Ryb25nLFxuICAgICAgdGhlbWF0aWNCcmVhazogb25leGl0dGhlbWF0aWNicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lIHRoZSBIVE1MIGV4dGVuc2lvbnMgd2l0aCB0aGUgZGVmYXVsdCBoYW5kbGVycy5cbiAgICogQW4gSFRNTCBleHRlbnNpb24gaXMgYW4gb2JqZWN0IHdob3NlIGZpZWxkcyBhcmUgZWl0aGVyIGBlbnRlcmAgb3IgYGV4aXRgXG4gICAqIChyZWZsZWN0aW5nIHdoZXRoZXIgYSB0b2tlbiBpcyBlbnRlcmVkIG9yIGV4aXRlZCkuXG4gICAqIFRoZSB2YWx1ZXMgYXQgc3VjaCBvYmplY3RzIGFyZSBuYW1lcyBvZiB0b2tlbnMgbWFwcGluZyB0byBoYW5kbGVycy5cbiAgICogSGFuZGxlcnMgYXJlIGNhbGxlZCwgcmVzcGVjdGl2ZWx5IHdoZW4gYSB0b2tlbiBpcyBvcGVuZXIgb3IgY2xvc2VkLCB3aXRoXG4gICAqIHRoYXQgdG9rZW4sIGFuZCBhIGNvbnRleHQgYXMgYHRoaXNgLlxuICAgKi9cbiAgY29uc3QgaGFuZGxlcnMgPVxuICAgIC8qKiBAdHlwZSB7Tm9ybWFsaXplZEh0bWxFeHRlbnNpb259ICovXG4gICAgY29tYmluZUh0bWxFeHRlbnNpb25zKFxuICAgICAgW2RlZmF1bHRIYW5kbGVyc10uY29uY2F0KHNldHRpbmdzLmh0bWxFeHRlbnNpb25zIHx8IFtdKVxuICAgIClcblxuICAvKipcbiAgICogSGFuZGxlcnMgZG8gb2Z0ZW4gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHNvbWUgc3RhdGUuXG4gICAqIFRoYXQgc3RhdGUgaXMgcHJvdmlkZWQgaGVyZSBhcyBhIGtleS12YWx1ZSBzdG9yZSAoYW4gb2JqZWN0KS5cbiAgICpcbiAgICogQHR5cGUge0NvbXBpbGVEYXRhfVxuICAgKi9cbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0aWdodFN0YWNrLFxuICAgIGRlZmluaXRpb25zXG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbnRleHQgZm9yIGhhbmRsZXJzIHJlZmVyZW5jZXMgYSBjb3VwbGUgb2YgdXNlZnVsIGZ1bmN0aW9ucy5cbiAgICogSW4gaGFuZGxlcnMgZnJvbSBleHRlbnNpb25zLCB0aG9zZSBjYW4gYmUgYWNjZXNzZWQgYXQgYHRoaXNgLlxuICAgKiBGb3IgdGhlIGhhbmRsZXJzIGhlcmUsIHRoZXkgY2FuIGJlIGFjY2Vzc2VkIGRpcmVjdGx5LlxuICAgKlxuICAgKiBAdHlwZSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59XG4gICAqL1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGxpbmVFbmRpbmdJZk5lZWRlZCxcbiAgICBvcHRpb25zOiBzZXR0aW5ncyxcbiAgICBlbmNvZGUsXG4gICAgcmF3LFxuICAgIHRhZyxcbiAgICBidWZmZXIsXG4gICAgcmVzdW1lLFxuICAgIHNldERhdGEsXG4gICAgZ2V0RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYWxseSwgbWljcm9tYXJrIGNvcGllcyBsaW5lIGVuZGluZ3MgKGAnXFxyJ2AsIGAnXFxuJ2AsIGAnXFxyXFxuJ2ApIGluIHRoZVxuICAgKiBtYXJrZG93biBkb2N1bWVudCBvdmVyIHRvIHRoZSBjb21waWxlZCBIVE1MLlxuICAgKiBJbiBzb21lIGNhc2VzLCBzdWNoIGFzIGA+IGFgLCBDb21tb25NYXJrIHJlcXVpcmVzIHRoYXQgZXh0cmEgbGluZSBlbmRpbmdzXG4gICAqIGFyZSBhZGRlZDogYDxibG9ja3F1b3RlPlxcbjxwPmE8L3A+XFxuPC9ibG9ja3F1b3RlPmAuXG4gICAqIFRoaXMgdmFyaWFibGUgaG9sZCB0aGUgZGVmYXVsdCBsaW5lIGVuZGluZyB3aGVuIGdpdmVuIChvciBgdW5kZWZpbmVkYCksXG4gICAqIGFuZCBpbiB0aGUgbGF0dGVyIGNhc2Ugd2lsbCBiZSB1cGRhdGVkIHRvIHRoZSBmaXJzdCBmb3VuZCBsaW5lIGVuZGluZyBpZlxuICAgKiB0aGVyZSBpcyBvbmUuXG4gICAqL1xuICBsZXQgbGluZUVuZGluZ1N0eWxlID0gc2V0dGluZ3MuZGVmYXVsdExpbmVFbmRpbmdcblxuICAvLyBSZXR1cm4gdGhlIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyBhIHNsaWNlIG9mIGV2ZW50cy5cbiAgcmV0dXJuIGNvbXBpbGVcblxuICAvKipcbiAgICogRGVhbCB3LyBhIHNsaWNlIG9mIGV2ZW50cy5cbiAgICogUmV0dXJuIGVpdGhlciB0aGUgZW1wdHkgc3RyaW5nIGlmIHRoZXJl4oCZcyBub3RoaW5nIG9mIG5vdGUgdG8gcmV0dXJuLCBvciB0aGVcbiAgICogcmVzdWx0IHdoZW4gZG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGlsZShldmVudHMpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIGxldCBzdGFydCA9IDBcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgbGlzdFN0YWNrID0gW11cbiAgICAvLyBBcyBkZWZpbml0aW9ucyBjYW4gY29tZSBhZnRlciByZWZlcmVuY2VzLCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgdGhlIG1lZGlhXG4gICAgLy8gKHVybHMgYW5kIHRpdGxlcykgZGVmaW5lZCBieSB0aGVtIGJlZm9yZSBoYW5kbGluZyB0aGUgcmVmZXJlbmNlcy5cbiAgICAvLyBTbywgd2UgZG8gc29ydCBvZiB3aGF0IEhUTUwgZG9lczogcHV0IG1ldGFkYXRhIGF0IHRoZSBzdGFydCAoaW4gaGVhZCksIGFuZFxuICAgIC8vIHRoZW4gcHV0IGNvbnRlbnQgYWZ0ZXIgKGBib2R5YCkuXG4gICAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gICAgbGV0IGhlYWQgPSBbXVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8RXZlbnQ+fSAqL1xuICAgIGxldCBib2R5ID0gW11cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGxpbmUgZW5kaW5nIHN0eWxlIHVzZWQgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgaWYgKFxuICAgICAgICAhbGluZUVuZGluZ1N0eWxlICYmXG4gICAgICAgIChldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsaW5lRW5kaW5nJyB8fFxuICAgICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmdCbGFuaycpXG4gICAgICApIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIdXNoLCBpdOKAmXMgYSBsaW5lIGVuZGluZy5cbiAgICAgICAgbGluZUVuZGluZ1N0eWxlID0gZXZlbnRzW2luZGV4XVsyXS5zbGljZVNlcmlhbGl6ZShldmVudHNbaW5kZXhdWzFdKVxuICAgICAgfVxuXG4gICAgICAvLyBQcmVwcm9jZXNzIGxpc3RzIHRvIGluZmVyIHdoZXRoZXIgdGhlIGxpc3QgaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgaWYgKFxuICAgICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsaXN0T3JkZXJlZCcgfHxcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnbGlzdFVub3JkZXJlZCdcbiAgICAgICkge1xuICAgICAgICBpZiAoZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgIGxpc3RTdGFjay5wdXNoKGluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXBhcmVMaXN0KGV2ZW50cy5zbGljZShsaXN0U3RhY2sucG9wKCksIGluZGV4KSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlIGRlZmluaXRpb25zIHRvIHRoZSBmcm9udC5cbiAgICAgIGlmIChldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdkZWZpbml0aW9uJykge1xuICAgICAgICBpZiAoZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgIGJvZHkgPSBwdXNoKGJvZHksIGV2ZW50cy5zbGljZShzdGFydCwgaW5kZXgpKVxuICAgICAgICAgIHN0YXJ0ID0gaW5kZXhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkID0gcHVzaChoZWFkLCBldmVudHMuc2xpY2Uoc3RhcnQsIGluZGV4ICsgMSkpXG4gICAgICAgICAgc3RhcnQgPSBpbmRleCArIDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBoZWFkID0gcHVzaChoZWFkLCBib2R5KVxuICAgIGhlYWQgPSBwdXNoKGhlYWQsIGV2ZW50cy5zbGljZShzdGFydCkpXG4gICAgaW5kZXggPSAtMVxuICAgIGNvbnN0IHJlc3VsdCA9IGhlYWRcblxuICAgIC8vIEhhbmRsZSB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LCBpZiBkZWZpbmVkLlxuICAgIGlmIChoYW5kbGVycy5lbnRlci5udWxsKSB7XG4gICAgICBoYW5kbGVycy5lbnRlci5udWxsLmNhbGwoY29udGV4dClcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYWxsIGV2ZW50cy5cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXMgPSBoYW5kbGVyc1tyZXN1bHRbaW5kZXhdWzBdXVxuICAgICAgY29uc3Qga2luZCA9IHJlc3VsdFtpbmRleF1bMV0udHlwZVxuICAgICAgY29uc3QgaGFuZGxlID0gaGFuZGxlc1traW5kXVxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaGFuZGxlcywga2luZCkgJiYgaGFuZGxlKSB7XG4gICAgICAgIGhhbmRsZS5jYWxsKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNsaWNlU2VyaWFsaXplOiByZXN1bHRbaW5kZXhdWzJdLnNsaWNlU2VyaWFsaXplXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICksXG4gICAgICAgICAgcmVzdWx0W2luZGV4XVsxXVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LCBpZiBkZWZpbmVkLlxuICAgIGlmIChoYW5kbGVycy5leGl0Lm51bGwpIHtcbiAgICAgIGhhbmRsZXJzLmV4aXQubnVsbC5jYWxsKGNvbnRleHQpXG4gICAgfVxuICAgIHJldHVybiBidWZmZXJzWzBdLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogRmlndXJlIG91dCB3aGV0aGVyIGxpc3RzIGFyZSBsb29zZSBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBzbGljZVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZUxpc3Qoc2xpY2UpIHtcbiAgICBjb25zdCBsZW5ndGggPSBzbGljZS5sZW5ndGhcbiAgICBsZXQgaW5kZXggPSAwIC8vIFNraXAgb3Blbi5cbiAgICBsZXQgY29udGFpbmVyQmFsYW5jZSA9IDBcbiAgICBsZXQgbG9vc2UgPSBmYWxzZVxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgYXRNYXJrZXJcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBzbGljZVtpbmRleF1cbiAgICAgIGlmIChldmVudFsxXS5fY29udGFpbmVyKSB7XG4gICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgIGNvbnRhaW5lckJhbGFuY2UrK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lckJhbGFuY2UtLVxuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgc3dpdGNoIChldmVudFsxXS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnbGlzdEl0ZW1QcmVmaXgnOiB7XG4gICAgICAgICAgICBpZiAoZXZlbnRbMF0gPT09ICdleGl0Jykge1xuICAgICAgICAgICAgICBhdE1hcmtlciA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2xpbmVQcmVmaXgnOiB7XG4gICAgICAgICAgICAvLyBJZ25vcmVcblxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnbGluZUVuZGluZ0JsYW5rJzoge1xuICAgICAgICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInICYmICFjb250YWluZXJCYWxhbmNlKSB7XG4gICAgICAgICAgICAgIGlmIChhdE1hcmtlcikge1xuICAgICAgICAgICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9vc2UgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlWzBdWzFdLl9sb29zZSA9IGxvb3NlXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0NvbXBpbGVDb250ZXh0WydzZXREYXRhJ119XG4gICAqL1xuICBmdW5jdGlvbiBzZXREYXRhKGtleSwgdmFsdWUpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhc3N1bWUgYHZhbHVlYCBpcyBvbWl0dGVkIChgdW5kZWZpbmVkYCBpcyBwYXNzZWQpIG9ubHlcbiAgICAvLyBpZiBhbGxvd2VkLlxuICAgIGRhdGFba2V5XSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0NvbXBpbGVDb250ZXh0WydnZXREYXRhJ119XG4gICAqL1xuICBmdW5jdGlvbiBnZXREYXRhKGtleSkge1xuICAgIHJldHVybiBkYXRhW2tleV1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7Q29tcGlsZUNvbnRleHRbJ2J1ZmZlciddfSAqL1xuICBmdW5jdGlvbiBidWZmZXIoKSB7XG4gICAgYnVmZmVycy5wdXNoKFtdKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtDb21waWxlQ29udGV4dFsncmVzdW1lJ119ICovXG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBjb25zdCBidWYgPSBidWZmZXJzLnBvcCgpXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtDb21waWxlQ29udGV4dFsndGFnJ119ICovXG4gIGZ1bmN0aW9uIHRhZyh2YWx1ZSkge1xuICAgIGlmICghdGFncykgcmV0dXJuXG4gICAgc2V0RGF0YSgnbGFzdFdhc1RhZycsIHRydWUpXG4gICAgYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdLnB1c2godmFsdWUpXG4gIH1cblxuICAvKiogQHR5cGUge0NvbXBpbGVDb250ZXh0WydyYXcnXX0gKi9cbiAgZnVuY3Rpb24gcmF3KHZhbHVlKSB7XG4gICAgc2V0RGF0YSgnbGFzdFdhc1RhZycpXG4gICAgYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdLnB1c2godmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogT3V0cHV0IGFuIGV4dHJhIGxpbmUgZW5kaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gbGluZUVuZGluZygpIHtcbiAgICByYXcobGluZUVuZGluZ1N0eWxlIHx8ICdcXG4nKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtDb21waWxlQ29udGV4dFsnbGluZUVuZGluZ0lmTmVlZGVkJ119ICovXG4gIGZ1bmN0aW9uIGxpbmVFbmRpbmdJZk5lZWRlZCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2J1ZmZlcnMubGVuZ3RoIC0gMV1cbiAgICBjb25zdCBzbGljZSA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV1cbiAgICBjb25zdCBwcmV2aW91cyA9IHNsaWNlID8gc2xpY2UuY2hhckNvZGVBdChzbGljZS5sZW5ndGggLSAxKSA6IG51bGxcbiAgICBpZiAocHJldmlvdXMgPT09IDEwIHx8IHByZXZpb3VzID09PSAxMyB8fCBwcmV2aW91cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxpbmVFbmRpbmcoKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtDb21waWxlQ29udGV4dFsnZW5jb2RlJ119ICovXG4gIGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBnZXREYXRhKCdpZ25vcmVFbmNvZGUnKSA/IHZhbHVlIDogX2VuY29kZSh2YWx1ZSlcbiAgfVxuXG4gIC8vXG4gIC8vIEhhbmRsZXJzLlxuICAvL1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25yZXN1bWVkcm9wKCkge1xuICAgIHJlc3VtZSgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmxpc3RvcmRlcmVkKHRva2VuKSB7XG4gICAgdGlnaHRTdGFjay5wdXNoKCF0b2tlbi5fbG9vc2UpXG4gICAgbGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICB0YWcoJzxvbCcpXG4gICAgc2V0RGF0YSgnZXhwZWN0Rmlyc3RJdGVtJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmVudGVybGlzdHVub3JkZXJlZCh0b2tlbikge1xuICAgIHRpZ2h0U3RhY2sucHVzaCghdG9rZW4uX2xvb3NlKVxuICAgIGxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgdGFnKCc8dWwnKVxuICAgIHNldERhdGEoJ2V4cGVjdEZpcnN0SXRlbScsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmxpc3RpdGVtdmFsdWUodG9rZW4pIHtcbiAgICBpZiAoZ2V0RGF0YSgnZXhwZWN0Rmlyc3RJdGVtJykpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyLnBhcnNlSW50KHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLCAxMClcbiAgICAgIGlmICh2YWx1ZSAhPT0gMSkge1xuICAgICAgICB0YWcoJyBzdGFydD1cIicgKyBlbmNvZGUoU3RyaW5nKHZhbHVlKSkgKyAnXCInKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmxpc3RpdGVtbWFya2VyKCkge1xuICAgIGlmIChnZXREYXRhKCdleHBlY3RGaXJzdEl0ZW0nKSkge1xuICAgICAgdGFnKCc+JylcbiAgICB9IGVsc2Uge1xuICAgICAgb25leGl0bGlzdGl0ZW0oKVxuICAgIH1cbiAgICBsaW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgIHRhZygnPGxpPicpXG4gICAgc2V0RGF0YSgnZXhwZWN0Rmlyc3RJdGVtJylcbiAgICAvLyDigJxIYWNr4oCdIHRvIHByZXZlbnQgYSBsaW5lIGVuZGluZyBmcm9tIHNob3dpbmcgdXAgaWYgdGhlIGl0ZW0gaXMgZW1wdHkuXG4gICAgc2V0RGF0YSgnbGFzdFdhc1RhZycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGxpc3RvcmRlcmVkKCkge1xuICAgIG9uZXhpdGxpc3RpdGVtKClcbiAgICB0aWdodFN0YWNrLnBvcCgpXG4gICAgbGluZUVuZGluZygpXG4gICAgdGFnKCc8L29sPicpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGxpc3R1bm9yZGVyZWQoKSB7XG4gICAgb25leGl0bGlzdGl0ZW0oKVxuICAgIHRpZ2h0U3RhY2sucG9wKClcbiAgICBsaW5lRW5kaW5nKClcbiAgICB0YWcoJzwvdWw+JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0bGlzdGl0ZW0oKSB7XG4gICAgaWYgKGdldERhdGEoJ2xhc3RXYXNUYWcnKSAmJiAhZ2V0RGF0YSgnc2x1cnBBbGxMaW5lRW5kaW5ncycpKSB7XG4gICAgICBsaW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgIH1cbiAgICB0YWcoJzwvbGk+JylcbiAgICBzZXREYXRhKCdzbHVycEFsbExpbmVFbmRpbmdzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmVudGVyYmxvY2txdW90ZSgpIHtcbiAgICB0aWdodFN0YWNrLnB1c2goZmFsc2UpXG4gICAgbGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICB0YWcoJzxibG9ja3F1b3RlPicpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YmxvY2txdW90ZSgpIHtcbiAgICB0aWdodFN0YWNrLnBvcCgpXG4gICAgbGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICB0YWcoJzwvYmxvY2txdW90ZT4nKVxuICAgIHNldERhdGEoJ3NsdXJwQWxsTGluZUVuZGluZ3MnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJwYXJhZ3JhcGgoKSB7XG4gICAgaWYgKCF0aWdodFN0YWNrW3RpZ2h0U3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgIGxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0YWcoJzxwPicpXG4gICAgfVxuICAgIHNldERhdGEoJ3NsdXJwQWxsTGluZUVuZGluZ3MnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHBhcmFncmFwaCgpIHtcbiAgICBpZiAodGlnaHRTdGFja1t0aWdodFN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICBzZXREYXRhKCdzbHVycEFsbExpbmVFbmRpbmdzJywgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnKCc8L3A+JylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmNvZGVmZW5jZWQoKSB7XG4gICAgbGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICB0YWcoJzxwcmU+PGNvZGUnKVxuICAgIHNldERhdGEoJ2ZlbmNlc0NvdW50JywgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvKCkge1xuICAgIGNvbnN0IHZhbHVlID0gcmVzdW1lKClcbiAgICB0YWcoJyBjbGFzcz1cImxhbmd1YWdlLScgKyB2YWx1ZSArICdcIicpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlKCkge1xuICAgIGNvbnN0IGNvdW50ID0gZ2V0RGF0YSgnZmVuY2VzQ291bnQnKSB8fCAwXG4gICAgaWYgKCFjb3VudCkge1xuICAgICAgdGFnKCc+JylcbiAgICAgIHNldERhdGEoJ3NsdXJwT25lTGluZUVuZGluZycsIHRydWUpXG4gICAgfVxuICAgIHNldERhdGEoJ2ZlbmNlc0NvdW50JywgY291bnQgKyAxKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJjb2RlaW5kZW50ZWQoKSB7XG4gICAgbGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICB0YWcoJzxwcmU+PGNvZGU+JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRmbG93Y29kZSgpIHtcbiAgICBjb25zdCBjb3VudCA9IGdldERhdGEoJ2ZlbmNlc0NvdW50JylcblxuICAgIC8vIE9uZSBzcGVjaWFsIGNhc2UgaXMgaWYgd2UgYXJlIGluc2lkZSBhIGNvbnRhaW5lciwgYW5kIHRoZSBmZW5jZWQgY29kZSB3YXNcbiAgICAvLyBub3QgY2xvc2VkIChtZWFuaW5nIGl0IHJ1bnMgdG8gdGhlIGVuZCkuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgZm9sbG93aW5nIGxpbmUgZW5kaW5nLCBpcyBjb25zaWRlcmVkICpvdXRzaWRlKiB0aGVcbiAgICAvLyBmZW5jZWQgY29kZSBhbmQgYmxvY2sgcXVvdGUgYnkgbWljcm9tYXJrLCBidXQgQ00gd2FudHMgdG8gdHJlYXQgdGhhdFxuICAgIC8vIGVuZGluZyBhcyBwYXJ0IG9mIHRoZSBjb2RlLlxuICAgIGlmIChcbiAgICAgIGNvdW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGNvdW50IDwgMiAmJlxuICAgICAgZGF0YS50aWdodFN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICFnZXREYXRhKCdsYXN0V2FzVGFnJylcbiAgICApIHtcbiAgICAgIGxpbmVFbmRpbmcoKVxuICAgIH1cblxuICAgIC8vIEJ1dCBpbiBtb3N0IGNhc2VzLCBpdOKAmXMgc2ltcGxlcjogd2hlbiB3ZeKAmXZlIHNlZW4gc29tZSBkYXRhLCBlbWl0IGFuIGV4dHJhXG4gICAgLy8gbGluZSBlbmRpbmcgd2hlbiBuZWVkZWQuXG4gICAgaWYgKGdldERhdGEoJ2Zsb3dDb2RlU2VlbkRhdGEnKSkge1xuICAgICAgbGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICB9XG4gICAgdGFnKCc8L2NvZGU+PC9wcmU+JylcbiAgICBpZiAoY291bnQgIT09IHVuZGVmaW5lZCAmJiBjb3VudCA8IDIpIGxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgc2V0RGF0YSgnZmxvd0NvZGVTZWVuRGF0YScpXG4gICAgc2V0RGF0YSgnZmVuY2VzQ291bnQnKVxuICAgIHNldERhdGEoJ3NsdXJwT25lTGluZUVuZGluZycpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmltYWdlKCkge1xuICAgIG1lZGlhU3RhY2sucHVzaCh7XG4gICAgICBpbWFnZTogdHJ1ZVxuICAgIH0pXG4gICAgdGFncyA9IHVuZGVmaW5lZCAvLyBEaXNhbGxvdyB0YWdzLlxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaW5rKCkge1xuICAgIG1lZGlhU3RhY2sucHVzaCh7fSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRsYWJlbHRleHQodG9rZW4pIHtcbiAgICBtZWRpYVN0YWNrW21lZGlhU3RhY2subGVuZ3RoIC0gMV0ubGFiZWxJZCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0bGFiZWwoKSB7XG4gICAgbWVkaWFTdGFja1ttZWRpYVN0YWNrLmxlbmd0aCAtIDFdLmxhYmVsID0gcmVzdW1lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRyZWZlcmVuY2VzdHJpbmcodG9rZW4pIHtcbiAgICBtZWRpYVN0YWNrW21lZGlhU3RhY2subGVuZ3RoIC0gMV0ucmVmZXJlbmNlSWQgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJyZXNvdXJjZSgpIHtcbiAgICBidWZmZXIoKSAvLyBXZSBjYW4gaGF2ZSBsaW5lIGVuZGluZ3MgaW4gdGhlIHJlc291cmNlLCBpZ25vcmUgdGhlbS5cbiAgICBtZWRpYVN0YWNrW21lZGlhU3RhY2subGVuZ3RoIC0gMV0uZGVzdGluYXRpb24gPSAnJ1xuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nKCkge1xuICAgIGJ1ZmZlcigpXG4gICAgLy8gSWdub3JlIGVuY29kaW5nIHRoZSByZXN1bHQsIGFzIHdl4oCZbGwgZmlyc3QgcGVyY2VudCBlbmNvZGUgdGhlIHVybCBhbmRcbiAgICAvLyBlbmNvZGUgbWFudWFsbHkgYWZ0ZXIuXG4gICAgc2V0RGF0YSgnaWdub3JlRW5jb2RlJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nKCkge1xuICAgIG1lZGlhU3RhY2tbbWVkaWFTdGFjay5sZW5ndGggLSAxXS5kZXN0aW5hdGlvbiA9IHJlc3VtZSgpXG4gICAgc2V0RGF0YSgnaWdub3JlRW5jb2RlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nKCkge1xuICAgIG1lZGlhU3RhY2tbbWVkaWFTdGFjay5sZW5ndGggLSAxXS50aXRsZSA9IHJlc3VtZSgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0bWVkaWEoKSB7XG4gICAgbGV0IGluZGV4ID0gbWVkaWFTdGFjay5sZW5ndGggLSAxIC8vIFNraXAgY3VycmVudC5cbiAgICBjb25zdCBtZWRpYSA9IG1lZGlhU3RhY2tbaW5kZXhdXG4gICAgY29uc3QgaWQgPSBtZWRpYS5yZWZlcmVuY2VJZCB8fCBtZWRpYS5sYWJlbElkXG4gICAgY29uc3QgY29udGV4dCA9XG4gICAgICBtZWRpYS5kZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZGVmaW5pdGlvbnNbbm9ybWFsaXplSWRlbnRpZmllcihpZCldXG4gICAgICAgIDogbWVkaWFcbiAgICB0YWdzID0gdHJ1ZVxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAobWVkaWFTdGFja1tpbmRleF0uaW1hZ2UpIHtcbiAgICAgICAgdGFncyA9IHVuZGVmaW5lZFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWVkaWEuaW1hZ2UpIHtcbiAgICAgIHRhZyhcbiAgICAgICAgJzxpbWcgc3JjPVwiJyArXG4gICAgICAgICAgc2FuaXRpemVVcmkoXG4gICAgICAgICAgICBjb250ZXh0LmRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgc2V0dGluZ3MuYWxsb3dEYW5nZXJvdXNQcm90b2NvbCA/IHVuZGVmaW5lZCA6IHByb3RvY29sU3JjXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ1wiIGFsdD1cIidcbiAgICAgIClcbiAgICAgIHJhdyhtZWRpYS5sYWJlbClcbiAgICAgIHRhZygnXCInKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWcoXG4gICAgICAgICc8YSBocmVmPVwiJyArXG4gICAgICAgICAgc2FuaXRpemVVcmkoXG4gICAgICAgICAgICBjb250ZXh0LmRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgc2V0dGluZ3MuYWxsb3dEYW5nZXJvdXNQcm90b2NvbCA/IHVuZGVmaW5lZCA6IHByb3RvY29sSHJlZlxuICAgICAgICAgICkgK1xuICAgICAgICAgICdcIidcbiAgICAgIClcbiAgICB9XG4gICAgdGFnKGNvbnRleHQudGl0bGUgPyAnIHRpdGxlPVwiJyArIGNvbnRleHQudGl0bGUgKyAnXCInIDogJycpXG4gICAgaWYgKG1lZGlhLmltYWdlKSB7XG4gICAgICB0YWcoJyAvPicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZygnPicpXG4gICAgICByYXcobWVkaWEubGFiZWwpXG4gICAgICB0YWcoJzwvYT4nKVxuICAgIH1cbiAgICBtZWRpYVN0YWNrLnBvcCgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmRlZmluaXRpb24oKSB7XG4gICAgYnVmZmVyKClcbiAgICBtZWRpYVN0YWNrLnB1c2goe30pXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0ZGVmaW5pdGlvbmxhYmVsc3RyaW5nKHRva2VuKSB7XG4gICAgLy8gRGlzY2FyZCBsYWJlbCwgdXNlIHRoZSBzb3VyY2UgY29udGVudCBpbnN0ZWFkLlxuICAgIHJlc3VtZSgpXG4gICAgbWVkaWFTdGFja1ttZWRpYVN0YWNrLmxlbmd0aCAtIDFdLmxhYmVsSWQgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmcoKSB7XG4gICAgYnVmZmVyKClcbiAgICBzZXREYXRhKCdpZ25vcmVFbmNvZGUnLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZygpIHtcbiAgICBtZWRpYVN0YWNrW21lZGlhU3RhY2subGVuZ3RoIC0gMV0uZGVzdGluYXRpb24gPSByZXN1bWUoKVxuICAgIHNldERhdGEoJ2lnbm9yZUVuY29kZScpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0ZGVmaW5pdGlvbnRpdGxlc3RyaW5nKCkge1xuICAgIG1lZGlhU3RhY2tbbWVkaWFTdGFjay5sZW5ndGggLSAxXS50aXRsZSA9IHJlc3VtZSgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0ZGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBtZWRpYSA9IG1lZGlhU3RhY2tbbWVkaWFTdGFjay5sZW5ndGggLSAxXVxuICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWRlbnRpZmllcihtZWRpYS5sYWJlbElkKVxuICAgIHJlc3VtZSgpXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb25zLCBpZCkpIHtcbiAgICAgIGRlZmluaXRpb25zW2lkXSA9IG1lZGlhU3RhY2tbbWVkaWFTdGFjay5sZW5ndGggLSAxXVxuICAgIH1cbiAgICBtZWRpYVN0YWNrLnBvcCgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmNvbnRlbnQoKSB7XG4gICAgc2V0RGF0YSgnc2x1cnBBbGxMaW5lRW5kaW5ncycsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YXR4aGVhZGluZ3NlcXVlbmNlKHRva2VuKSB7XG4gICAgLy8gRXhpdCBmb3IgZnVydGhlciBzZXF1ZW5jZXMuXG4gICAgaWYgKGdldERhdGEoJ2hlYWRpbmdSYW5rJykpIHJldHVyblxuICAgIHNldERhdGEoJ2hlYWRpbmdSYW5rJywgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikubGVuZ3RoKVxuICAgIGxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgdGFnKCc8aCcgKyBnZXREYXRhKCdoZWFkaW5nUmFuaycpICsgJz4nKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJzZXRleHRoZWFkaW5nKCkge1xuICAgIGJ1ZmZlcigpXG4gICAgc2V0RGF0YSgnc2x1cnBBbGxMaW5lRW5kaW5ncycpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZ3RleHQoKSB7XG4gICAgc2V0RGF0YSgnc2x1cnBBbGxMaW5lRW5kaW5ncycsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YXR4aGVhZGluZygpIHtcbiAgICB0YWcoJzwvaCcgKyBnZXREYXRhKCdoZWFkaW5nUmFuaycpICsgJz4nKVxuICAgIHNldERhdGEoJ2hlYWRpbmdSYW5rJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRzZXRleHRoZWFkaW5nbGluZXNlcXVlbmNlKHRva2VuKSB7XG4gICAgc2V0RGF0YShcbiAgICAgICdoZWFkaW5nUmFuaycsXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKS5jaGFyQ29kZUF0KDApID09PSA2MSA/IDEgOiAyXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmcoKSB7XG4gICAgY29uc3QgdmFsdWUgPSByZXN1bWUoKVxuICAgIGxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgdGFnKCc8aCcgKyBnZXREYXRhKCdoZWFkaW5nUmFuaycpICsgJz4nKVxuICAgIHJhdyh2YWx1ZSlcbiAgICB0YWcoJzwvaCcgKyBnZXREYXRhKCdoZWFkaW5nUmFuaycpICsgJz4nKVxuICAgIHNldERhdGEoJ3NsdXJwQWxsTGluZUVuZGluZ3MnKVxuICAgIHNldERhdGEoJ2hlYWRpbmdSYW5rJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRkYXRhKHRva2VuKSB7XG4gICAgcmF3KGVuY29kZSh0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKSkpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0bGluZWVuZGluZyh0b2tlbikge1xuICAgIGlmIChnZXREYXRhKCdzbHVycEFsbExpbmVFbmRpbmdzJykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoZ2V0RGF0YSgnc2x1cnBPbmVMaW5lRW5kaW5nJykpIHtcbiAgICAgIHNldERhdGEoJ3NsdXJwT25lTGluZUVuZGluZycpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGdldERhdGEoJ2luQ29kZVRleHQnKSkge1xuICAgICAgcmF3KCcgJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByYXcoZW5jb2RlKHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmxvd3ZhbHVlKHRva2VuKSB7XG4gICAgcmF3KGVuY29kZSh0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKSkpXG4gICAgc2V0RGF0YSgnZmxvd0NvZGVTZWVuRGF0YScsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0aGFyZGJyZWFrKCkge1xuICAgIHRhZygnPGJyIC8+JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmh0bWxmbG93KCkge1xuICAgIGxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgb25lbnRlcmh0bWwoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRodG1sKCkge1xuICAgIHNldERhdGEoJ2lnbm9yZUVuY29kZScpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJodG1sKCkge1xuICAgIGlmIChzZXR0aW5ncy5hbGxvd0Rhbmdlcm91c0h0bWwpIHtcbiAgICAgIHNldERhdGEoJ2lnbm9yZUVuY29kZScsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBvbmVudGVyZW1waGFzaXMoKSB7XG4gICAgdGFnKCc8ZW0+JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcnN0cm9uZygpIHtcbiAgICB0YWcoJzxzdHJvbmc+JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25lbnRlcmNvZGV0ZXh0KCkge1xuICAgIHNldERhdGEoJ2luQ29kZVRleHQnLCB0cnVlKVxuICAgIHRhZygnPGNvZGU+JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZXRleHQoKSB7XG4gICAgc2V0RGF0YSgnaW5Db2RlVGV4dCcpXG4gICAgdGFnKCc8L2NvZGU+JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0ZW1waGFzaXMoKSB7XG4gICAgdGFnKCc8L2VtPicpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHN0cm9uZygpIHtcbiAgICB0YWcoJzwvc3Ryb25nPicpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHRoZW1hdGljYnJlYWsoKSB7XG4gICAgbGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICB0YWcoJzxociAvPicpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyKHRva2VuKSB7XG4gICAgc2V0RGF0YSgnY2hhcmFjdGVyUmVmZXJlbmNlVHlwZScsIHRva2VuLnR5cGUpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNldmFsdWUodG9rZW4pIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2VgIGNhbiByZXR1cm4gZmFsc2UgZm9yXG4gICAgLy8gaW52YWxpZCBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcywgYnV0IGV2ZXJ5dGhpbmcgd2XigJl2ZSB0b2tlbml6ZWQgaXNcbiAgICAvLyB2YWxpZC5cbiAgICB2YWx1ZSA9IGdldERhdGEoJ2NoYXJhY3RlclJlZmVyZW5jZVR5cGUnKVxuICAgICAgPyBkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGdldERhdGEoJ2NoYXJhY3RlclJlZmVyZW5jZVR5cGUnKSA9PT1cbiAgICAgICAgICAgICdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljJ1xuICAgICAgICAgICAgPyAxMFxuICAgICAgICAgICAgOiAxNlxuICAgICAgICApXG4gICAgICA6IGRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlKHZhbHVlKVxuICAgIHJhdyhlbmNvZGUodmFsdWUpKVxuICAgIHNldERhdGEoJ2NoYXJhY3RlclJlZmVyZW5jZVR5cGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGF1dG9saW5rcHJvdG9jb2wodG9rZW4pIHtcbiAgICBjb25zdCB1cmkgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIHRhZyhcbiAgICAgICc8YSBocmVmPVwiJyArXG4gICAgICAgIHNhbml0aXplVXJpKFxuICAgICAgICAgIHVyaSxcbiAgICAgICAgICBzZXR0aW5ncy5hbGxvd0Rhbmdlcm91c1Byb3RvY29sID8gdW5kZWZpbmVkIDogcHJvdG9jb2xIcmVmXG4gICAgICAgICkgK1xuICAgICAgICAnXCI+J1xuICAgIClcbiAgICByYXcoZW5jb2RlKHVyaSkpXG4gICAgdGFnKCc8L2E+JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRhdXRvbGlua2VtYWlsKHRva2VuKSB7XG4gICAgY29uc3QgdXJpID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICB0YWcoJzxhIGhyZWY9XCInICsgc2FuaXRpemVVcmkoJ21haWx0bzonICsgdXJpKSArICdcIj4nKVxuICAgIHJhdyhlbmNvZGUodXJpKSlcbiAgICB0YWcoJzwvYT4nKVxuICB9XG59XG4iXSwibmFtZXMiOlsiY29tcGlsZSIsImhhc093blByb3BlcnR5IiwicHJvdG9jb2xIcmVmIiwicHJvdG9jb2xTcmMiLCJvcHRpb25zIiwic2V0dGluZ3MiLCJ0YWdzIiwiZGVmaW5pdGlvbnMiLCJidWZmZXJzIiwibWVkaWFTdGFjayIsInRpZ2h0U3RhY2siLCJkZWZhdWx0SGFuZGxlcnMiLCJlbnRlciIsImJsb2NrUXVvdGUiLCJvbmVudGVyYmxvY2txdW90ZSIsImNvZGVGZW5jZWQiLCJvbmVudGVyY29kZWZlbmNlZCIsImNvZGVGZW5jZWRGZW5jZUluZm8iLCJidWZmZXIiLCJjb2RlRmVuY2VkRmVuY2VNZXRhIiwiY29kZUluZGVudGVkIiwib25lbnRlcmNvZGVpbmRlbnRlZCIsImNvZGVUZXh0Iiwib25lbnRlcmNvZGV0ZXh0IiwiY29udGVudCIsIm9uZW50ZXJjb250ZW50IiwiZGVmaW5pdGlvbiIsIm9uZW50ZXJkZWZpbml0aW9uIiwiZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nIiwib25lbnRlcmRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZyIsImRlZmluaXRpb25MYWJlbFN0cmluZyIsImRlZmluaXRpb25UaXRsZVN0cmluZyIsImVtcGhhc2lzIiwib25lbnRlcmVtcGhhc2lzIiwiaHRtbEZsb3ciLCJvbmVudGVyaHRtbGZsb3ciLCJodG1sVGV4dCIsIm9uZW50ZXJodG1sIiwiaW1hZ2UiLCJvbmVudGVyaW1hZ2UiLCJsYWJlbCIsImxpbmsiLCJvbmVudGVybGluayIsImxpc3RJdGVtTWFya2VyIiwib25lbnRlcmxpc3RpdGVtbWFya2VyIiwibGlzdEl0ZW1WYWx1ZSIsIm9uZW50ZXJsaXN0aXRlbXZhbHVlIiwibGlzdE9yZGVyZWQiLCJvbmVudGVybGlzdG9yZGVyZWQiLCJsaXN0VW5vcmRlcmVkIiwib25lbnRlcmxpc3R1bm9yZGVyZWQiLCJwYXJhZ3JhcGgiLCJvbmVudGVycGFyYWdyYXBoIiwicmVmZXJlbmNlIiwicmVzb3VyY2UiLCJvbmVudGVycmVzb3VyY2UiLCJyZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nIiwib25lbnRlcnJlc291cmNlZGVzdGluYXRpb25zdHJpbmciLCJyZXNvdXJjZVRpdGxlU3RyaW5nIiwic2V0ZXh0SGVhZGluZyIsIm9uZW50ZXJzZXRleHRoZWFkaW5nIiwic3Ryb25nIiwib25lbnRlcnN0cm9uZyIsImV4aXQiLCJhdHhIZWFkaW5nIiwib25leGl0YXR4aGVhZGluZyIsImF0eEhlYWRpbmdTZXF1ZW5jZSIsIm9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSIsImF1dG9saW5rRW1haWwiLCJvbmV4aXRhdXRvbGlua2VtYWlsIiwiYXV0b2xpbmtQcm90b2NvbCIsIm9uZXhpdGF1dG9saW5rcHJvdG9jb2wiLCJvbmV4aXRibG9ja3F1b3RlIiwiY2hhcmFjdGVyRXNjYXBlVmFsdWUiLCJvbmV4aXRkYXRhIiwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWwiLCJvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIiLCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljIiwiY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWUiLCJvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSIsIm9uZXhpdGZsb3djb2RlIiwiY29kZUZlbmNlZEZlbmNlIiwib25leGl0Y29kZWZlbmNlZGZlbmNlIiwib25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbyIsIm9ucmVzdW1lZHJvcCIsImNvZGVGbG93VmFsdWUiLCJvbmV4aXRjb2RlZmxvd3ZhbHVlIiwib25leGl0Y29kZXRleHQiLCJjb2RlVGV4dERhdGEiLCJkYXRhIiwib25leGl0ZGVmaW5pdGlvbiIsIm9uZXhpdGRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZyIsIm9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyIsIm9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZyIsIm9uZXhpdGVtcGhhc2lzIiwiaGFyZEJyZWFrRXNjYXBlIiwib25leGl0aGFyZGJyZWFrIiwiaGFyZEJyZWFrVHJhaWxpbmciLCJvbmV4aXRodG1sIiwiaHRtbEZsb3dEYXRhIiwiaHRtbFRleHREYXRhIiwib25leGl0bWVkaWEiLCJvbmV4aXRsYWJlbCIsImxhYmVsVGV4dCIsIm9uZXhpdGxhYmVsdGV4dCIsImxpbmVFbmRpbmciLCJvbmV4aXRsaW5lZW5kaW5nIiwib25leGl0bGlzdG9yZGVyZWQiLCJvbmV4aXRsaXN0dW5vcmRlcmVkIiwib25leGl0cGFyYWdyYXBoIiwicmVmZXJlbmNlU3RyaW5nIiwib25leGl0cmVmZXJlbmNlc3RyaW5nIiwib25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZyIsIm9uZXhpdHJlc291cmNldGl0bGVzdHJpbmciLCJvbmV4aXRzZXRleHRoZWFkaW5nIiwic2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZSIsIm9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UiLCJzZXRleHRIZWFkaW5nVGV4dCIsIm9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0Iiwib25leGl0c3Ryb25nIiwidGhlbWF0aWNCcmVhayIsIm9uZXhpdHRoZW1hdGljYnJlYWsiLCJoYW5kbGVycyIsImNvbWJpbmVIdG1sRXh0ZW5zaW9ucyIsImNvbmNhdCIsImh0bWxFeHRlbnNpb25zIiwiY29udGV4dCIsImxpbmVFbmRpbmdJZk5lZWRlZCIsImVuY29kZSIsInJhdyIsInRhZyIsInJlc3VtZSIsInNldERhdGEiLCJnZXREYXRhIiwibGluZUVuZGluZ1N0eWxlIiwiZGVmYXVsdExpbmVFbmRpbmciLCJldmVudHMiLCJpbmRleCIsInN0YXJ0IiwibGlzdFN0YWNrIiwiaGVhZCIsImJvZHkiLCJsZW5ndGgiLCJ0eXBlIiwic2xpY2VTZXJpYWxpemUiLCJwdXNoIiwicHJlcGFyZUxpc3QiLCJzbGljZSIsInBvcCIsInJlc3VsdCIsIm51bGwiLCJjYWxsIiwiaGFuZGxlcyIsImtpbmQiLCJoYW5kbGUiLCJPYmplY3QiLCJhc3NpZ24iLCJqb2luIiwiY29udGFpbmVyQmFsYW5jZSIsImxvb3NlIiwiYXRNYXJrZXIiLCJldmVudCIsIl9jb250YWluZXIiLCJ1bmRlZmluZWQiLCJfbG9vc2UiLCJrZXkiLCJ2YWx1ZSIsImJ1ZiIsInByZXZpb3VzIiwiY2hhckNvZGVBdCIsIl9lbmNvZGUiLCJ0b2tlbiIsIk51bWJlciIsInBhcnNlSW50IiwiU3RyaW5nIiwib25leGl0bGlzdGl0ZW0iLCJjb3VudCIsImxhYmVsSWQiLCJyZWZlcmVuY2VJZCIsImRlc3RpbmF0aW9uIiwidGl0bGUiLCJtZWRpYSIsImlkIiwibm9ybWFsaXplSWRlbnRpZmllciIsInNhbml0aXplVXJpIiwiYWxsb3dEYW5nZXJvdXNQcm90b2NvbCIsImFsbG93RGFuZ2Vyb3VzSHRtbCIsImRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UiLCJkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZSIsInVyaSJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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