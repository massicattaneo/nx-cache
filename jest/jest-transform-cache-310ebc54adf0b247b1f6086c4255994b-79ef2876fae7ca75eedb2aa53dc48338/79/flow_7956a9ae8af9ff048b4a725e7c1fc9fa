44fcd1552a2cb911e9fefd97f3fa9dd0
/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "flow", {
    enumerable: true,
    get: function() {
        return flow;
    }
});
const _micromarkcorecommonmark = require("micromark-core-commonmark");
const _micromarkfactoryspace = require("micromark-factory-space");
const flow = {
    tokenize: initializeFlow
};
/**
 * @this {TokenizeContext}
 * @type {Initializer}
 */ function initializeFlow(effects) {
    const self = this;
    const initial = effects.attempt(// Try to parse a blank line.
    _micromarkcorecommonmark.blankLine, atBlankEnding, // Try to parse initial flow (essentially, only code).
    effects.attempt(this.parser.constructs.flowInitial, afterConstruct, (0, _micromarkfactoryspace.factorySpace)(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(_micromarkcorecommonmark.content, afterConstruct)), 'linePrefix')));
    return initial;
    /** @type {State} */ function atBlankEnding(code) {
        if (code === null) {
            effects.consume(code);
            return;
        }
        effects.enter('lineEndingBlank');
        effects.consume(code);
        effects.exit('lineEndingBlank');
        self.currentConstruct = undefined;
        return initial;
    }
    /** @type {State} */ function afterConstruct(code) {
        if (code === null) {
            effects.consume(code);
            return;
        }
        effects.enter('lineEnding');
        effects.consume(code);
        effects.exit('lineEnding');
        self.currentConstruct = undefined;
        return initial;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9taWNyb21hcmsvbGliL2luaXRpYWxpemUvZmxvdy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSW5pdGlhbENvbnN0cnVjdH0gSW5pdGlhbENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Jbml0aWFsaXplcn0gSW5pdGlhbGl6ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplQ29udGV4dH0gVG9rZW5pemVDb250ZXh0XG4gKi9cblxuaW1wb3J0IHtibGFua0xpbmUsIGNvbnRlbnR9IGZyb20gJ21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsnXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuLyoqIEB0eXBlIHtJbml0aWFsQ29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IGZsb3cgPSB7XG4gIHRva2VuaXplOiBpbml0aWFsaXplRmxvd1xufVxuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7SW5pdGlhbGl6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVGbG93KGVmZmVjdHMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgaW5pdGlhbCA9IGVmZmVjdHMuYXR0ZW1wdChcbiAgICAvLyBUcnkgdG8gcGFyc2UgYSBibGFuayBsaW5lLlxuICAgIGJsYW5rTGluZSxcbiAgICBhdEJsYW5rRW5kaW5nLFxuICAgIC8vIFRyeSB0byBwYXJzZSBpbml0aWFsIGZsb3cgKGVzc2VudGlhbGx5LCBvbmx5IGNvZGUpLlxuICAgIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZmxvd0luaXRpYWwsXG4gICAgICBhZnRlckNvbnN0cnVjdCxcbiAgICAgIGZhY3RvcnlTcGFjZShcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgZWZmZWN0cy5hdHRlbXB0KFxuICAgICAgICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZmxvdyxcbiAgICAgICAgICBhZnRlckNvbnN0cnVjdCxcbiAgICAgICAgICBlZmZlY3RzLmF0dGVtcHQoY29udGVudCwgYWZ0ZXJDb25zdHJ1Y3QpXG4gICAgICAgICksXG4gICAgICAgICdsaW5lUHJlZml4J1xuICAgICAgKVxuICAgIClcbiAgKVxuICByZXR1cm4gaW5pdGlhbFxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIGF0QmxhbmtFbmRpbmcoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nQmxhbmsnKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnbGluZUVuZGluZ0JsYW5rJylcbiAgICBzZWxmLmN1cnJlbnRDb25zdHJ1Y3QgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gaW5pdGlhbFxuICB9XG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgZnVuY3Rpb24gYWZ0ZXJDb25zdHJ1Y3QoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlZmZlY3RzLmVudGVyKCdsaW5lRW5kaW5nJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2xpbmVFbmRpbmcnKVxuICAgIHNlbGYuY3VycmVudENvbnN0cnVjdCA9IHVuZGVmaW5lZFxuICAgIHJldHVybiBpbml0aWFsXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmbG93IiwidG9rZW5pemUiLCJpbml0aWFsaXplRmxvdyIsImVmZmVjdHMiLCJzZWxmIiwiaW5pdGlhbCIsImF0dGVtcHQiLCJibGFua0xpbmUiLCJhdEJsYW5rRW5kaW5nIiwicGFyc2VyIiwiY29uc3RydWN0cyIsImZsb3dJbml0aWFsIiwiYWZ0ZXJDb25zdHJ1Y3QiLCJmYWN0b3J5U3BhY2UiLCJjb250ZW50IiwiY29kZSIsImNvbnN1bWUiLCJlbnRlciIsImV4aXQiLCJjdXJyZW50Q29uc3RydWN0IiwidW5kZWZpbmVkIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7K0JBTVlBOzs7ZUFBQUE7Ozt5Q0FKb0I7dUNBQ047QUFHcEIsTUFBTUEsT0FBTztJQUNsQkMsVUFBVUM7QUFDWjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNBLGVBQWVDLE9BQU87SUFDN0IsTUFBTUMsT0FBTyxJQUFJO0lBQ2pCLE1BQU1DLFVBQVVGLFFBQVFHLE9BQU8sQ0FDN0IsNkJBQTZCO0lBQzdCQyxrQ0FBUyxFQUNUQyxlQUNBLHNEQUFzRDtJQUN0REwsUUFBUUcsT0FBTyxDQUNiLElBQUksQ0FBQ0csTUFBTSxDQUFDQyxVQUFVLENBQUNDLFdBQVcsRUFDbENDLGdCQUNBQyxJQUFBQSxtQ0FBWSxFQUNWVixTQUNBQSxRQUFRRyxPQUFPLENBQ2IsSUFBSSxDQUFDRyxNQUFNLENBQUNDLFVBQVUsQ0FBQ1YsSUFBSSxFQUMzQlksZ0JBQ0FULFFBQVFHLE9BQU8sQ0FBQ1EsZ0NBQU8sRUFBRUYsa0JBRTNCO0lBSU4sT0FBT1A7SUFFUCxrQkFBa0IsR0FDbEIsU0FBU0csY0FBY08sSUFBSTtRQUN6QixJQUFJQSxTQUFTLE1BQU07WUFDakJaLFFBQVFhLE9BQU8sQ0FBQ0Q7WUFDaEI7UUFDRjtRQUNBWixRQUFRYyxLQUFLLENBQUM7UUFDZGQsUUFBUWEsT0FBTyxDQUFDRDtRQUNoQlosUUFBUWUsSUFBSSxDQUFDO1FBQ2JkLEtBQUtlLGdCQUFnQixHQUFHQztRQUN4QixPQUFPZjtJQUNUO0lBRUEsa0JBQWtCLEdBQ2xCLFNBQVNPLGVBQWVHLElBQUk7UUFDMUIsSUFBSUEsU0FBUyxNQUFNO1lBQ2pCWixRQUFRYSxPQUFPLENBQUNEO1lBQ2hCO1FBQ0Y7UUFDQVosUUFBUWMsS0FBSyxDQUFDO1FBQ2RkLFFBQVFhLE9BQU8sQ0FBQ0Q7UUFDaEJaLFFBQVFlLElBQUksQ0FBQztRQUNiZCxLQUFLZSxnQkFBZ0IsR0FBR0M7UUFDeEIsT0FBT2Y7SUFDVDtBQUNGIn0=