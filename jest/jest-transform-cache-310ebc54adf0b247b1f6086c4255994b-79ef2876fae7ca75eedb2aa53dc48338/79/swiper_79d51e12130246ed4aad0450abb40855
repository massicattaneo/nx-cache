2817c2148438287c18302a122ea80054
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Swiper", {
    enumerable: true,
    get: function() {
        return Swiper;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _swiper = /*#__PURE__*/ _interop_require_default(require("swiper"));
const _getparams = require("../components-shared/get-params.js");
const _mountswiper = require("../components-shared/mount-swiper.js");
const _utils = require("../components-shared/utils.js");
const _getchangedparams = require("../components-shared/get-changed-params.js");
const _getchildren = require("./get-children.js");
const _updateswiper = require("../components-shared/update-swiper.js");
const _virtual = require("./virtual.js");
const _updateonvirtualdata = require("../components-shared/update-on-virtual-data.js");
const _useisomorphiclayouteffect = require("./use-isomorphic-layout-effect.js");
const _context = require("./context.js");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const Swiper = /*#__PURE__*/ (0, _react.forwardRef)(function(_temp, externalElRef) {
    let _ref = _temp === void 0 ? {} : _temp, { className, tag: Tag = 'div', wrapperTag: WrapperTag = 'div', children, onSwiper } = _ref, rest = _object_without_properties(_ref, [
        "className",
        "tag",
        "wrapperTag",
        "children",
        "onSwiper"
    ]);
    let eventsAssigned = false;
    const [containerClasses, setContainerClasses] = (0, _react.useState)('swiper');
    const [virtualData, setVirtualData] = (0, _react.useState)(null);
    const [breakpointChanged, setBreakpointChanged] = (0, _react.useState)(false);
    const initializedRef = (0, _react.useRef)(false);
    const swiperElRef = (0, _react.useRef)(null);
    const swiperRef = (0, _react.useRef)(null);
    const oldPassedParamsRef = (0, _react.useRef)(null);
    const oldSlides = (0, _react.useRef)(null);
    const nextElRef = (0, _react.useRef)(null);
    const prevElRef = (0, _react.useRef)(null);
    const paginationElRef = (0, _react.useRef)(null);
    const scrollbarElRef = (0, _react.useRef)(null);
    const { params: swiperParams, passedParams, rest: restProps, events } = (0, _getparams.getParams)(rest);
    const { slides, slots } = (0, _getchildren.getChildren)(children);
    const onBeforeBreakpoint = ()=>{
        setBreakpointChanged(!breakpointChanged);
    };
    Object.assign(swiperParams.on, {
        _containerClasses (swiper, classes) {
            setContainerClasses(classes);
        }
    });
    const initSwiper = ()=>{
        // init swiper
        Object.assign(swiperParams.on, events);
        eventsAssigned = true;
        const passParams = _object_spread({}, swiperParams);
        delete passParams.wrapperClass;
        swiperRef.current = new _swiper.default(passParams);
        if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
            swiperRef.current.virtual.slides = slides;
            const extendWith = {
                cache: false,
                slides,
                renderExternal: setVirtualData,
                renderExternalUpdate: false
            };
            (0, _utils.extend)(swiperRef.current.params.virtual, extendWith);
            (0, _utils.extend)(swiperRef.current.originalParams.virtual, extendWith);
        }
    };
    if (!swiperElRef.current) {
        initSwiper();
    }
    // Listen for breakpoints change
    if (swiperRef.current) {
        swiperRef.current.on('_beforeBreakpoint', onBeforeBreakpoint);
    }
    const attachEvents = ()=>{
        if (eventsAssigned || !events || !swiperRef.current) return;
        Object.keys(events).forEach((eventName)=>{
            swiperRef.current.on(eventName, events[eventName]);
        });
    };
    const detachEvents = ()=>{
        if (!events || !swiperRef.current) return;
        Object.keys(events).forEach((eventName)=>{
            swiperRef.current.off(eventName, events[eventName]);
        });
    };
    (0, _react.useEffect)(()=>{
        return ()=>{
            if (swiperRef.current) swiperRef.current.off('_beforeBreakpoint', onBeforeBreakpoint);
        };
    });
    // set initialized flag
    (0, _react.useEffect)(()=>{
        if (!initializedRef.current && swiperRef.current) {
            swiperRef.current.emitSlidesClasses();
            initializedRef.current = true;
        }
    });
    // mount swiper
    (0, _useisomorphiclayouteffect.useIsomorphicLayoutEffect)(()=>{
        if (externalElRef) {
            externalElRef.current = swiperElRef.current;
        }
        if (!swiperElRef.current) return;
        if (swiperRef.current.destroyed) {
            initSwiper();
        }
        (0, _mountswiper.mountSwiper)({
            el: swiperElRef.current,
            nextEl: nextElRef.current,
            prevEl: prevElRef.current,
            paginationEl: paginationElRef.current,
            scrollbarEl: scrollbarElRef.current,
            swiper: swiperRef.current
        }, swiperParams);
        if (onSwiper) onSwiper(swiperRef.current);
        // eslint-disable-next-line
        return ()=>{
            if (swiperRef.current && !swiperRef.current.destroyed) {
                swiperRef.current.destroy(true, false);
            }
        };
    }, []);
    // watch for params change
    (0, _useisomorphiclayouteffect.useIsomorphicLayoutEffect)(()=>{
        attachEvents();
        const changedParams = (0, _getchangedparams.getChangedParams)(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c)=>c.key);
        oldPassedParamsRef.current = passedParams;
        oldSlides.current = slides;
        if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
            (0, _updateswiper.updateSwiper)({
                swiper: swiperRef.current,
                slides,
                passedParams,
                changedParams,
                nextEl: nextElRef.current,
                prevEl: prevElRef.current,
                scrollbarEl: scrollbarElRef.current,
                paginationEl: paginationElRef.current
            });
        }
        return ()=>{
            detachEvents();
        };
    });
    // update on virtual update
    (0, _useisomorphiclayouteffect.useIsomorphicLayoutEffect)(()=>{
        (0, _updateonvirtualdata.updateOnVirtualData)(swiperRef.current);
    }, [
        virtualData
    ]);
    // bypass swiper instance to slides
    function renderSlides() {
        if (swiperParams.virtual) {
            return (0, _virtual.renderVirtual)(swiperRef.current, slides, virtualData);
        }
        return slides.map((child, index)=>{
            return /*#__PURE__*/ _react.default.cloneElement(child, {
                swiper: swiperRef.current,
                swiperSlideIndex: index
            });
        });
    }
    return /*#__PURE__*/ _react.default.createElement(Tag, _extends({
        ref: swiperElRef,
        className: (0, _utils.uniqueClasses)(`${containerClasses}${className ? ` ${className}` : ''}`)
    }, restProps), /*#__PURE__*/ _react.default.createElement(_context.SwiperContext.Provider, {
        value: swiperRef.current
    }, slots['container-start'], /*#__PURE__*/ _react.default.createElement(WrapperTag, {
        className: (0, _utils.wrapperClass)(swiperParams.wrapperClass)
    }, slots['wrapper-start'], renderSlides(), slots['wrapper-end']), (0, _utils.needsNavigation)(swiperParams) && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("div", {
        ref: prevElRef,
        className: "swiper-button-prev"
    }), /*#__PURE__*/ _react.default.createElement("div", {
        ref: nextElRef,
        className: "swiper-button-next"
    })), (0, _utils.needsScrollbar)(swiperParams) && /*#__PURE__*/ _react.default.createElement("div", {
        ref: scrollbarElRef,
        className: "swiper-scrollbar"
    }), (0, _utils.needsPagination)(swiperParams) && /*#__PURE__*/ _react.default.createElement("div", {
        ref: paginationElRef,
        className: "swiper-pagination"
    }), slots['container-end']));
});
Swiper.displayName = 'Swiper';

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9zd2lwZXIvcmVhY3Qvc3dpcGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBTd2lwZXJDb3JlIGZyb20gJ3N3aXBlcic7XG5pbXBvcnQgeyBnZXRQYXJhbXMgfSBmcm9tICcuLi9jb21wb25lbnRzLXNoYXJlZC9nZXQtcGFyYW1zLmpzJztcbmltcG9ydCB7IG1vdW50U3dpcGVyIH0gZnJvbSAnLi4vY29tcG9uZW50cy1zaGFyZWQvbW91bnQtc3dpcGVyLmpzJztcbmltcG9ydCB7IG5lZWRzU2Nyb2xsYmFyLCBuZWVkc05hdmlnYXRpb24sIG5lZWRzUGFnaW5hdGlvbiwgdW5pcXVlQ2xhc3NlcywgZXh0ZW5kLCB3cmFwcGVyQ2xhc3MgfSBmcm9tICcuLi9jb21wb25lbnRzLXNoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXRDaGFuZ2VkUGFyYW1zIH0gZnJvbSAnLi4vY29tcG9uZW50cy1zaGFyZWQvZ2V0LWNoYW5nZWQtcGFyYW1zLmpzJztcbmltcG9ydCB7IGdldENoaWxkcmVuIH0gZnJvbSAnLi9nZXQtY2hpbGRyZW4uanMnO1xuaW1wb3J0IHsgdXBkYXRlU3dpcGVyIH0gZnJvbSAnLi4vY29tcG9uZW50cy1zaGFyZWQvdXBkYXRlLXN3aXBlci5qcyc7XG5pbXBvcnQgeyByZW5kZXJWaXJ0dWFsIH0gZnJvbSAnLi92aXJ0dWFsLmpzJztcbmltcG9ydCB7IHVwZGF0ZU9uVmlydHVhbERhdGEgfSBmcm9tICcuLi9jb21wb25lbnRzLXNoYXJlZC91cGRhdGUtb24tdmlydHVhbC1kYXRhLmpzJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QuanMnO1xuaW1wb3J0IHsgU3dpcGVyQ29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5jb25zdCBTd2lwZXIgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiAoX3RlbXAsIGV4dGVybmFsRWxSZWYpIHtcbiAgbGV0IHtcbiAgICBjbGFzc05hbWUsXG4gICAgdGFnOiBUYWcgPSAnZGl2JyxcbiAgICB3cmFwcGVyVGFnOiBXcmFwcGVyVGFnID0gJ2RpdicsXG4gICAgY2hpbGRyZW4sXG4gICAgb25Td2lwZXIsXG4gICAgLi4ucmVzdFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGxldCBldmVudHNBc3NpZ25lZCA9IGZhbHNlO1xuICBjb25zdCBbY29udGFpbmVyQ2xhc3Nlcywgc2V0Q29udGFpbmVyQ2xhc3Nlc10gPSB1c2VTdGF0ZSgnc3dpcGVyJyk7XG4gIGNvbnN0IFt2aXJ0dWFsRGF0YSwgc2V0VmlydHVhbERhdGFdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFticmVha3BvaW50Q2hhbmdlZCwgc2V0QnJlYWtwb2ludENoYW5nZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBpbml0aWFsaXplZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHN3aXBlckVsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzd2lwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IG9sZFBhc3NlZFBhcmFtc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgb2xkU2xpZGVzID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBuZXh0RWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHByZXZFbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcGFnaW5hdGlvbkVsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzY3JvbGxiYXJFbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIHBhcmFtczogc3dpcGVyUGFyYW1zLFxuICAgIHBhc3NlZFBhcmFtcyxcbiAgICByZXN0OiByZXN0UHJvcHMsXG4gICAgZXZlbnRzXG4gIH0gPSBnZXRQYXJhbXMocmVzdCk7XG4gIGNvbnN0IHtcbiAgICBzbGlkZXMsXG4gICAgc2xvdHNcbiAgfSA9IGdldENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgY29uc3Qgb25CZWZvcmVCcmVha3BvaW50ID0gKCkgPT4ge1xuICAgIHNldEJyZWFrcG9pbnRDaGFuZ2VkKCFicmVha3BvaW50Q2hhbmdlZCk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyUGFyYW1zLm9uLCB7XG4gICAgX2NvbnRhaW5lckNsYXNzZXMoc3dpcGVyLCBjbGFzc2VzKSB7XG4gICAgICBzZXRDb250YWluZXJDbGFzc2VzKGNsYXNzZXMpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGluaXRTd2lwZXIgPSAoKSA9PiB7XG4gICAgLy8gaW5pdCBzd2lwZXJcbiAgICBPYmplY3QuYXNzaWduKHN3aXBlclBhcmFtcy5vbiwgZXZlbnRzKTtcbiAgICBldmVudHNBc3NpZ25lZCA9IHRydWU7XG4gICAgY29uc3QgcGFzc1BhcmFtcyA9IHtcbiAgICAgIC4uLnN3aXBlclBhcmFtc1xuICAgIH07XG4gICAgZGVsZXRlIHBhc3NQYXJhbXMud3JhcHBlckNsYXNzO1xuICAgIHN3aXBlclJlZi5jdXJyZW50ID0gbmV3IFN3aXBlckNvcmUocGFzc1BhcmFtcyk7XG4gICAgaWYgKHN3aXBlclJlZi5jdXJyZW50LnZpcnR1YWwgJiYgc3dpcGVyUmVmLmN1cnJlbnQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgc3dpcGVyUmVmLmN1cnJlbnQudmlydHVhbC5zbGlkZXMgPSBzbGlkZXM7XG4gICAgICBjb25zdCBleHRlbmRXaXRoID0ge1xuICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgIHNsaWRlcyxcbiAgICAgICAgcmVuZGVyRXh0ZXJuYWw6IHNldFZpcnR1YWxEYXRhLFxuICAgICAgICByZW5kZXJFeHRlcm5hbFVwZGF0ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBleHRlbmQoc3dpcGVyUmVmLmN1cnJlbnQucGFyYW1zLnZpcnR1YWwsIGV4dGVuZFdpdGgpO1xuICAgICAgZXh0ZW5kKHN3aXBlclJlZi5jdXJyZW50Lm9yaWdpbmFsUGFyYW1zLnZpcnR1YWwsIGV4dGVuZFdpdGgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKCFzd2lwZXJFbFJlZi5jdXJyZW50KSB7XG4gICAgaW5pdFN3aXBlcigpO1xuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBicmVha3BvaW50cyBjaGFuZ2VcbiAgaWYgKHN3aXBlclJlZi5jdXJyZW50KSB7XG4gICAgc3dpcGVyUmVmLmN1cnJlbnQub24oJ19iZWZvcmVCcmVha3BvaW50Jywgb25CZWZvcmVCcmVha3BvaW50KTtcbiAgfVxuICBjb25zdCBhdHRhY2hFdmVudHMgPSAoKSA9PiB7XG4gICAgaWYgKGV2ZW50c0Fzc2lnbmVkIHx8ICFldmVudHMgfHwgIXN3aXBlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBzd2lwZXJSZWYuY3VycmVudC5vbihldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZGV0YWNoRXZlbnRzID0gKCkgPT4ge1xuICAgIGlmICghZXZlbnRzIHx8ICFzd2lwZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgc3dpcGVyUmVmLmN1cnJlbnQub2ZmKGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgIH0pO1xuICB9O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc3dpcGVyUmVmLmN1cnJlbnQpIHN3aXBlclJlZi5jdXJyZW50Lm9mZignX2JlZm9yZUJyZWFrcG9pbnQnLCBvbkJlZm9yZUJyZWFrcG9pbnQpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHNldCBpbml0aWFsaXplZCBmbGFnXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpbml0aWFsaXplZFJlZi5jdXJyZW50ICYmIHN3aXBlclJlZi5jdXJyZW50KSB7XG4gICAgICBzd2lwZXJSZWYuY3VycmVudC5lbWl0U2xpZGVzQ2xhc3NlcygpO1xuICAgICAgaW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBtb3VudCBzd2lwZXJcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGV4dGVybmFsRWxSZWYpIHtcbiAgICAgIGV4dGVybmFsRWxSZWYuY3VycmVudCA9IHN3aXBlckVsUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmICghc3dpcGVyRWxSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGlmIChzd2lwZXJSZWYuY3VycmVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGluaXRTd2lwZXIoKTtcbiAgICB9XG4gICAgbW91bnRTd2lwZXIoe1xuICAgICAgZWw6IHN3aXBlckVsUmVmLmN1cnJlbnQsXG4gICAgICBuZXh0RWw6IG5leHRFbFJlZi5jdXJyZW50LFxuICAgICAgcHJldkVsOiBwcmV2RWxSZWYuY3VycmVudCxcbiAgICAgIHBhZ2luYXRpb25FbDogcGFnaW5hdGlvbkVsUmVmLmN1cnJlbnQsXG4gICAgICBzY3JvbGxiYXJFbDogc2Nyb2xsYmFyRWxSZWYuY3VycmVudCxcbiAgICAgIHN3aXBlcjogc3dpcGVyUmVmLmN1cnJlbnRcbiAgICB9LCBzd2lwZXJQYXJhbXMpO1xuICAgIGlmIChvblN3aXBlcikgb25Td2lwZXIoc3dpcGVyUmVmLmN1cnJlbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc3dpcGVyUmVmLmN1cnJlbnQgJiYgIXN3aXBlclJlZi5jdXJyZW50LmRlc3Ryb3llZCkge1xuICAgICAgICBzd2lwZXJSZWYuY3VycmVudC5kZXN0cm95KHRydWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gd2F0Y2ggZm9yIHBhcmFtcyBjaGFuZ2VcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYXR0YWNoRXZlbnRzKCk7XG4gICAgY29uc3QgY2hhbmdlZFBhcmFtcyA9IGdldENoYW5nZWRQYXJhbXMocGFzc2VkUGFyYW1zLCBvbGRQYXNzZWRQYXJhbXNSZWYuY3VycmVudCwgc2xpZGVzLCBvbGRTbGlkZXMuY3VycmVudCwgYyA9PiBjLmtleSk7XG4gICAgb2xkUGFzc2VkUGFyYW1zUmVmLmN1cnJlbnQgPSBwYXNzZWRQYXJhbXM7XG4gICAgb2xkU2xpZGVzLmN1cnJlbnQgPSBzbGlkZXM7XG4gICAgaWYgKGNoYW5nZWRQYXJhbXMubGVuZ3RoICYmIHN3aXBlclJlZi5jdXJyZW50ICYmICFzd2lwZXJSZWYuY3VycmVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHVwZGF0ZVN3aXBlcih7XG4gICAgICAgIHN3aXBlcjogc3dpcGVyUmVmLmN1cnJlbnQsXG4gICAgICAgIHNsaWRlcyxcbiAgICAgICAgcGFzc2VkUGFyYW1zLFxuICAgICAgICBjaGFuZ2VkUGFyYW1zLFxuICAgICAgICBuZXh0RWw6IG5leHRFbFJlZi5jdXJyZW50LFxuICAgICAgICBwcmV2RWw6IHByZXZFbFJlZi5jdXJyZW50LFxuICAgICAgICBzY3JvbGxiYXJFbDogc2Nyb2xsYmFyRWxSZWYuY3VycmVudCxcbiAgICAgICAgcGFnaW5hdGlvbkVsOiBwYWdpbmF0aW9uRWxSZWYuY3VycmVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZXRhY2hFdmVudHMoKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyB1cGRhdGUgb24gdmlydHVhbCB1cGRhdGVcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdXBkYXRlT25WaXJ0dWFsRGF0YShzd2lwZXJSZWYuY3VycmVudCk7XG4gIH0sIFt2aXJ0dWFsRGF0YV0pO1xuXG4gIC8vIGJ5cGFzcyBzd2lwZXIgaW5zdGFuY2UgdG8gc2xpZGVzXG4gIGZ1bmN0aW9uIHJlbmRlclNsaWRlcygpIHtcbiAgICBpZiAoc3dpcGVyUGFyYW1zLnZpcnR1YWwpIHtcbiAgICAgIHJldHVybiByZW5kZXJWaXJ0dWFsKHN3aXBlclJlZi5jdXJyZW50LCBzbGlkZXMsIHZpcnR1YWxEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWRlcy5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgc3dpcGVyOiBzd2lwZXJSZWYuY3VycmVudCxcbiAgICAgICAgc3dpcGVyU2xpZGVJbmRleDogaW5kZXhcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHtcbiAgICByZWY6IHN3aXBlckVsUmVmLFxuICAgIGNsYXNzTmFtZTogdW5pcXVlQ2xhc3NlcyhgJHtjb250YWluZXJDbGFzc2VzfSR7Y2xhc3NOYW1lID8gYCAke2NsYXNzTmFtZX1gIDogJyd9YClcbiAgfSwgcmVzdFByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3dpcGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzd2lwZXJSZWYuY3VycmVudFxuICB9LCBzbG90c1snY29udGFpbmVyLXN0YXJ0J10sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXJUYWcsIHtcbiAgICBjbGFzc05hbWU6IHdyYXBwZXJDbGFzcyhzd2lwZXJQYXJhbXMud3JhcHBlckNsYXNzKVxuICB9LCBzbG90c1snd3JhcHBlci1zdGFydCddLCByZW5kZXJTbGlkZXMoKSwgc2xvdHNbJ3dyYXBwZXItZW5kJ10pLCBuZWVkc05hdmlnYXRpb24oc3dpcGVyUGFyYW1zKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogcHJldkVsUmVmLFxuICAgIGNsYXNzTmFtZTogXCJzd2lwZXItYnV0dG9uLXByZXZcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogbmV4dEVsUmVmLFxuICAgIGNsYXNzTmFtZTogXCJzd2lwZXItYnV0dG9uLW5leHRcIlxuICB9KSksIG5lZWRzU2Nyb2xsYmFyKHN3aXBlclBhcmFtcykgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogc2Nyb2xsYmFyRWxSZWYsXG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1zY3JvbGxiYXJcIlxuICB9KSwgbmVlZHNQYWdpbmF0aW9uKHN3aXBlclBhcmFtcykgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogcGFnaW5hdGlvbkVsUmVmLFxuICAgIGNsYXNzTmFtZTogXCJzd2lwZXItcGFnaW5hdGlvblwiXG4gIH0pLCBzbG90c1snY29udGFpbmVyLWVuZCddKSk7XG59KTtcblN3aXBlci5kaXNwbGF5TmFtZSA9ICdTd2lwZXInO1xuZXhwb3J0IHsgU3dpcGVyIH07Il0sIm5hbWVzIjpbIlN3aXBlciIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsImZvcndhcmRSZWYiLCJfdGVtcCIsImV4dGVybmFsRWxSZWYiLCJjbGFzc05hbWUiLCJ0YWciLCJUYWciLCJ3cmFwcGVyVGFnIiwiV3JhcHBlclRhZyIsImNoaWxkcmVuIiwib25Td2lwZXIiLCJyZXN0IiwiZXZlbnRzQXNzaWduZWQiLCJjb250YWluZXJDbGFzc2VzIiwic2V0Q29udGFpbmVyQ2xhc3NlcyIsInVzZVN0YXRlIiwidmlydHVhbERhdGEiLCJzZXRWaXJ0dWFsRGF0YSIsImJyZWFrcG9pbnRDaGFuZ2VkIiwic2V0QnJlYWtwb2ludENoYW5nZWQiLCJpbml0aWFsaXplZFJlZiIsInVzZVJlZiIsInN3aXBlckVsUmVmIiwic3dpcGVyUmVmIiwib2xkUGFzc2VkUGFyYW1zUmVmIiwib2xkU2xpZGVzIiwibmV4dEVsUmVmIiwicHJldkVsUmVmIiwicGFnaW5hdGlvbkVsUmVmIiwic2Nyb2xsYmFyRWxSZWYiLCJwYXJhbXMiLCJzd2lwZXJQYXJhbXMiLCJwYXNzZWRQYXJhbXMiLCJyZXN0UHJvcHMiLCJldmVudHMiLCJnZXRQYXJhbXMiLCJzbGlkZXMiLCJzbG90cyIsImdldENoaWxkcmVuIiwib25CZWZvcmVCcmVha3BvaW50Iiwib24iLCJfY29udGFpbmVyQ2xhc3NlcyIsInN3aXBlciIsImNsYXNzZXMiLCJpbml0U3dpcGVyIiwicGFzc1BhcmFtcyIsIndyYXBwZXJDbGFzcyIsImN1cnJlbnQiLCJTd2lwZXJDb3JlIiwidmlydHVhbCIsImVuYWJsZWQiLCJleHRlbmRXaXRoIiwiY2FjaGUiLCJyZW5kZXJFeHRlcm5hbCIsInJlbmRlckV4dGVybmFsVXBkYXRlIiwiZXh0ZW5kIiwib3JpZ2luYWxQYXJhbXMiLCJhdHRhY2hFdmVudHMiLCJrZXlzIiwiZm9yRWFjaCIsImV2ZW50TmFtZSIsImRldGFjaEV2ZW50cyIsIm9mZiIsInVzZUVmZmVjdCIsImVtaXRTbGlkZXNDbGFzc2VzIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImRlc3Ryb3llZCIsIm1vdW50U3dpcGVyIiwiZWwiLCJuZXh0RWwiLCJwcmV2RWwiLCJwYWdpbmF0aW9uRWwiLCJzY3JvbGxiYXJFbCIsImRlc3Ryb3kiLCJjaGFuZ2VkUGFyYW1zIiwiZ2V0Q2hhbmdlZFBhcmFtcyIsImMiLCJ1cGRhdGVTd2lwZXIiLCJ1cGRhdGVPblZpcnR1YWxEYXRhIiwicmVuZGVyU2xpZGVzIiwicmVuZGVyVmlydHVhbCIsIm1hcCIsImNoaWxkIiwiaW5kZXgiLCJSZWFjdCIsImNsb25lRWxlbWVudCIsInN3aXBlclNsaWRlSW5kZXgiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwidW5pcXVlQ2xhc3NlcyIsIlN3aXBlckNvbnRleHQiLCJQcm92aWRlciIsInZhbHVlIiwibmVlZHNOYXZpZ2F0aW9uIiwiRnJhZ21lbnQiLCJuZWVkc1Njcm9sbGJhciIsIm5lZWRzUGFnaW5hdGlvbiIsImRpc3BsYXlOYW1lIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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