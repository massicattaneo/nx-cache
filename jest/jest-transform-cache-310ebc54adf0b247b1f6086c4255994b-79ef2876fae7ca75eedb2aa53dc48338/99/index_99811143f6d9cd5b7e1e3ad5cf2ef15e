e98d1ab5d4aa8e3de430df6967649afd
/**
 * @typedef Options
 *   Configuration (optional).
 * @property {string|null|ReadonlyArray<string|null|undefined>} [align]
 *   One style for all columns, or styles for their respective columns.
 *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).
 *   Other values are treated as `''`, which doesn‚Äôt place the colon in the
 *   alignment row but does align left.
 *   *Only the lowercased first character is used, so `Right` is fine.*
 * @property {boolean} [padding=true]
 *   Whether to add a space of padding between delimiters and cells.
 *
 *   When `true`, there is padding:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there is no padding:
 *
 *   ```markdown
 *   |Alpha|B    |
 *   |-----|-----|
 *   |C    |Delta|
 *   ```
 * @property {boolean} [delimiterStart=true]
 *   Whether to begin each row with the delimiter.
 *
 *   > üëâ **Note**: please don‚Äôt use this: it could create fragile structures
 *   > that aren‚Äôt understandable to some markdown parsers.
 *
 *   When `true`, there are starting delimiters:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there are no starting delimiters:
 *
 *   ```markdown
 *   Alpha | B     |
 *   ----- | ----- |
 *   C     | Delta |
 *   ```
 * @property {boolean} [delimiterEnd=true]
 *   Whether to end each row with the delimiter.
 *
 *   > üëâ **Note**: please don‚Äôt use this: it could create fragile structures
 *   > that aren‚Äôt understandable to some markdown parsers.
 *
 *   When `true`, there are ending delimiters:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there are no ending delimiters:
 *
 *   ```markdown
 *   | Alpha | B
 *   | ----- | -----
 *   | C     | Delta
 *   ```
 * @property {boolean} [alignDelimiters=true]
 *   Whether to align the delimiters.
 *   By default, they are aligned:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   Pass `false` to make them staggered:
 *
 *   ```markdown
 *   | Alpha | B |
 *   | - | - |
 *   | C | Delta |
 *   ```
 * @property {(value: string) => number} [stringLength]
 *   Function to detect the length of table cell content.
 *   This is used when aligning the delimiters (`|`) between table cells.
 *   Full-width characters and emoji mess up delimiter alignment when viewing
 *   the markdown source.
 *   To fix this, you can pass this function, which receives the cell content
 *   and returns its ‚Äúvisible‚Äù size.
 *   Note that what is and isn‚Äôt visible depends on where the text is displayed.
 *
 *   Without such a function, the following:
 *
 *   ```js
 *   markdownTable([
 *     ['Alpha', 'Bravo'],
 *     ['‰∏≠Êñá', 'Charlie'],
 *     ['üë©‚Äç‚ù§Ô∏è‚Äçüë©', 'Delta']
 *   ])
 *   ```
 *
 *   Yields:
 *
 *   ```markdown
 *   | Alpha | Bravo |
 *   | - | - |
 *   | ‰∏≠Êñá | Charlie |
 *   | üë©‚Äç‚ù§Ô∏è‚Äçüë© | Delta |
 *   ```
 *
 *   With [`string-width`](https://github.com/sindresorhus/string-width):
 *
 *   ```js
 *   import stringWidth from 'string-width'
 *
 *   markdownTable(
 *     [
 *       ['Alpha', 'Bravo'],
 *       ['‰∏≠Êñá', 'Charlie'],
 *       ['üë©‚Äç‚ù§Ô∏è‚Äçüë©', 'Delta']
 *     ],
 *     {stringLength: stringWidth}
 *   )
 *   ```
 *
 *   Yields:
 *
 *   ```markdown
 *   | Alpha | Bravo   |
 *   | ----- | ------- |
 *   | ‰∏≠Êñá  | Charlie |
 *   | üë©‚Äç‚ù§Ô∏è‚Äçüë©    | Delta   |
 *   ```
 */ /**
 * @typedef {Options} MarkdownTableOptions
 * @todo
 *   Remove next major.
 */ /**
 * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..
 *
 * @param {ReadonlyArray<ReadonlyArray<string|null|undefined>>} table
 *   Table data (matrix of strings).
 * @param {Options} [options]
 *   Configuration (optional).
 * @returns {string}
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "markdownTable", {
    enumerable: true,
    get: function() {
        return markdownTable;
    }
});
function markdownTable(table, options = {}) {
    const align = (options.align || []).concat();
    const stringLength = options.stringLength || defaultStringLength;
    /** @type {Array<number>} Character codes as symbols for alignment per column. */ const alignments = [];
    /** @type {Array<Array<string>>} Cells per row. */ const cellMatrix = [];
    /** @type {Array<Array<number>>} Sizes of each cell per row. */ const sizeMatrix = [];
    /** @type {Array<number>} */ const longestCellByColumn = [];
    let mostCellsPerRow = 0;
    let rowIndex = -1;
    // This is a superfluous loop if we don‚Äôt align delimiters, but otherwise we‚Äôd
    // do superfluous work when aligning, so optimize for aligning.
    while(++rowIndex < table.length){
        /** @type {Array<string>} */ const row = [];
        /** @type {Array<number>} */ const sizes = [];
        let columnIndex = -1;
        if (table[rowIndex].length > mostCellsPerRow) {
            mostCellsPerRow = table[rowIndex].length;
        }
        while(++columnIndex < table[rowIndex].length){
            const cell = serialize(table[rowIndex][columnIndex]);
            if (options.alignDelimiters !== false) {
                const size = stringLength(cell);
                sizes[columnIndex] = size;
                if (longestCellByColumn[columnIndex] === undefined || size > longestCellByColumn[columnIndex]) {
                    longestCellByColumn[columnIndex] = size;
                }
            }
            row.push(cell);
        }
        cellMatrix[rowIndex] = row;
        sizeMatrix[rowIndex] = sizes;
    }
    // Figure out which alignments to use.
    let columnIndex = -1;
    if (typeof align === 'object' && 'length' in align) {
        while(++columnIndex < mostCellsPerRow){
            alignments[columnIndex] = toAlignment(align[columnIndex]);
        }
    } else {
        const code = toAlignment(align);
        while(++columnIndex < mostCellsPerRow){
            alignments[columnIndex] = code;
        }
    }
    // Inject the alignment row.
    columnIndex = -1;
    /** @type {Array<string>} */ const row = [];
    /** @type {Array<number>} */ const sizes = [];
    while(++columnIndex < mostCellsPerRow){
        const code = alignments[columnIndex];
        let before = '';
        let after = '';
        if (code === 99 /* `c` */ ) {
            before = ':';
            after = ':';
        } else if (code === 108 /* `l` */ ) {
            before = ':';
        } else if (code === 114 /* `r` */ ) {
            after = ':';
        }
        // There *must* be at least one hyphen-minus in each alignment cell.
        let size = options.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);
        const cell = before + '-'.repeat(size) + after;
        if (options.alignDelimiters !== false) {
            size = before.length + size + after.length;
            if (size > longestCellByColumn[columnIndex]) {
                longestCellByColumn[columnIndex] = size;
            }
            sizes[columnIndex] = size;
        }
        row[columnIndex] = cell;
    }
    // Inject the alignment row.
    cellMatrix.splice(1, 0, row);
    sizeMatrix.splice(1, 0, sizes);
    rowIndex = -1;
    /** @type {Array<string>} */ const lines = [];
    while(++rowIndex < cellMatrix.length){
        const row = cellMatrix[rowIndex];
        const sizes = sizeMatrix[rowIndex];
        columnIndex = -1;
        /** @type {Array<string>} */ const line = [];
        while(++columnIndex < mostCellsPerRow){
            const cell = row[columnIndex] || '';
            let before = '';
            let after = '';
            if (options.alignDelimiters !== false) {
                const size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
                const code = alignments[columnIndex];
                if (code === 114 /* `r` */ ) {
                    before = ' '.repeat(size);
                } else if (code === 99 /* `c` */ ) {
                    if (size % 2) {
                        before = ' '.repeat(size / 2 + 0.5);
                        after = ' '.repeat(size / 2 - 0.5);
                    } else {
                        before = ' '.repeat(size / 2);
                        after = before;
                    }
                } else {
                    after = ' '.repeat(size);
                }
            }
            if (options.delimiterStart !== false && !columnIndex) {
                line.push('|');
            }
            if (options.padding !== false && // Don‚Äôt add the opening space if we‚Äôre not aligning and the cell is
            // empty: there will be a closing space.
            !(options.alignDelimiters === false && cell === '') && (options.delimiterStart !== false || columnIndex)) {
                line.push(' ');
            }
            if (options.alignDelimiters !== false) {
                line.push(before);
            }
            line.push(cell);
            if (options.alignDelimiters !== false) {
                line.push(after);
            }
            if (options.padding !== false) {
                line.push(' ');
            }
            if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
                line.push('|');
            }
        }
        lines.push(options.delimiterEnd === false ? line.join('').replace(/ +$/, '') : line.join(''));
    }
    return lines.join('\n');
}
/**
 * @param {string|null|undefined} [value]
 * @returns {string}
 */ function serialize(value) {
    return value === null || value === undefined ? '' : String(value);
}
/**
 * @param {string} value
 * @returns {number}
 */ function defaultStringLength(value) {
    return value.length;
}
/**
 * @param {string|null|undefined} value
 * @returns {number}
 */ function toAlignment(value) {
    const code = typeof value === 'string' ? value.codePointAt(0) : 0;
    return code === 67 /* `C` */  || code === 99 /* `c` */  ? 99 /* `c` */  : code === 76 /* `L` */  || code === 108 /* `l` */  ? 108 /* `l` */  : code === 82 /* `R` */  || code === 114 /* `r` */  ? 114 /* `r` */  : 0;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9tYXJrZG93bi10YWJsZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbHxSZWFkb25seUFycmF5PHN0cmluZ3xudWxsfHVuZGVmaW5lZD59IFthbGlnbl1cbiAqICAgT25lIHN0eWxlIGZvciBhbGwgY29sdW1ucywgb3Igc3R5bGVzIGZvciB0aGVpciByZXNwZWN0aXZlIGNvbHVtbnMuXG4gKiAgIEVhY2ggc3R5bGUgaXMgZWl0aGVyIGAnbCdgIChsZWZ0KSwgYCdyJ2AgKHJpZ2h0KSwgb3IgYCdjJ2AgKGNlbnRlcikuXG4gKiAgIE90aGVyIHZhbHVlcyBhcmUgdHJlYXRlZCBhcyBgJydgLCB3aGljaCBkb2VzbuKAmXQgcGxhY2UgdGhlIGNvbG9uIGluIHRoZVxuICogICBhbGlnbm1lbnQgcm93IGJ1dCBkb2VzIGFsaWduIGxlZnQuXG4gKiAgICpPbmx5IHRoZSBsb3dlcmNhc2VkIGZpcnN0IGNoYXJhY3RlciBpcyB1c2VkLCBzbyBgUmlnaHRgIGlzIGZpbmUuKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcGFkZGluZz10cnVlXVxuICogICBXaGV0aGVyIHRvIGFkZCBhIHNwYWNlIG9mIHBhZGRpbmcgYmV0d2VlbiBkZWxpbWl0ZXJzIGFuZCBjZWxscy5cbiAqXG4gKiAgIFdoZW4gYHRydWVgLCB0aGVyZSBpcyBwYWRkaW5nOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgfCBBbHBoYSB8IEIgICAgIHxcbiAqICAgfCAtLS0tLSB8IC0tLS0tIHxcbiAqICAgfCBDICAgICB8IERlbHRhIHxcbiAqICAgYGBgXG4gKlxuICogICBXaGVuIGBmYWxzZWAsIHRoZXJlIGlzIG5vIHBhZGRpbmc6XG4gKlxuICogICBgYGBtYXJrZG93blxuICogICB8QWxwaGF8QiAgICB8XG4gKiAgIHwtLS0tLXwtLS0tLXxcbiAqICAgfEMgICAgfERlbHRhfFxuICogICBgYGBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlbGltaXRlclN0YXJ0PXRydWVdXG4gKiAgIFdoZXRoZXIgdG8gYmVnaW4gZWFjaCByb3cgd2l0aCB0aGUgZGVsaW1pdGVyLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBwbGVhc2UgZG9u4oCZdCB1c2UgdGhpczogaXQgY291bGQgY3JlYXRlIGZyYWdpbGUgc3RydWN0dXJlc1xuICogICA+IHRoYXQgYXJlbuKAmXQgdW5kZXJzdGFuZGFibGUgdG8gc29tZSBtYXJrZG93biBwYXJzZXJzLlxuICpcbiAqICAgV2hlbiBgdHJ1ZWAsIHRoZXJlIGFyZSBzdGFydGluZyBkZWxpbWl0ZXJzOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgfCBBbHBoYSB8IEIgICAgIHxcbiAqICAgfCAtLS0tLSB8IC0tLS0tIHxcbiAqICAgfCBDICAgICB8IERlbHRhIHxcbiAqICAgYGBgXG4gKlxuICogICBXaGVuIGBmYWxzZWAsIHRoZXJlIGFyZSBubyBzdGFydGluZyBkZWxpbWl0ZXJzOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgQWxwaGEgfCBCICAgICB8XG4gKiAgIC0tLS0tIHwgLS0tLS0gfFxuICogICBDICAgICB8IERlbHRhIHxcbiAqICAgYGBgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWxpbWl0ZXJFbmQ9dHJ1ZV1cbiAqICAgV2hldGhlciB0byBlbmQgZWFjaCByb3cgd2l0aCB0aGUgZGVsaW1pdGVyLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBwbGVhc2UgZG9u4oCZdCB1c2UgdGhpczogaXQgY291bGQgY3JlYXRlIGZyYWdpbGUgc3RydWN0dXJlc1xuICogICA+IHRoYXQgYXJlbuKAmXQgdW5kZXJzdGFuZGFibGUgdG8gc29tZSBtYXJrZG93biBwYXJzZXJzLlxuICpcbiAqICAgV2hlbiBgdHJ1ZWAsIHRoZXJlIGFyZSBlbmRpbmcgZGVsaW1pdGVyczpcbiAqXG4gKiAgIGBgYG1hcmtkb3duXG4gKiAgIHwgQWxwaGEgfCBCICAgICB8XG4gKiAgIHwgLS0tLS0gfCAtLS0tLSB8XG4gKiAgIHwgQyAgICAgfCBEZWx0YSB8XG4gKiAgIGBgYFxuICpcbiAqICAgV2hlbiBgZmFsc2VgLCB0aGVyZSBhcmUgbm8gZW5kaW5nIGRlbGltaXRlcnM6XG4gKlxuICogICBgYGBtYXJrZG93blxuICogICB8IEFscGhhIHwgQlxuICogICB8IC0tLS0tIHwgLS0tLS1cbiAqICAgfCBDICAgICB8IERlbHRhXG4gKiAgIGBgYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWxpZ25EZWxpbWl0ZXJzPXRydWVdXG4gKiAgIFdoZXRoZXIgdG8gYWxpZ24gdGhlIGRlbGltaXRlcnMuXG4gKiAgIEJ5IGRlZmF1bHQsIHRoZXkgYXJlIGFsaWduZWQ6XG4gKlxuICogICBgYGBtYXJrZG93blxuICogICB8IEFscGhhIHwgQiAgICAgfFxuICogICB8IC0tLS0tIHwgLS0tLS0gfFxuICogICB8IEMgICAgIHwgRGVsdGEgfFxuICogICBgYGBcbiAqXG4gKiAgIFBhc3MgYGZhbHNlYCB0byBtYWtlIHRoZW0gc3RhZ2dlcmVkOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgfCBBbHBoYSB8IEIgfFxuICogICB8IC0gfCAtIHxcbiAqICAgfCBDIHwgRGVsdGEgfFxuICogICBgYGBcbiAqIEBwcm9wZXJ0eSB7KHZhbHVlOiBzdHJpbmcpID0+IG51bWJlcn0gW3N0cmluZ0xlbmd0aF1cbiAqICAgRnVuY3Rpb24gdG8gZGV0ZWN0IHRoZSBsZW5ndGggb2YgdGFibGUgY2VsbCBjb250ZW50LlxuICogICBUaGlzIGlzIHVzZWQgd2hlbiBhbGlnbmluZyB0aGUgZGVsaW1pdGVycyAoYHxgKSBiZXR3ZWVuIHRhYmxlIGNlbGxzLlxuICogICBGdWxsLXdpZHRoIGNoYXJhY3RlcnMgYW5kIGVtb2ppIG1lc3MgdXAgZGVsaW1pdGVyIGFsaWdubWVudCB3aGVuIHZpZXdpbmdcbiAqICAgdGhlIG1hcmtkb3duIHNvdXJjZS5cbiAqICAgVG8gZml4IHRoaXMsIHlvdSBjYW4gcGFzcyB0aGlzIGZ1bmN0aW9uLCB3aGljaCByZWNlaXZlcyB0aGUgY2VsbCBjb250ZW50XG4gKiAgIGFuZCByZXR1cm5zIGl0cyDigJx2aXNpYmxl4oCdIHNpemUuXG4gKiAgIE5vdGUgdGhhdCB3aGF0IGlzIGFuZCBpc27igJl0IHZpc2libGUgZGVwZW5kcyBvbiB3aGVyZSB0aGUgdGV4dCBpcyBkaXNwbGF5ZWQuXG4gKlxuICogICBXaXRob3V0IHN1Y2ggYSBmdW5jdGlvbiwgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgIGBgYGpzXG4gKiAgIG1hcmtkb3duVGFibGUoW1xuICogICAgIFsnQWxwaGEnLCAnQnJhdm8nXSxcbiAqICAgICBbJ+S4reaWhycsICdDaGFybGllJ10sXG4gKiAgICAgWyfwn5Gp4oCN4p2k77iP4oCN8J+RqScsICdEZWx0YSddXG4gKiAgIF0pXG4gKiAgIGBgYFxuICpcbiAqICAgWWllbGRzOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgfCBBbHBoYSB8IEJyYXZvIHxcbiAqICAgfCAtIHwgLSB8XG4gKiAgIHwg5Lit5paHIHwgQ2hhcmxpZSB8XG4gKiAgIHwg8J+RqeKAjeKdpO+4j+KAjfCfkakgfCBEZWx0YSB8XG4gKiAgIGBgYFxuICpcbiAqICAgV2l0aCBbYHN0cmluZy13aWR0aGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc3RyaW5nLXdpZHRoKTpcbiAqXG4gKiAgIGBgYGpzXG4gKiAgIGltcG9ydCBzdHJpbmdXaWR0aCBmcm9tICdzdHJpbmctd2lkdGgnXG4gKlxuICogICBtYXJrZG93blRhYmxlKFxuICogICAgIFtcbiAqICAgICAgIFsnQWxwaGEnLCAnQnJhdm8nXSxcbiAqICAgICAgIFsn5Lit5paHJywgJ0NoYXJsaWUnXSxcbiAqICAgICAgIFsn8J+RqeKAjeKdpO+4j+KAjfCfkaknLCAnRGVsdGEnXVxuICogICAgIF0sXG4gKiAgICAge3N0cmluZ0xlbmd0aDogc3RyaW5nV2lkdGh9XG4gKiAgIClcbiAqICAgYGBgXG4gKlxuICogICBZaWVsZHM6XG4gKlxuICogICBgYGBtYXJrZG93blxuICogICB8IEFscGhhIHwgQnJhdm8gICB8XG4gKiAgIHwgLS0tLS0gfCAtLS0tLS0tIHxcbiAqICAgfCDkuK3mlocgIHwgQ2hhcmxpZSB8XG4gKiAgIHwg8J+RqeKAjeKdpO+4j+KAjfCfkakgICAgfCBEZWx0YSAgIHxcbiAqICAgYGBgXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T3B0aW9uc30gTWFya2Rvd25UYWJsZU9wdGlvbnNcbiAqIEB0b2RvXG4gKiAgIFJlbW92ZSBuZXh0IG1ham9yLlxuICovXG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXJrZG93biAoW0dGTV0oaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vZ2l0aHViL3dyaXRpbmctb24tZ2l0aHViL3dvcmtpbmctd2l0aC1hZHZhbmNlZC1mb3JtYXR0aW5nL29yZ2FuaXppbmctaW5mb3JtYXRpb24td2l0aC10YWJsZXMpKSB0YWJsZS4uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seUFycmF5PFJlYWRvbmx5QXJyYXk8c3RyaW5nfG51bGx8dW5kZWZpbmVkPj59IHRhYmxlXG4gKiAgIFRhYmxlIGRhdGEgKG1hdHJpeCBvZiBzdHJpbmdzKS5cbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrZG93blRhYmxlKHRhYmxlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgYWxpZ24gPSAob3B0aW9ucy5hbGlnbiB8fCBbXSkuY29uY2F0KClcbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gb3B0aW9ucy5zdHJpbmdMZW5ndGggfHwgZGVmYXVsdFN0cmluZ0xlbmd0aFxuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59IENoYXJhY3RlciBjb2RlcyBhcyBzeW1ib2xzIGZvciBhbGlnbm1lbnQgcGVyIGNvbHVtbi4gKi9cbiAgY29uc3QgYWxpZ25tZW50cyA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8c3RyaW5nPj59IENlbGxzIHBlciByb3cuICovXG4gIGNvbnN0IGNlbGxNYXRyaXggPSBbXVxuICAvKiogQHR5cGUge0FycmF5PEFycmF5PG51bWJlcj4+fSBTaXplcyBvZiBlYWNoIGNlbGwgcGVyIHJvdy4gKi9cbiAgY29uc3Qgc2l6ZU1hdHJpeCA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgbG9uZ2VzdENlbGxCeUNvbHVtbiA9IFtdXG4gIGxldCBtb3N0Q2VsbHNQZXJSb3cgPSAwXG4gIGxldCByb3dJbmRleCA9IC0xXG5cbiAgLy8gVGhpcyBpcyBhIHN1cGVyZmx1b3VzIGxvb3AgaWYgd2UgZG9u4oCZdCBhbGlnbiBkZWxpbWl0ZXJzLCBidXQgb3RoZXJ3aXNlIHdl4oCZZFxuICAvLyBkbyBzdXBlcmZsdW91cyB3b3JrIHdoZW4gYWxpZ25pbmcsIHNvIG9wdGltaXplIGZvciBhbGlnbmluZy5cbiAgd2hpbGUgKCsrcm93SW5kZXggPCB0YWJsZS5sZW5ndGgpIHtcbiAgICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gICAgY29uc3Qgcm93ID0gW11cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3Qgc2l6ZXMgPSBbXVxuICAgIGxldCBjb2x1bW5JbmRleCA9IC0xXG5cbiAgICBpZiAodGFibGVbcm93SW5kZXhdLmxlbmd0aCA+IG1vc3RDZWxsc1BlclJvdykge1xuICAgICAgbW9zdENlbGxzUGVyUm93ID0gdGFibGVbcm93SW5kZXhdLmxlbmd0aFxuICAgIH1cblxuICAgIHdoaWxlICgrK2NvbHVtbkluZGV4IDwgdGFibGVbcm93SW5kZXhdLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2VsbCA9IHNlcmlhbGl6ZSh0YWJsZVtyb3dJbmRleF1bY29sdW1uSW5kZXhdKVxuXG4gICAgICBpZiAob3B0aW9ucy5hbGlnbkRlbGltaXRlcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBzdHJpbmdMZW5ndGgoY2VsbClcbiAgICAgICAgc2l6ZXNbY29sdW1uSW5kZXhdID0gc2l6ZVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgc2l6ZSA+IGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdXG4gICAgICAgICkge1xuICAgICAgICAgIGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdID0gc2l6ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJvdy5wdXNoKGNlbGwpXG4gICAgfVxuXG4gICAgY2VsbE1hdHJpeFtyb3dJbmRleF0gPSByb3dcbiAgICBzaXplTWF0cml4W3Jvd0luZGV4XSA9IHNpemVzXG4gIH1cblxuICAvLyBGaWd1cmUgb3V0IHdoaWNoIGFsaWdubWVudHMgdG8gdXNlLlxuICBsZXQgY29sdW1uSW5kZXggPSAtMVxuXG4gIGlmICh0eXBlb2YgYWxpZ24gPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFsaWduKSB7XG4gICAgd2hpbGUgKCsrY29sdW1uSW5kZXggPCBtb3N0Q2VsbHNQZXJSb3cpIHtcbiAgICAgIGFsaWdubWVudHNbY29sdW1uSW5kZXhdID0gdG9BbGlnbm1lbnQoYWxpZ25bY29sdW1uSW5kZXhdKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb2RlID0gdG9BbGlnbm1lbnQoYWxpZ24pXG5cbiAgICB3aGlsZSAoKytjb2x1bW5JbmRleCA8IG1vc3RDZWxsc1BlclJvdykge1xuICAgICAgYWxpZ25tZW50c1tjb2x1bW5JbmRleF0gPSBjb2RlXG4gICAgfVxuICB9XG5cbiAgLy8gSW5qZWN0IHRoZSBhbGlnbm1lbnQgcm93LlxuICBjb2x1bW5JbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3Qgcm93ID0gW11cbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBjb25zdCBzaXplcyA9IFtdXG5cbiAgd2hpbGUgKCsrY29sdW1uSW5kZXggPCBtb3N0Q2VsbHNQZXJSb3cpIHtcbiAgICBjb25zdCBjb2RlID0gYWxpZ25tZW50c1tjb2x1bW5JbmRleF1cbiAgICBsZXQgYmVmb3JlID0gJydcbiAgICBsZXQgYWZ0ZXIgPSAnJ1xuXG4gICAgaWYgKGNvZGUgPT09IDk5IC8qIGBjYCAqLykge1xuICAgICAgYmVmb3JlID0gJzonXG4gICAgICBhZnRlciA9ICc6J1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMTA4IC8qIGBsYCAqLykge1xuICAgICAgYmVmb3JlID0gJzonXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAxMTQgLyogYHJgICovKSB7XG4gICAgICBhZnRlciA9ICc6J1xuICAgIH1cblxuICAgIC8vIFRoZXJlICptdXN0KiBiZSBhdCBsZWFzdCBvbmUgaHlwaGVuLW1pbnVzIGluIGVhY2ggYWxpZ25tZW50IGNlbGwuXG4gICAgbGV0IHNpemUgPVxuICAgICAgb3B0aW9ucy5hbGlnbkRlbGltaXRlcnMgPT09IGZhbHNlXG4gICAgICAgID8gMVxuICAgICAgICA6IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdIC0gYmVmb3JlLmxlbmd0aCAtIGFmdGVyLmxlbmd0aFxuICAgICAgICAgIClcblxuICAgIGNvbnN0IGNlbGwgPSBiZWZvcmUgKyAnLScucmVwZWF0KHNpemUpICsgYWZ0ZXJcblxuICAgIGlmIChvcHRpb25zLmFsaWduRGVsaW1pdGVycyAhPT0gZmFsc2UpIHtcbiAgICAgIHNpemUgPSBiZWZvcmUubGVuZ3RoICsgc2l6ZSArIGFmdGVyLmxlbmd0aFxuXG4gICAgICBpZiAoc2l6ZSA+IGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdKSB7XG4gICAgICAgIGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdID0gc2l6ZVxuICAgICAgfVxuXG4gICAgICBzaXplc1tjb2x1bW5JbmRleF0gPSBzaXplXG4gICAgfVxuXG4gICAgcm93W2NvbHVtbkluZGV4XSA9IGNlbGxcbiAgfVxuXG4gIC8vIEluamVjdCB0aGUgYWxpZ25tZW50IHJvdy5cbiAgY2VsbE1hdHJpeC5zcGxpY2UoMSwgMCwgcm93KVxuICBzaXplTWF0cml4LnNwbGljZSgxLCAwLCBzaXplcylcblxuICByb3dJbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgbGluZXMgPSBbXVxuXG4gIHdoaWxlICgrK3Jvd0luZGV4IDwgY2VsbE1hdHJpeC5sZW5ndGgpIHtcbiAgICBjb25zdCByb3cgPSBjZWxsTWF0cml4W3Jvd0luZGV4XVxuICAgIGNvbnN0IHNpemVzID0gc2l6ZU1hdHJpeFtyb3dJbmRleF1cbiAgICBjb2x1bW5JbmRleCA9IC0xXG4gICAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAgIGNvbnN0IGxpbmUgPSBbXVxuXG4gICAgd2hpbGUgKCsrY29sdW1uSW5kZXggPCBtb3N0Q2VsbHNQZXJSb3cpIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dbY29sdW1uSW5kZXhdIHx8ICcnXG4gICAgICBsZXQgYmVmb3JlID0gJydcbiAgICAgIGxldCBhZnRlciA9ICcnXG5cbiAgICAgIGlmIChvcHRpb25zLmFsaWduRGVsaW1pdGVycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9XG4gICAgICAgICAgbG9uZ2VzdENlbGxCeUNvbHVtbltjb2x1bW5JbmRleF0gLSAoc2l6ZXNbY29sdW1uSW5kZXhdIHx8IDApXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhbGlnbm1lbnRzW2NvbHVtbkluZGV4XVxuXG4gICAgICAgIGlmIChjb2RlID09PSAxMTQgLyogYHJgICovKSB7XG4gICAgICAgICAgYmVmb3JlID0gJyAnLnJlcGVhdChzaXplKVxuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDk5IC8qIGBjYCAqLykge1xuICAgICAgICAgIGlmIChzaXplICUgMikge1xuICAgICAgICAgICAgYmVmb3JlID0gJyAnLnJlcGVhdChzaXplIC8gMiArIDAuNSlcbiAgICAgICAgICAgIGFmdGVyID0gJyAnLnJlcGVhdChzaXplIC8gMiAtIDAuNSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlID0gJyAnLnJlcGVhdChzaXplIC8gMilcbiAgICAgICAgICAgIGFmdGVyID0gYmVmb3JlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmdGVyID0gJyAnLnJlcGVhdChzaXplKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGltaXRlclN0YXJ0ICE9PSBmYWxzZSAmJiAhY29sdW1uSW5kZXgpIHtcbiAgICAgICAgbGluZS5wdXNoKCd8JylcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zLnBhZGRpbmcgIT09IGZhbHNlICYmXG4gICAgICAgIC8vIERvbuKAmXQgYWRkIHRoZSBvcGVuaW5nIHNwYWNlIGlmIHdl4oCZcmUgbm90IGFsaWduaW5nIGFuZCB0aGUgY2VsbCBpc1xuICAgICAgICAvLyBlbXB0eTogdGhlcmUgd2lsbCBiZSBhIGNsb3Npbmcgc3BhY2UuXG4gICAgICAgICEob3B0aW9ucy5hbGlnbkRlbGltaXRlcnMgPT09IGZhbHNlICYmIGNlbGwgPT09ICcnKSAmJlxuICAgICAgICAob3B0aW9ucy5kZWxpbWl0ZXJTdGFydCAhPT0gZmFsc2UgfHwgY29sdW1uSW5kZXgpXG4gICAgICApIHtcbiAgICAgICAgbGluZS5wdXNoKCcgJylcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYWxpZ25EZWxpbWl0ZXJzICE9PSBmYWxzZSkge1xuICAgICAgICBsaW5lLnB1c2goYmVmb3JlKVxuICAgICAgfVxuXG4gICAgICBsaW5lLnB1c2goY2VsbClcblxuICAgICAgaWYgKG9wdGlvbnMuYWxpZ25EZWxpbWl0ZXJzICE9PSBmYWxzZSkge1xuICAgICAgICBsaW5lLnB1c2goYWZ0ZXIpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBhZGRpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIGxpbmUucHVzaCgnICcpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucy5kZWxpbWl0ZXJFbmQgIT09IGZhbHNlIHx8XG4gICAgICAgIGNvbHVtbkluZGV4ICE9PSBtb3N0Q2VsbHNQZXJSb3cgLSAxXG4gICAgICApIHtcbiAgICAgICAgbGluZS5wdXNoKCd8JylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaW5lcy5wdXNoKFxuICAgICAgb3B0aW9ucy5kZWxpbWl0ZXJFbmQgPT09IGZhbHNlXG4gICAgICAgID8gbGluZS5qb2luKCcnKS5yZXBsYWNlKC8gKyQvLCAnJylcbiAgICAgICAgOiBsaW5lLmpvaW4oJycpXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVsbHx1bmRlZmluZWR9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKHZhbHVlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFN0cmluZ0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubGVuZ3RoXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVsbHx1bmRlZmluZWR9IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB0b0FsaWdubWVudCh2YWx1ZSkge1xuICBjb25zdCBjb2RlID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLmNvZGVQb2ludEF0KDApIDogMFxuXG4gIHJldHVybiBjb2RlID09PSA2NyAvKiBgQ2AgKi8gfHwgY29kZSA9PT0gOTkgLyogYGNgICovXG4gICAgPyA5OSAvKiBgY2AgKi9cbiAgICA6IGNvZGUgPT09IDc2IC8qIGBMYCAqLyB8fCBjb2RlID09PSAxMDggLyogYGxgICovXG4gICAgPyAxMDggLyogYGxgICovXG4gICAgOiBjb2RlID09PSA4MiAvKiBgUmAgKi8gfHwgY29kZSA9PT0gMTE0IC8qIGByYCAqL1xuICAgID8gMTE0IC8qIGByYCAqL1xuICAgIDogMFxufVxuIl0sIm5hbWVzIjpbIm1hcmtkb3duVGFibGUiLCJ0YWJsZSIsIm9wdGlvbnMiLCJhbGlnbiIsImNvbmNhdCIsInN0cmluZ0xlbmd0aCIsImRlZmF1bHRTdHJpbmdMZW5ndGgiLCJhbGlnbm1lbnRzIiwiY2VsbE1hdHJpeCIsInNpemVNYXRyaXgiLCJsb25nZXN0Q2VsbEJ5Q29sdW1uIiwibW9zdENlbGxzUGVyUm93Iiwicm93SW5kZXgiLCJsZW5ndGgiLCJyb3ciLCJzaXplcyIsImNvbHVtbkluZGV4IiwiY2VsbCIsInNlcmlhbGl6ZSIsImFsaWduRGVsaW1pdGVycyIsInNpemUiLCJ1bmRlZmluZWQiLCJwdXNoIiwidG9BbGlnbm1lbnQiLCJjb2RlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJNYXRoIiwibWF4IiwicmVwZWF0Iiwic3BsaWNlIiwibGluZXMiLCJsaW5lIiwiZGVsaW1pdGVyU3RhcnQiLCJwYWRkaW5nIiwiZGVsaW1pdGVyRW5kIiwiam9pbiIsInJlcGxhY2UiLCJ2YWx1ZSIsIlN0cmluZyIsImNvZGVQb2ludEF0Il0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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