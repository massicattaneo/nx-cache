fef4e511459619a0f4704a539556e066
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useShouldUseMinimalList = require("./useShouldUseMinimalList");
let renderedHook;
const expectedInitialState = {
    setDivRef: expect.any(Function),
    shouldUseMinimalList: true
};
const mockObserve = jest.fn();
const mockDisconnect = jest.fn();
global.ResizeObserver = jest.fn().mockImplementation(()=>({
        observe: jest.fn((props)=>mockObserve(props)),
        unobserve: jest.fn(),
        disconnect: mockDisconnect
    }));
beforeEach(jest.clearAllMocks);
// TODO: Find a way to assert the resize observer (cb and unmount)
describe("useShouldUseMinimalistList", ()=>{
    describe("on initial render", ()=>{
        beforeEach(()=>{
            renderedHook = (0, _react.renderHook)(_useShouldUseMinimalList.useShouldUseMinimalList);
        });
        it("should return correct initial state", ()=>{
            expect(renderedHook.result.current).toStrictEqual(expectedInitialState);
        });
    });
    describe("when sets to small element", ()=>{
        const event = {
            offsetWidth: _useShouldUseMinimalList.MINIMAL_LIST_BREAK_WIDTH - 10
        };
        beforeEach(()=>{
            renderedHook = (0, _react.renderHook)(_useShouldUseMinimalList.useShouldUseMinimalList);
            (0, _react.act)(()=>renderedHook.result.current.setDivRef(event));
        });
        it("should return correct initial state", ()=>{
            expect(mockObserve).toHaveBeenCalledWith(event);
        });
    });
    describe("when sets to large element", ()=>{
        const event = {
            offsetWidth: _useShouldUseMinimalList.MINIMAL_LIST_BREAK_WIDTH + 10
        };
        beforeEach(()=>{
            renderedHook = (0, _react.renderHook)(_useShouldUseMinimalList.useShouldUseMinimalList);
            (0, _react.act)(()=>renderedHook.result.current.setDivRef(event));
        });
        it("should return correct initial state", ()=>{
            expect(mockObserve).toHaveBeenCalledWith(event);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL2FwcHMvY2xpZW50LXdlYi9zcmMvYXBwL2NvbXBvbmVudHMvSHViL0ZpbGVzL0ZpbGVzTGlzdC9ob29rcy91c2VTaG91bGRVc2VNaW5pbWFsTGlzdC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlbmRlckhvb2tSZXN1bHQsIGFjdCwgcmVuZGVySG9vayB9IGZyb20gXCJAdGVzdGluZy1saWJyYXJ5L3JlYWN0XCJcbmltcG9ydCB7XG4gIE1JTklNQUxfTElTVF9CUkVBS19XSURUSCxcbiAgVXNlU2hvdWxkVXNlTWluaW1hbGlzdExpc3RTdGF0ZSxcbiAgdXNlU2hvdWxkVXNlTWluaW1hbExpc3QsXG59IGZyb20gXCIuL3VzZVNob3VsZFVzZU1pbmltYWxMaXN0XCJcblxubGV0IHJlbmRlcmVkSG9vazogUmVuZGVySG9va1Jlc3VsdDxVc2VTaG91bGRVc2VNaW5pbWFsaXN0TGlzdFN0YXRlLCB1bmRlZmluZWQ+XG5cbmNvbnN0IGV4cGVjdGVkSW5pdGlhbFN0YXRlID0ge1xuICBzZXREaXZSZWY6IGV4cGVjdC5hbnkoRnVuY3Rpb24pLFxuICBzaG91bGRVc2VNaW5pbWFsTGlzdDogdHJ1ZSxcbn1cblxuY29uc3QgbW9ja09ic2VydmUgPSBqZXN0LmZuKClcbmNvbnN0IG1vY2tEaXNjb25uZWN0ID0gamVzdC5mbigpXG5cbmdsb2JhbC5SZXNpemVPYnNlcnZlciA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgb2JzZXJ2ZTogamVzdC5mbihwcm9wcyA9PiBtb2NrT2JzZXJ2ZShwcm9wcykpLFxuICB1bm9ic2VydmU6IGplc3QuZm4oKSxcbiAgZGlzY29ubmVjdDogbW9ja0Rpc2Nvbm5lY3QsXG59KSlcblxuYmVmb3JlRWFjaChqZXN0LmNsZWFyQWxsTW9ja3MpXG5cbi8vIFRPRE86IEZpbmQgYSB3YXkgdG8gYXNzZXJ0IHRoZSByZXNpemUgb2JzZXJ2ZXIgKGNiIGFuZCB1bm1vdW50KVxuXG5kZXNjcmliZShcInVzZVNob3VsZFVzZU1pbmltYWxpc3RMaXN0XCIsICgpID0+IHtcbiAgZGVzY3JpYmUoXCJvbiBpbml0aWFsIHJlbmRlclwiLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICByZW5kZXJlZEhvb2sgPSByZW5kZXJIb29rKHVzZVNob3VsZFVzZU1pbmltYWxMaXN0KVxuICAgIH0pXG5cbiAgICBpdChcInNob3VsZCByZXR1cm4gY29ycmVjdCBpbml0aWFsIHN0YXRlXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChyZW5kZXJlZEhvb2sucmVzdWx0LmN1cnJlbnQpLnRvU3RyaWN0RXF1YWwoZXhwZWN0ZWRJbml0aWFsU3RhdGUpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZShcIndoZW4gc2V0cyB0byBzbWFsbCBlbGVtZW50XCIsICgpID0+IHtcbiAgICBjb25zdCBldmVudCA9IHsgb2Zmc2V0V2lkdGg6IE1JTklNQUxfTElTVF9CUkVBS19XSURUSCAtIDEwIH0gYXMgSFRNTERpdkVsZW1lbnRcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHJlbmRlcmVkSG9vayA9IHJlbmRlckhvb2sodXNlU2hvdWxkVXNlTWluaW1hbExpc3QpXG5cbiAgICAgIGFjdCgoKSA9PiByZW5kZXJlZEhvb2sucmVzdWx0LmN1cnJlbnQuc2V0RGl2UmVmKGV2ZW50KSlcbiAgICB9KVxuXG4gICAgaXQoXCJzaG91bGQgcmV0dXJuIGNvcnJlY3QgaW5pdGlhbCBzdGF0ZVwiLCAoKSA9PiB7XG4gICAgICBleHBlY3QobW9ja09ic2VydmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV2ZW50KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoXCJ3aGVuIHNldHMgdG8gbGFyZ2UgZWxlbWVudFwiLCAoKSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSB7IG9mZnNldFdpZHRoOiBNSU5JTUFMX0xJU1RfQlJFQUtfV0lEVEggKyAxMCB9IGFzIEhUTUxEaXZFbGVtZW50XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICByZW5kZXJlZEhvb2sgPSByZW5kZXJIb29rKHVzZVNob3VsZFVzZU1pbmltYWxMaXN0KVxuXG4gICAgICBhY3QoKCkgPT4gcmVuZGVyZWRIb29rLnJlc3VsdC5jdXJyZW50LnNldERpdlJlZihldmVudCkpXG4gICAgfSlcblxuICAgIGl0KFwic2hvdWxkIHJldHVybiBjb3JyZWN0IGluaXRpYWwgc3RhdGVcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KG1vY2tPYnNlcnZlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChldmVudClcbiAgICB9KVxuICB9KVxufSlcbiJdLCJuYW1lcyI6WyJyZW5kZXJlZEhvb2siLCJleHBlY3RlZEluaXRpYWxTdGF0ZSIsInNldERpdlJlZiIsImV4cGVjdCIsImFueSIsIkZ1bmN0aW9uIiwic2hvdWxkVXNlTWluaW1hbExpc3QiLCJtb2NrT2JzZXJ2ZSIsImplc3QiLCJmbiIsIm1vY2tEaXNjb25uZWN0IiwiZ2xvYmFsIiwiUmVzaXplT2JzZXJ2ZXIiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJvYnNlcnZlIiwicHJvcHMiLCJ1bm9ic2VydmUiLCJkaXNjb25uZWN0IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJkZXNjcmliZSIsInJlbmRlckhvb2siLCJ1c2VTaG91bGRVc2VNaW5pbWFsTGlzdCIsIml0IiwicmVzdWx0IiwiY3VycmVudCIsInRvU3RyaWN0RXF1YWwiLCJldmVudCIsIm9mZnNldFdpZHRoIiwiTUlOSU1BTF9MSVNUX0JSRUFLX1dJRFRIIiwiYWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwibWFwcGluZ3MiOiI7Ozs7dUJBQWtEO3lDQUszQztBQUVQLElBQUlBO0FBRUosTUFBTUMsdUJBQXVCO0lBQzNCQyxXQUFXQyxPQUFPQyxHQUFHLENBQUNDO0lBQ3RCQyxzQkFBc0I7QUFDeEI7QUFFQSxNQUFNQyxjQUFjQyxLQUFLQyxFQUFFO0FBQzNCLE1BQU1DLGlCQUFpQkYsS0FBS0MsRUFBRTtBQUU5QkUsT0FBT0MsY0FBYyxHQUFHSixLQUFLQyxFQUFFLEdBQUdJLGtCQUFrQixDQUFDLElBQU8sQ0FBQTtRQUMxREMsU0FBU04sS0FBS0MsRUFBRSxDQUFDTSxDQUFBQSxRQUFTUixZQUFZUTtRQUN0Q0MsV0FBV1IsS0FBS0MsRUFBRTtRQUNsQlEsWUFBWVA7SUFDZCxDQUFBO0FBRUFRLFdBQVdWLEtBQUtXLGFBQWE7QUFFN0Isa0VBQWtFO0FBRWxFQyxTQUFTLDhCQUE4QjtJQUNyQ0EsU0FBUyxxQkFBcUI7UUFDNUJGLFdBQVc7WUFDVGxCLGVBQWVxQixJQUFBQSxpQkFBVSxFQUFDQyxnREFBdUI7UUFDbkQ7UUFFQUMsR0FBRyx1Q0FBdUM7WUFDeENwQixPQUFPSCxhQUFhd0IsTUFBTSxDQUFDQyxPQUFPLEVBQUVDLGFBQWEsQ0FBQ3pCO1FBQ3BEO0lBQ0Y7SUFFQW1CLFNBQVMsOEJBQThCO1FBQ3JDLE1BQU1PLFFBQVE7WUFBRUMsYUFBYUMsaURBQXdCLEdBQUc7UUFBRztRQUMzRFgsV0FBVztZQUNUbEIsZUFBZXFCLElBQUFBLGlCQUFVLEVBQUNDLGdEQUF1QjtZQUVqRFEsSUFBQUEsVUFBRyxFQUFDLElBQU05QixhQUFhd0IsTUFBTSxDQUFDQyxPQUFPLENBQUN2QixTQUFTLENBQUN5QjtRQUNsRDtRQUVBSixHQUFHLHVDQUF1QztZQUN4Q3BCLE9BQU9JLGFBQWF3QixvQkFBb0IsQ0FBQ0o7UUFDM0M7SUFDRjtJQUVBUCxTQUFTLDhCQUE4QjtRQUNyQyxNQUFNTyxRQUFRO1lBQUVDLGFBQWFDLGlEQUF3QixHQUFHO1FBQUc7UUFDM0RYLFdBQVc7WUFDVGxCLGVBQWVxQixJQUFBQSxpQkFBVSxFQUFDQyxnREFBdUI7WUFFakRRLElBQUFBLFVBQUcsRUFBQyxJQUFNOUIsYUFBYXdCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDdkIsU0FBUyxDQUFDeUI7UUFDbEQ7UUFFQUosR0FBRyx1Q0FBdUM7WUFDeENwQixPQUFPSSxhQUFhd0Isb0JBQW9CLENBQUNKO1FBQzNDO0lBQ0Y7QUFDRiJ9