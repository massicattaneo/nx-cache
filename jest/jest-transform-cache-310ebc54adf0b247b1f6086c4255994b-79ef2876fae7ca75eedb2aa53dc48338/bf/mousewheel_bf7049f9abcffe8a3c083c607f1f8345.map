{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/swiper/modules/mousewheel/mousewheel.js"],"sourcesContent":["/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport { now, nextTick } from '../../shared/utils.js';\nexport default function Mousewheel({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel'\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}"],"names":["Mousewheel","swiper","extendParams","on","emit","window","getWindow","mousewheel","enabled","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","noMousewheelClass","timeout","lastScrollTime","now","lastEventBeforeSnap","recentWheelEvents","normalize","e","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","shiftKey","deltaMode","spinX","spinY","pixelX","pixelY","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","params","delta","direction","isEnd","loop","animating","slideNext","raw","isBeginning","slidePrev","Date","getTime","releaseScroll","handle","event","disableParentSwiper","target","closest","cssMode","preventDefault","targetEl","el","document","querySelector","targetElContainsTarget","contains","originalEvent","rtlFactor","rtlTranslate","data","isHorizontal","Math","abs","positions","getTranslate","minTranslate","maxTranslate","nested","stopPropagation","freeMode","time","sign","length","shift","prevEvent","undefined","push","ignoreWheelEvents","position","wasBeginning","wasEnd","setTransition","setTranslate","updateProgress","updateActiveIndex","updateSlidesClasses","loopFix","byMousewheel","sticky","clearTimeout","firstEvent","splice","snapToThreshold","nextTick","slideToClosest","speed","autoplay","autoplayDisableOnInteraction","stop","returnValue","events","method","enable","wrapperEl","removeEventListener","disable","addEventListener","Object","assign"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}