{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/hast-util-to-jsx-runtime/lib/index.js"],"sourcesContent":["// Register MDX nodes in mdast:\n/// <reference types=\"mdast-util-mdx-expression\" />\n/// <reference types=\"mdast-util-mdx-jsx\" />\n/// <reference types=\"mdast-util-mdxjs-esm\" />\n\n/**\n * @typedef {import('estree').Identifier} Identifier\n * @typedef {import('estree').Literal} Literal\n * @typedef {import('estree').MemberExpression} MemberExpression\n * @typedef {import('estree').Expression} Expression\n * @typedef {import('estree').Program} Program\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('mdast-util-mdx-expression').MdxFlowExpressionHast} MdxFlowExpression\n * @typedef {import('mdast-util-mdx-expression').MdxTextExpressionHast} MdxTextExpression\n *\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxFlowElementHast} MdxJsxFlowElement\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxTextElementHast} MdxJsxTextElement\n *\n * @typedef {import('mdast-util-mdxjs-esm').MdxjsEsmHast} MdxjsEsm\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Position} Position\n *\n * @typedef {import('./components.js').Components} Components\n */\n\n/**\n * @typedef {JSX.Element | string | null | undefined} Child\n *   Child.\n *\n * @callback Create\n *   Create something in development or production.\n * @param {Nodes} node\n *   hast node.\n * @param {unknown} type\n *   Fragment symbol or tag name.\n * @param {Props} props\n *   Properties and children.\n * @param {string | undefined} key\n *   Key.\n * @returns {JSX.Element}\n *   Result.\n *\n * @callback CreateEvaluater\n *   Create an evaluator that turns ESTree ASTs from embedded MDX into values.\n * @returns {Evaluater}\n *   Evaluater.\n *\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @callback EvaluateExpression\n *   Turn an MDX expression into a value.\n * @param {Expression} expression\n *   ESTree expression.\n * @returns {unknown}\n *   Result of expression.\n *\n * @callback EvaluateProgram\n *   Turn an MDX program (export/import statements) into a value.\n * @param {Program} expression\n *   ESTree program.\n * @returns {unknown}\n *   Result of program;\n *   should likely be `undefined` as ESM changes the scope but doesnâ€™t yield\n *   something.\n *\n * @typedef Evaluater\n *   Evaluator that turns ESTree ASTs from embedded MDX into values.\n * @property {EvaluateExpression} evaluateExpression\n *   Evaluate an expression.\n * @property {EvaluateProgram} evaluateProgram\n *   Evaluate a program.\n *\n * @typedef {[string, Value]} Field\n *   Property field.\n *\n * @typedef {unknown} Fragment\n *   Represent the children, typically a symbol.\n *\n * @callback Jsx\n *   Create a production element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} [key]\n *   Dynamicly generated key to use.\n * @returns {JSX.Element}\n *   Element from your framework.\n *\n * @callback JsxDev\n *   Create a development element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} key\n *   Dynamicly generated key to use.\n * @param {boolean} isStaticChildren\n *   Whether two or more children are passed (in an array), which is whether\n *   `jsxs` or `jsx` would be used.\n * @param {Source} source\n *   Info about source.\n * @param {undefined} self\n *   Nothing (this is used by frameworks that have components, we donâ€™t).\n * @returns {JSX.Element}\n *   Element from your framework.\n *\n * @typedef {{children?: Array<Child> | Child, node?: Element | MdxJsxFlowElement | MdxJsxTextElement | undefined, [prop: string]: Array<Child> | Child | Element | MdxJsxFlowElement | MdxJsxTextElement | Value | undefined}} Props\n *   Properties and children.\n *\n * @typedef RegularFields\n *   Configuration.\n * @property {Partial<Components> | null | undefined} [components]\n *   Components to use (optional).\n * @property {CreateEvaluater | null | undefined} [createEvaluater]\n *   Create an evaluator that turns ESTree ASTs into values (optional).\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names (default: `'react'`).\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in source info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n * @property {boolean | null | undefined} [ignoreInvalidStyle=false]\n *   Ignore invalid CSS in `style` props (default: `false`);\n *   the default behavior is to throw an error.\n * @property {boolean | null | undefined} [passKeys=true]\n *   Generate keys to optimize frameworks that support them (default: `true`).\n *\n *   > ðŸ‘‰ **Note**: Solid currently fails if keys are passed.\n * @property {boolean | null | undefined} [passNode=false]\n *   Pass the hast element node to components (default: `false`).\n * @property {Space | null | undefined} [space='html']\n *   Whether `tree` is in the `'html'` or `'svg'` space (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects (default:\n *   `'dom'`).\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\n *   (default: `true`).\n *\n * @typedef RuntimeDevelopment\n *   Runtime fields when development is on.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {true} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev} jsxDEV\n *   Development JSX.\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef RuntimeProduction\n *   Runtime fields when development is off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {false | null | undefined} [development]\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off) (optional).\n * @property {Jsx} jsx\n *   Dynamic JSX.\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx} jsxs\n *   Static JSX.\n *\n * @typedef RuntimeUnknown\n *   Runtime fields when development might be on or off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {boolean} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef Source\n *   Info about source.\n * @property {number | undefined} columnNumber\n *   Column where thing starts (0-indexed).\n * @property {string | undefined} fileName\n *   Name of source file.\n * @property {number | undefined} lineNumber\n *   Line where thing starts (1-indexed).\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n *   > ðŸ‘‰ **Note**: hast is not XML.\n *   > It supports SVG as embedded in HTML.\n *   > It does not support the features available in XML.\n *   > Passing SVG might break but fragments of modern SVG should be fine.\n *   > Use `xast` if you need to support SVG as XML.\n *\n * @typedef State\n *   Info passed around.\n * @property {unknown} Fragment\n *   Fragment symbol.\n * @property {Array<Parents>} ancestors\n *   Stack of parents.\n * @property {Partial<Components>} components\n *   Components to swap.\n * @property {Create} create\n *   Create something in development or production.\n * @property {ElementAttributeNameCase} elementAttributeNameCase\n *   Casing to use for attribute names.\n * @property {Evaluater | undefined} evaluater\n *   Evaluator that turns ESTree ASTs into values.\n * @property {string | undefined} filePath\n *   File path.\n * @property {boolean} ignoreInvalidStyle\n *   Ignore invalid CSS in `style` props.\n * @property {boolean} passKeys\n *   Generate keys to optimize frameworks that support them.\n * @property {boolean} passNode\n *   Pass `node` to components.\n * @property {Schema} schema\n *   Current schema.\n * @property {StylePropertyNameCase} stylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n * @property {boolean} tableCellAlignToStyle\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\n *\n * @typedef {Record<string, string>} Style\n *   Style map.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef {Style | boolean | number | string} Value\n *   Primitive property value and `Style` map.\n */\n\n/**\n * @typedef {RuntimeDevelopment & RegularFields} Development\n *   Configuration (development).\n * @typedef {Development | Production | Unknown} Options\n *   Configuration.\n * @typedef {RegularFields & RuntimeProduction} Production\n *   Configuration (production).\n * @typedef {RegularFields & RuntimeUnknown} Unknown\n *   Configuration (production or development).\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\nimport {whitespace} from 'hast-util-whitespace'\nimport {find, hastToReact, html, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport styleToObject from 'style-to-object'\nimport {pointStart} from 'unist-util-position'\nimport {VFileMessage} from 'vfile-message'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map()\n\nconst cap = /[A-Z]/g\nconst dashSomething = /-([a-z])/g\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\n\nconst tableCellElement = new Set(['td', 'th'])\n\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime'\n\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JSX.Element}\n *   JSX element.\n */\n\nexport function toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options')\n  }\n\n  const filePath = options.filePath || undefined\n  /** @type {Create} */\n  let create\n\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError(\n        'Expected `jsxDEV` in options when `development: true`'\n      )\n    }\n\n    create = developmentCreate(filePath, options.jsxDEV)\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options')\n    }\n\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options')\n    }\n\n    create = productionCreate(filePath, options.jsx, options.jsxs)\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  }\n\n  const result = one(state, tree, undefined)\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(\n    tree,\n    state.Fragment,\n    {children: result || undefined},\n    undefined\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key)\n  }\n\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node)\n  }\n\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key)\n  }\n\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node)\n  }\n\n  if (node.type === 'root') {\n    return root(state, node, key)\n  }\n\n  if (node.type === 'text') {\n    return text(state, node)\n  }\n}\n\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction element(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type = findComponentFromName(state, node.tagName, false)\n  const props = createElementProps(state, node)\n  let children = createChildren(state, node)\n\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !whitespace(child) : true\n    })\n  }\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree\n    const expression = program.body[0]\n    assert(expression.type === 'ExpressionStatement')\n\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateExpression(expression.expression)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsm} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateProgram(node.data.estree)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type =\n    node.name === null\n      ? state.Fragment\n      : findComponentFromName(state, node.name, true)\n  const props = createJsxElementProps(state, node)\n  const children = createChildren(state, node)\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {}\n\n  addChildren(props, createChildren(state, node))\n\n  return state.create(node, state.Fragment, props, key)\n}\n\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction text(_, node) {\n  return node.value\n}\n\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElement | MdxJsxTextElement} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node\n  }\n}\n\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0]\n\n    if (value) {\n      props.children = value\n    }\n  }\n}\n\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const fn = isStaticChildren ? jsxs : jsx\n    return key ? fn(type, props, key) : fn(type, props)\n  }\n}\n\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const point = pointStart(node)\n    return jsxDEV(\n      type,\n      props,\n      key,\n      isStaticChildren,\n      {\n        columnNumber: point ? point.column - 1 : undefined,\n        fileName: filePath,\n        lineNumber: point ? point.line : undefined\n      },\n      undefined\n    )\n  }\n}\n\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n  /** @type {string | undefined} */\n  let alignValue\n  /** @type {string} */\n  let prop\n\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop])\n\n      if (result) {\n        const [key, value] = result\n\n        if (\n          state.tableCellAlignToStyle &&\n          key === 'align' &&\n          typeof value === 'string' &&\n          tableCellElement.has(node.tagName)\n        ) {\n          alignValue = value\n        } else {\n          props[key] = value\n        }\n      }\n    }\n  }\n\n  if (alignValue) {\n    // Assume style is an object.\n    const style = /** @type {Style} */ (props.style || (props.style = {}))\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] =\n      alignValue\n  }\n\n  return props\n}\n\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree\n        const expression = program.body[0]\n        assert(expression.type === 'ExpressionStatement')\n        const objectExpression = expression.expression\n        assert(objectExpression.type === 'ObjectExpression')\n        const property = objectExpression.properties[0]\n        assert(property.type === 'SpreadElement')\n\n        Object.assign(\n          props,\n          state.evaluater.evaluateExpression(property.argument)\n        )\n      } else {\n        crashEstree(state, node.position)\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name\n      /** @type {unknown} */\n      let value\n\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (\n          attribute.value.data &&\n          attribute.value.data.estree &&\n          state.evaluater\n        ) {\n          const program = attribute.value.data.estree\n          const expression = program.body[0]\n          assert(expression.type === 'ExpressionStatement')\n          value = state.evaluater.evaluateExpression(expression.expression)\n        } else {\n          crashEstree(state, node.position)\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value\n      }\n\n      // Assume a prop.\n      props[name] = /** @type {Props[keyof Props]} */ (value)\n    }\n  }\n\n  return props\n}\n\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = []\n  let index = -1\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByName = state.passKeys ? new Map() : emptyMap\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    /** @type {string | undefined} */\n    let key\n\n    if (state.passKeys) {\n      const name =\n        child.type === 'element'\n          ? child.tagName\n          : child.type === 'mdxJsxFlowElement' ||\n              child.type === 'mdxJsxTextElement'\n            ? child.name\n            : undefined\n\n      if (name) {\n        const count = countsByName.get(name) || 0\n        key = name + '-' + count\n        countsByName.set(name, count + 1)\n      }\n    }\n\n    const result = one(state, child, key)\n    if (result !== undefined) children.push(result)\n  }\n\n  return children\n}\n\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(state, prop, value) {\n  const info = find(state.schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject =\n      typeof value === 'object' ? value : parseStyle(state, String(value))\n\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject)\n    }\n\n    return ['style', styleObject]\n  }\n\n  return [\n    state.elementAttributeNameCase === 'react' && info.space\n      ? hastToReact[info.property] || info.property\n      : info.attribute,\n    value\n  ]\n}\n\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */\nfunction parseStyle(state, value) {\n  /** @type {Style} */\n  const result = {}\n\n  try {\n    // @ts-expect-error: `style-to-object` types are broken.\n    styleToObject(value, replacer)\n  } catch (error) {\n    if (!state.ignoreInvalidStyle) {\n      const cause = /** @type {Error} */ (error)\n      const message = new VFileMessage('Cannot parse `style` attribute', {\n        ancestors: state.ancestors,\n        cause,\n        ruleId: 'style',\n        source: 'hast-util-to-jsx-runtime'\n      })\n      message.file = state.filePath || undefined\n      message.url = docs + '#cannot-parse-style-attribute'\n\n      throw message\n    }\n  }\n\n  return result\n\n  /**\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\n   * property.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function replacer(name, value) {\n    let key = name\n\n    if (key.slice(0, 2) !== '--') {\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4)\n      key = key.replace(dashSomething, toCamel)\n    }\n\n    result[key] = value\n  }\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result\n\n  if (!allowExpression) {\n    result = {type: 'Literal', value: name}\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.')\n    let index = -1\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let node\n\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = isIdentifierName(identifiers[index])\n        ? {type: 'Identifier', name: identifiers[index]}\n        : {type: 'Literal', value: identifiers[index]}\n      node = node\n        ? {\n            type: 'MemberExpression',\n            object: node,\n            property: prop,\n            computed: Boolean(index && prop.type === 'Literal'),\n            optional: false\n          }\n        : prop\n    }\n\n    assert(node, 'always a result')\n    result = node\n  } else {\n    result =\n      isIdentifierName(name) && !/^[a-z]/.test(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n  }\n\n  // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n  if (result.type === 'Literal') {\n    const name = /** @type {keyof JSX.IntrinsicElements} */ (result.value)\n\n    return own.call(state.components, name) ? state.components[name] : name\n  }\n\n  // Assume component.\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result)\n  }\n\n  crashEstree(state)\n}\n\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */\nfunction crashEstree(state, place) {\n  const message = new VFileMessage(\n    'Cannot handle MDX estrees without `createEvaluater`',\n    {\n      ancestors: state.ancestors,\n      place,\n      ruleId: 'mdx-estree',\n      source: 'hast-util-to-jsx-runtime'\n    }\n  )\n  message.file = state.filePath || undefined\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater'\n\n  throw message\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash)\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\n  return to\n}\n\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */\nfunction toCamel(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n"],"names":["toJsxRuntime","own","hasOwnProperty","emptyMap","Map","cap","dashSomething","tableElements","Set","tableCellElement","docs","tree","options","Fragment","undefined","TypeError","filePath","create","development","jsxDEV","developmentCreate","jsx","jsxs","productionCreate","state","ancestors","components","elementAttributeNameCase","evaluater","createEvaluater","ignoreInvalidStyle","passKeys","passNode","schema","space","svg","html","stylePropertyNameCase","tableCellAlignToStyle","result","one","children","node","key","type","element","mdxExpression","mdxJsxElement","mdxEsm","root","text","parentSchema","tagName","toLowerCase","push","findComponentFromName","props","createElementProps","createChildren","has","filter","child","whitespace","addNode","addChildren","pop","data","estree","program","expression","body","assert","evaluateExpression","crashEstree","position","evaluateProgram","name","createJsxElementProps","_","value","length","isStaticChildren","Array","isArray","fn","point","pointStart","columnNumber","column","fileName","lineNumber","line","alignValue","prop","properties","call","createProperty","style","attribute","attributes","objectExpression","property","Object","assign","argument","index","countsByName","count","get","set","info","find","Number","isNaN","commaSeparated","commas","spaces","styleObject","parseStyle","String","transformStylesToCssCasing","hastToReact","styleToObject","replacer","error","cause","message","VFileMessage","ruleId","source","file","url","slice","replace","toCamel","allowExpression","includes","identifiers","split","isIdentifierName","object","computed","Boolean","optional","test","place","domCasing","cssCasing","from","transformStyleToCssCasing","to","toDash","$1","toUpperCase","$0"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}