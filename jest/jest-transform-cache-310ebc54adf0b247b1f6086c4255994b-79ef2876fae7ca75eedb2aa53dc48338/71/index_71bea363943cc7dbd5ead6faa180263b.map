{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Omit<Parent, 'children' | 'type'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | null | undefined | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {undefined | void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnâ€™t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Fragment | Nodes>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {(this: CompileContext) => undefined} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {(this: CompileContext, node: Nodes, token: Token, onError?: OnEnterError) => undefined} enter\n *   Enter a node.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => undefined} exit\n *   Exit a node.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n * @property {CompileData} data\n *   Info passed around; key/value store.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\nimport {toString} from 'mdast-util-to-string'\nimport {parse, postprocess, preprocess} from 'micromark'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding\n    encoding = undefined\n  }\n  return compiler(options)(\n    postprocess(\n      parse(options).document().write(preprocess()(value, encoding, true))\n    )\n  )\n}\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n    while (++index <= length) {\n      const event = events[index]\n      switch (event[1].type) {\n        case 'listUnordered':\n        case 'listOrdered':\n        case 'blockQuote': {\n          if (event[0] === 'enter') {\n            containerBalance++\n          } else {\n            containerBalance--\n          }\n          atMarker = undefined\n          break\n        }\n        case 'lineEndingBlank': {\n          if (event[0] === 'enter') {\n            if (\n              listItem &&\n              !atMarker &&\n              !containerBalance &&\n              !firstBlankLineIndex\n            ) {\n              firstBlankLineIndex = index\n            }\n            atMarker = undefined\n          }\n          break\n        }\n        case 'linePrefix':\n        case 'listItemValue':\n        case 'listItemMarker':\n        case 'listItemPrefix':\n        case 'listItemPrefixWhitespace': {\n          // Empty.\n\n          break\n        }\n        default: {\n          atMarker = undefined\n        }\n      }\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === 'listItemPrefix') {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: weâ€™ll add `end` in a second.\n            end: undefined\n          }\n          listItem = item\n          events.splice(index, 0, ['enter', item, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {undefined}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Nodes} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    siblings.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler])\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    }\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): itâ€™s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      this.data.expectingFirstListItemValue = undefined\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return\n    this.buffer()\n    this.data.flowCodeInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    this.data.flowCodeInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    /** @type {Array<Nodes>} */\n    const siblings = node.children\n    let tail = siblings[siblings.length - 1]\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: weâ€™ll add `end` later.\n        end: undefined\n      }\n      siblings.push(tail)\n    }\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    // If weâ€™re at a hard break, include the line ending in there.\n    if (this.data.atHardBreak) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      this.data.atHardBreak = undefined\n      return\n    }\n    if (\n      !this.data.setextHeadingSlurpLineEnding &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    this.data.referenceType = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    this.data.referenceType = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // Assume a reference.\n    this.data.inReference = true\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    this.data.inReference = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed'\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    this.data.referenceType = 'full'\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    this.data.characterReferenceType = token.type\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = this.data.characterReferenceType\n    /** @type {string} */\n    let value\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      this.data.characterReferenceType = undefined\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      value = result\n    }\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n\n  /** @returns {Html} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n  while (++index < extensions.length) {\n    const value = extensions[index]\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols': {\n          const right = extension[key]\n          if (right) {\n            combined[key].push(...right)\n          }\n          break\n        }\n        case 'transforms': {\n          const right = extension[key]\n          if (right) {\n            combined[key].push(...right)\n          }\n          break\n        }\n        case 'enter':\n        case 'exit': {\n          const right = extension[key]\n          if (right) {\n            Object.assign(combined[key], right)\n          }\n          break\n        }\n        // No default\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n"],"names":["fromMarkdown","own","hasOwnProperty","value","encoding","options","undefined","compiler","postprocess","parse","document","write","preprocess","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","list","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","configure","mdastExtensions","compile","events","tree","type","children","context","stack","tokenStack","resume","listStack","index","length","push","tail","pop","prepareList","handler","call","Object","assign","sliceSerialize","defaultOnError","position","start","point","line","column","offset","end","containerBalance","listSpread","lineIndex","firstBlankLineIndex","atMarker","event","tailIndex","tailEvent","_spread","splice","item","create","and","open","token","node","errorHandler","parent","siblings","close","onExitError","Error","stringifyPosition","toString","expectingFirstListItemValue","ancestor","Number","parseInt","lang","meta","flowCodeInside","replace","identifier","normalizeIdentifier","toLowerCase","title","url","depth","setextHeadingSlurpLineEnding","codePointAt","text","atHardBreak","includes","inReference","referenceType","string","decodeString","fragment","alt","characterReferenceType","decodeNumericCharacterReference","result","decodeNamedCharacterReference","ordered","spread","checked","d","combined","extensions","Array","isArray","extension","key","right","left"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCC,GAED;;CAEC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+CC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6CC;;;;+BAkCeA;;;eAAAA;;;mCAhCO;2BACsB;8DACC;2CACnB;kDACO;+CACU;4CACZ;AAChC,MAAMC,MAAM,CAAC,EAAEC,cAAc;AAyBtB,SAASF,aAAaG,KAAK,EAAEC,QAAQ,EAAEC,OAAO;IACnD,IAAI,OAAOD,aAAa,UAAU;QAChCC,UAAUD;QACVA,WAAWE;IACb;IACA,OAAOC,SAASF,SACdG,IAAAA,sBAAW,EACTC,IAAAA,gBAAK,EAACJ,SAASK,QAAQ,GAAGC,KAAK,CAACC,IAAAA,qBAAU,IAAGT,OAAOC,UAAU;AAGpE;AAEA;;;;CAIC,GACD,SAASG,SAASF,OAAO;IACvB,mBAAmB,GACnB,MAAMQ,SAAS;QACbC,YAAY,EAAE;QACdC,gBAAgB;YAAC;YAAY;YAAY;YAAW;YAAa;SAAS;QAC1EC,OAAO;YACLC,UAAUC,OAAOC;YACjBC,kBAAkBC;YAClBC,eAAeD;YACfE,YAAYL,OAAOM;YACnBC,YAAYP,OAAOO;YACnBC,iBAAiBL;YACjBM,oBAAoBN;YACpBO,YAAYV,OAAOW;YACnBC,qBAAqBC;YACrBC,qBAAqBD;YACrBE,cAAcf,OAAOW,UAAUE;YAC/BG,UAAUhB,OAAOgB,UAAUH;YAC3BI,cAAcd;YACde,MAAMf;YACNgB,eAAehB;YACfiB,YAAYpB,OAAOoB;YACnBC,6BAA6BR;YAC7BS,uBAAuBT;YACvBU,uBAAuBV;YACvBW,UAAUxB,OAAOwB;YACjBC,iBAAiBzB,OAAO0B;YACxBC,mBAAmB3B,OAAO0B;YAC1BE,UAAU5B,OAAO6B,MAAMhB;YACvBiB,cAAc3B;YACd4B,UAAU/B,OAAO6B,MAAMhB;YACvBmB,cAAc7B;YACd8B,OAAOjC,OAAOiC;YACdC,OAAOrB;YACPZ,MAAMD,OAAOC;YACbkC,UAAUnC,OAAOmC;YACjBC,eAAeC;YACfC,aAAatC,OAAOuC,MAAMC;YAC1BC,eAAezC,OAAOuC;YACtBG,WAAW1C,OAAO0C;YAClBC,WAAWC;YACXC,iBAAiBhC;YACjBiC,2BAA2BjC;YAC3BkC,qBAAqBlC;YACrBmC,eAAehD,OAAOM;YACtB2C,QAAQjD,OAAOiD;YACfC,eAAelD,OAAOkD;QACxB;QACAC,MAAM;YACJ9C,YAAY+C;YACZC,oBAAoBC;YACpBvD,UAAUqD;YACVhD,eAAemD;YACfrD,kBAAkBsD;YAClBjD,YAAY6C;YACZK,sBAAsBC;YACtBC,qCAAqCC;YACrCC,iCAAiCD;YACjCE,yBAAyBC;YACzBrD,YAAY0C,OAAOY;YACnBC,iBAAiBC;YACjBtD,qBAAqBuD;YACrBrD,qBAAqBsD;YACrBjD,eAAeuC;YACf3C,cAAcqC,OAAOiB;YACrBrD,UAAUoC,OAAOkB;YACjBrD,cAAcyC;YACdxC,MAAMwC;YACNtC,YAAYgC;YACZ/B,6BAA6BkD;YAC7BjD,uBAAuBkD;YACvBjD,uBAAuBkD;YACvBjD,UAAU4B;YACV3B,iBAAiB2B,OAAOsB;YACxB/C,mBAAmByB,OAAOsB;YAC1B9C,UAAUwB,OAAOuB;YACjB7C,cAAc4B;YACd3B,UAAUqB,OAAOwB;YACjB5C,cAAc0B;YACdzB,OAAOmB,OAAOyB;YACd3C,OAAO4C;YACPC,WAAWC;YACXC,YAAYC;YACZjF,MAAMmD,OAAO+B;YACbhD,UAAUiB;YACVd,aAAac;YACbX,eAAeW;YACfV,WAAWU;YACXP,iBAAiBuC;YACjBtC,2BAA2BuC;YAC3BtC,qBAAqBuC;YACrBC,UAAUC;YACVxC,eAAeI,OAAOqC;YACtBC,2BAA2BC;YAC3BC,mBAAmBC;YACnB5C,QAAQG;YACRF,eAAeE;QACjB;IACF;IACA0C,UAAUnG,QAAQ,AAACR,CAAAA,WAAW,CAAC,CAAA,EAAG4G,eAAe,IAAI,EAAE;IAEvD,wBAAwB,GACxB,MAAM7E,OAAO,CAAC;IACd,OAAO8E;IAEP;;;;;;;GAOC,GACD,SAASA,QAAQC,MAAM;QACrB,iBAAiB,GACjB,IAAIC,OAAO;YACTC,MAAM;YACNC,UAAU,EAAE;QACd;QACA,mDAAmD,GACnD,MAAMC,UAAU;YACdC,OAAO;gBAACJ;aAAK;YACbK,YAAY,EAAE;YACd5G;YACAG;YACAqD;YACAtC;YACA2F;YACAtF;QACF;QACA,0BAA0B,GAC1B,MAAMuF,YAAY,EAAE;QACpB,IAAIC,QAAQ,CAAC;QACb,MAAO,EAAEA,QAAQT,OAAOU,MAAM,CAAE;YAC9B,qEAAqE;YACrE,wCAAwC;YACxC,IACEV,MAAM,CAACS,MAAM,CAAC,EAAE,CAACP,IAAI,KAAK,iBAC1BF,MAAM,CAACS,MAAM,CAAC,EAAE,CAACP,IAAI,KAAK,iBAC1B;gBACA,IAAIF,MAAM,CAACS,MAAM,CAAC,EAAE,KAAK,SAAS;oBAChCD,UAAUG,IAAI,CAACF;gBACjB,OAAO;oBACL,MAAMG,OAAOJ,UAAUK,GAAG;oBAC1BJ,QAAQK,YAAYd,QAAQY,MAAMH;gBACpC;YACF;QACF;QACAA,QAAQ,CAAC;QACT,MAAO,EAAEA,QAAQT,OAAOU,MAAM,CAAE;YAC9B,MAAMK,UAAUrH,MAAM,CAACsG,MAAM,CAACS,MAAM,CAAC,EAAE,CAAC;YACxC,IAAI3H,IAAIkI,IAAI,CAACD,SAASf,MAAM,CAACS,MAAM,CAAC,EAAE,CAACP,IAAI,GAAG;gBAC5Ca,OAAO,CAACf,MAAM,CAACS,MAAM,CAAC,EAAE,CAACP,IAAI,CAAC,CAACc,IAAI,CACjCC,OAAOC,MAAM,CACX;oBACEC,gBAAgBnB,MAAM,CAACS,MAAM,CAAC,EAAE,CAACU,cAAc;gBACjD,GACAf,UAEFJ,MAAM,CAACS,MAAM,CAAC,EAAE;YAEpB;QACF;QAEA,kCAAkC;QAClC,IAAIL,QAAQE,UAAU,CAACI,MAAM,GAAG,GAAG;YACjC,MAAME,OAAOR,QAAQE,UAAU,CAACF,QAAQE,UAAU,CAACI,MAAM,GAAG,EAAE;YAC9D,MAAMK,UAAUH,IAAI,CAAC,EAAE,IAAIQ;YAC3BL,QAAQC,IAAI,CAACZ,SAASjH,WAAWyH,IAAI,CAAC,EAAE;QAC1C;QAEA,8BAA8B;QAC9BX,KAAKoB,QAAQ,GAAG;YACdC,OAAOC,MACLvB,OAAOU,MAAM,GAAG,IACZV,MAAM,CAAC,EAAE,CAAC,EAAE,CAACsB,KAAK,GAClB;gBACEE,MAAM;gBACNC,QAAQ;gBACRC,QAAQ;YACV;YAENC,KAAKJ,MACHvB,OAAOU,MAAM,GAAG,IACZV,MAAM,CAACA,OAAOU,MAAM,GAAG,EAAE,CAAC,EAAE,CAACiB,GAAG,GAChC;gBACEH,MAAM;gBACNC,QAAQ;gBACRC,QAAQ;YACV;QAER;QAEA,mBAAmB;QACnBjB,QAAQ,CAAC;QACT,MAAO,EAAEA,QAAQ/G,OAAOC,UAAU,CAAC+G,MAAM,CAAE;YACzCT,OAAOvG,OAAOC,UAAU,CAAC8G,MAAM,CAACR,SAASA;QAC3C;QACA,OAAOA;IACT;IAEA;;;;;GAKC,GACD,SAASa,YAAYd,MAAM,EAAEsB,KAAK,EAAEZ,MAAM;QACxC,IAAID,QAAQa,QAAQ;QACpB,IAAIM,mBAAmB,CAAC;QACxB,IAAIC,aAAa;QACjB,8BAA8B,GAC9B,IAAI3F;QACJ,+BAA+B,GAC/B,IAAI4F;QACJ,+BAA+B,GAC/B,IAAIC;QACJ,gCAAgC,GAChC,IAAIC;QACJ,MAAO,EAAEvB,SAASC,OAAQ;YACxB,MAAMuB,QAAQjC,MAAM,CAACS,MAAM;YAC3B,OAAQwB,KAAK,CAAC,EAAE,CAAC/B,IAAI;gBACnB,KAAK;gBACL,KAAK;gBACL,KAAK;oBAAc;wBACjB,IAAI+B,KAAK,CAAC,EAAE,KAAK,SAAS;4BACxBL;wBACF,OAAO;4BACLA;wBACF;wBACAI,WAAW7I;wBACX;oBACF;gBACA,KAAK;oBAAmB;wBACtB,IAAI8I,KAAK,CAAC,EAAE,KAAK,SAAS;4BACxB,IACE/F,YACA,CAAC8F,YACD,CAACJ,oBACD,CAACG,qBACD;gCACAA,sBAAsBtB;4BACxB;4BACAuB,WAAW7I;wBACb;wBACA;oBACF;gBACA,KAAK;gBACL,KAAK;gBACL,KAAK;gBACL,KAAK;gBACL,KAAK;oBAA4B;wBAG/B;oBACF;gBACA;oBAAS;wBACP6I,WAAW7I;oBACb;YACF;YACA,IACE,AAAC,CAACyI,oBACAK,KAAK,CAAC,EAAE,KAAK,WACbA,KAAK,CAAC,EAAE,CAAC/B,IAAI,KAAK,oBACnB0B,qBAAqB,CAAC,KACrBK,KAAK,CAAC,EAAE,KAAK,UACZA,CAAAA,KAAK,CAAC,EAAE,CAAC/B,IAAI,KAAK,mBACjB+B,KAAK,CAAC,EAAE,CAAC/B,IAAI,KAAK,aAAY,GAClC;gBACA,IAAIhE,UAAU;oBACZ,IAAIgG,YAAYzB;oBAChBqB,YAAY3I;oBACZ,MAAO+I,YAAa;wBAClB,MAAMC,YAAYnC,MAAM,CAACkC,UAAU;wBACnC,IACEC,SAAS,CAAC,EAAE,CAACjC,IAAI,KAAK,gBACtBiC,SAAS,CAAC,EAAE,CAACjC,IAAI,KAAK,mBACtB;4BACA,IAAIiC,SAAS,CAAC,EAAE,KAAK,QAAQ;4BAC7B,IAAIL,WAAW;gCACb9B,MAAM,CAAC8B,UAAU,CAAC,EAAE,CAAC5B,IAAI,GAAG;gCAC5B2B,aAAa;4BACf;4BACAM,SAAS,CAAC,EAAE,CAACjC,IAAI,GAAG;4BACpB4B,YAAYI;wBACd,OAAO,IACLC,SAAS,CAAC,EAAE,CAACjC,IAAI,KAAK,gBACtBiC,SAAS,CAAC,EAAE,CAACjC,IAAI,KAAK,sBACtBiC,SAAS,CAAC,EAAE,CAACjC,IAAI,KAAK,gCACtBiC,SAAS,CAAC,EAAE,CAACjC,IAAI,KAAK,sBACtBiC,SAAS,CAAC,EAAE,CAACjC,IAAI,KAAK,kBACtB;wBACA,QAAQ;wBACV,OAAO;4BACL;wBACF;oBACF;oBACA,IACE6B,uBACC,CAAA,CAACD,aAAaC,sBAAsBD,SAAQ,GAC7C;wBACA5F,SAASkG,OAAO,GAAG;oBACrB;oBAEA,gBAAgB;oBAChBlG,SAASyF,GAAG,GAAGV,OAAOC,MAAM,CAC1B,CAAC,GACDY,YAAY9B,MAAM,CAAC8B,UAAU,CAAC,EAAE,CAACR,KAAK,GAAGW,KAAK,CAAC,EAAE,CAACN,GAAG;oBAEvD3B,OAAOqC,MAAM,CAACP,aAAarB,OAAO,GAAG;wBAAC;wBAAQvE;wBAAU+F,KAAK,CAAC,EAAE;qBAAC;oBACjExB;oBACAC;gBACF;gBAEA,0BAA0B;gBAC1B,IAAIuB,KAAK,CAAC,EAAE,CAAC/B,IAAI,KAAK,kBAAkB;oBACtC,kBAAkB,GAClB,MAAMoC,OAAO;wBACXpC,MAAM;wBACNkC,SAAS;wBACTd,OAAOL,OAAOC,MAAM,CAAC,CAAC,GAAGe,KAAK,CAAC,EAAE,CAACX,KAAK;wBACvC,iDAAiD;wBACjDK,KAAKxI;oBACP;oBACA+C,WAAWoG;oBACXtC,OAAOqC,MAAM,CAAC5B,OAAO,GAAG;wBAAC;wBAAS6B;wBAAML,KAAK,CAAC,EAAE;qBAAC;oBACjDxB;oBACAC;oBACAqB,sBAAsB5I;oBACtB6I,WAAW;gBACb;YACF;QACF;QACAhC,MAAM,CAACsB,MAAM,CAAC,EAAE,CAACc,OAAO,GAAGP;QAC3B,OAAOnB;IACT;IAEA;;;;;;;;;GASC,GACD,SAAS3G,OAAOwI,MAAM,EAAEC,GAAG;QACzB,OAAOC;QAEP;;;;KAIC,GACD,SAASA,KAAKC,KAAK;YACjB7I,MAAMmH,IAAI,CAAC,IAAI,EAAEuB,OAAOG,QAAQA;YAChC,IAAIF,KAAKA,IAAIxB,IAAI,CAAC,IAAI,EAAE0B;QAC1B;IACF;IAEA;;;GAGC,GACD,SAAS9H;QACP,IAAI,CAACyF,KAAK,CAACM,IAAI,CAAC;YACdT,MAAM;YACNC,UAAU,EAAE;QACd;IACF;IAEA;;;;;;;;;;;GAWC,GACD,SAAStG,MAAM8I,IAAI,EAAED,KAAK,EAAEE,YAAY;QACtC,MAAMC,SAAS,IAAI,CAACxC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAChD,yBAAyB,GACzB,MAAMoC,WAAWD,OAAO1C,QAAQ;QAChC2C,SAASnC,IAAI,CAACgC;QACd,IAAI,CAACtC,KAAK,CAACM,IAAI,CAACgC;QAChB,IAAI,CAACrC,UAAU,CAACK,IAAI,CAAC;YAAC+B;YAAOE;SAAa;QAC1CD,KAAKtB,QAAQ,GAAG;YACdC,OAAOC,MAAMmB,MAAMpB,KAAK;YACxB,iDAAiD;YACjDK,KAAKxI;QACP;IACF;IAEA;;;;;;;GAOC,GACD,SAASgE,OAAOqF,GAAG;QACjB,OAAOO;QAEP;;;;KAIC,GACD,SAASA,MAAML,KAAK;YAClB,IAAIF,KAAKA,IAAIxB,IAAI,CAAC,IAAI,EAAE0B;YACxBxF,KAAK8D,IAAI,CAAC,IAAI,EAAE0B;QAClB;IACF;IAEA;;;;;;;;;GASC,GACD,SAASxF,KAAKwF,KAAK,EAAEM,WAAW;QAC9B,MAAML,OAAO,IAAI,CAACtC,KAAK,CAACQ,GAAG;QAC3B,MAAM4B,OAAO,IAAI,CAACnC,UAAU,CAACO,GAAG;QAChC,IAAI,CAAC4B,MAAM;YACT,MAAM,IAAIQ,MACR,mBACEP,MAAMxC,IAAI,GACV,QACAgD,IAAAA,6CAAiB,EAAC;gBAChB5B,OAAOoB,MAAMpB,KAAK;gBAClBK,KAAKe,MAAMf,GAAG;YAChB,KACA;QAEN,OAAO,IAAIc,IAAI,CAAC,EAAE,CAACvC,IAAI,KAAKwC,MAAMxC,IAAI,EAAE;YACtC,IAAI8C,aAAa;gBACfA,YAAYhC,IAAI,CAAC,IAAI,EAAE0B,OAAOD,IAAI,CAAC,EAAE;YACvC,OAAO;gBACL,MAAM1B,UAAU0B,IAAI,CAAC,EAAE,IAAIrB;gBAC3BL,QAAQC,IAAI,CAAC,IAAI,EAAE0B,OAAOD,IAAI,CAAC,EAAE;YACnC;QACF;QACAE,KAAKtB,QAAQ,CAACM,GAAG,GAAGJ,MAAMmB,MAAMf,GAAG;IACrC;IAEA;;;GAGC,GACD,SAASpB;QACP,OAAO4C,IAAAA,2BAAQ,EAAC,IAAI,CAAC9C,KAAK,CAACQ,GAAG;IAChC;IAEA,EAAE;IACF,YAAY;IACZ,EAAE;IAEF;;;GAGC,GACD,SAAStE;QACP,IAAI,CAACtB,IAAI,CAACmI,2BAA2B,GAAG;IAC1C;IAEA;;;GAGC,GACD,SAAShH,qBAAqBsG,KAAK;QACjC,IAAI,IAAI,CAACzH,IAAI,CAACmI,2BAA2B,EAAE;YACzC,MAAMC,WAAW,IAAI,CAAChD,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;YAClD2C,SAAS/B,KAAK,GAAGgC,OAAOC,QAAQ,CAAC,IAAI,CAACpC,cAAc,CAACuB,QAAQ;YAC7D,IAAI,CAACzH,IAAI,CAACmI,2BAA2B,GAAGjK;QAC1C;IACF;IAEA;;;GAGC,GACD,SAAS+E;QACP,MAAMjD,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKa,IAAI,GAAGvI;IACd;IAEA;;;GAGC,GACD,SAASkD;QACP,MAAMlD,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKc,IAAI,GAAGxI;IACd;IAEA;;;GAGC,GACD,SAASgD;QACP,qCAAqC;QACrC,IAAI,IAAI,CAAChD,IAAI,CAACyI,cAAc,EAAE;QAC9B,IAAI,CAAC9I,MAAM;QACX,IAAI,CAACK,IAAI,CAACyI,cAAc,GAAG;IAC7B;IAEA;;;GAGC,GACD,SAAS3F;QACP,MAAM9C,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAK3J,KAAK,GAAGiC,KAAK0I,OAAO,CAAC,4BAA4B;QACtD,IAAI,CAAC1I,IAAI,CAACyI,cAAc,GAAGvK;IAC7B;IAEA;;;GAGC,GACD,SAASiF;QACP,MAAMnD,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAK3J,KAAK,GAAGiC,KAAK0I,OAAO,CAAC,gBAAgB;IAC5C;IAEA;;;GAGC,GACD,SAASpF,4BAA4BmE,KAAK;QACxC,MAAMzG,QAAQ,IAAI,CAACsE,MAAM;QACzB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAK1G,KAAK,GAAGA;QACb0G,KAAKiB,UAAU,GAAGC,IAAAA,qDAAmB,EACnC,IAAI,CAAC1C,cAAc,CAACuB,QACpBoB,WAAW;IACf;IAEA;;;GAGC,GACD,SAAStF;QACP,MAAMvD,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKoB,KAAK,GAAG9I;IACf;IAEA;;;GAGC,GACD,SAASqD;QACP,MAAMrD,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKqB,GAAG,GAAG/I;IACb;IAEA;;;GAGC,GACD,SAASoC,yBAAyBqF,KAAK;QACrC,MAAMC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9C,IAAI,CAACiC,KAAKsB,KAAK,EAAE;YACf,MAAMA,QAAQ,IAAI,CAAC9C,cAAc,CAACuB,OAAOhC,MAAM;YAC/CiC,KAAKsB,KAAK,GAAGA;QACf;IACF;IAEA;;;GAGC,GACD,SAASrE;QACP,IAAI,CAAC3E,IAAI,CAACiJ,4BAA4B,GAAG;IAC3C;IAEA;;;GAGC,GACD,SAASxE,gCAAgCgD,KAAK;QAC5C,MAAMC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKsB,KAAK,GAAG,IAAI,CAAC9C,cAAc,CAACuB,OAAOyB,WAAW,CAAC,OAAO,KAAK,IAAI;IACtE;IAEA;;;GAGC,GACD,SAAS3E;QACP,IAAI,CAACvE,IAAI,CAACiJ,4BAA4B,GAAG/K;IAC3C;IAEA;;;GAGC,GAED,SAASe,YAAYwI,KAAK;QACxB,MAAMC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9C,yBAAyB,GACzB,MAAMoC,WAAWH,KAAKxC,QAAQ;QAC9B,IAAIS,OAAOkC,QAAQ,CAACA,SAASpC,MAAM,GAAG,EAAE;QACxC,IAAI,CAACE,QAAQA,KAAKV,IAAI,KAAK,QAAQ;YACjC,uBAAuB;YACvBU,OAAOwD;YACPxD,KAAKS,QAAQ,GAAG;gBACdC,OAAOC,MAAMmB,MAAMpB,KAAK;gBACxB,2CAA2C;gBAC3CK,KAAKxI;YACP;YACA2J,SAASnC,IAAI,CAACC;QAChB;QACA,IAAI,CAACP,KAAK,CAACM,IAAI,CAACC;IAClB;IAEA;;;GAGC,GAED,SAASnD,WAAWiF,KAAK;QACvB,MAAM9B,OAAO,IAAI,CAACP,KAAK,CAACQ,GAAG;QAC3BD,KAAK5H,KAAK,IAAI,IAAI,CAACmI,cAAc,CAACuB;QAClC9B,KAAKS,QAAQ,CAACM,GAAG,GAAGJ,MAAMmB,MAAMf,GAAG;IACrC;IAEA;;;GAGC,GAED,SAAS1C,iBAAiByD,KAAK;QAC7B,MAAMtC,UAAU,IAAI,CAACC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QACjD,8DAA8D;QAC9D,IAAI,IAAI,CAACzF,IAAI,CAACoJ,WAAW,EAAE;YACzB,MAAMzD,OAAOR,QAAQD,QAAQ,CAACC,QAAQD,QAAQ,CAACO,MAAM,GAAG,EAAE;YAC1DE,KAAKS,QAAQ,CAACM,GAAG,GAAGJ,MAAMmB,MAAMf,GAAG;YACnC,IAAI,CAAC1G,IAAI,CAACoJ,WAAW,GAAGlL;YACxB;QACF;QACA,IACE,CAAC,IAAI,CAAC8B,IAAI,CAACiJ,4BAA4B,IACvCxK,OAAOE,cAAc,CAAC0K,QAAQ,CAAClE,QAAQF,IAAI,GAC3C;YACAhG,YAAY8G,IAAI,CAAC,IAAI,EAAE0B;YACvBjF,WAAWuD,IAAI,CAAC,IAAI,EAAE0B;QACxB;IACF;IAEA;;;GAGC,GAED,SAASjE;QACP,IAAI,CAACxD,IAAI,CAACoJ,WAAW,GAAG;IAC1B;IAEA;;;GAGC,GAED,SAAS3F;QACP,MAAMzD,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAK3J,KAAK,GAAGiC;IACf;IAEA;;;GAGC,GAED,SAAS0D;QACP,MAAM1D,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAK3J,KAAK,GAAGiC;IACf;IAEA;;;GAGC,GAED,SAASoD;QACP,MAAMpD,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAK3J,KAAK,GAAGiC;IACf;IAEA;;;GAGC,GAED,SAASiE;QACP,MAAMyD,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9C,0EAA0E;QAC1E,iCAAiC;QACjC,gBAAgB;QAChB,IAAI,IAAI,CAACzF,IAAI,CAACsJ,WAAW,EAAE;YACzB,0BAA0B,GAC1B,MAAMC,gBAAgB,IAAI,CAACvJ,IAAI,CAACuJ,aAAa,IAAI;YACjD7B,KAAKzC,IAAI,IAAI;YACb,4BAA4B;YAC5ByC,KAAK6B,aAAa,GAAGA;YACrB,4BAA4B;YAC5B,OAAO7B,KAAKqB,GAAG;YACf,OAAOrB,KAAKoB,KAAK;QACnB,OAAO;YACL,4BAA4B;YAC5B,OAAOpB,KAAKiB,UAAU;YACtB,4BAA4B;YAC5B,OAAOjB,KAAK1G,KAAK;QACnB;QACA,IAAI,CAAChB,IAAI,CAACuJ,aAAa,GAAGrL;IAC5B;IAEA;;;GAGC,GAED,SAASyF;QACP,MAAM+D,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9C,0EAA0E;QAC1E,iCAAiC;QACjC,gBAAgB;QAChB,IAAI,IAAI,CAACzF,IAAI,CAACsJ,WAAW,EAAE;YACzB,0BAA0B,GAC1B,MAAMC,gBAAgB,IAAI,CAACvJ,IAAI,CAACuJ,aAAa,IAAI;YACjD7B,KAAKzC,IAAI,IAAI;YACb,4BAA4B;YAC5ByC,KAAK6B,aAAa,GAAGA;YACrB,4BAA4B;YAC5B,OAAO7B,KAAKqB,GAAG;YACf,OAAOrB,KAAKoB,KAAK;QACnB,OAAO;YACL,4BAA4B;YAC5B,OAAOpB,KAAKiB,UAAU;YACtB,4BAA4B;YAC5B,OAAOjB,KAAK1G,KAAK;QACnB;QACA,IAAI,CAAChB,IAAI,CAACuJ,aAAa,GAAGrL;IAC5B;IAEA;;;GAGC,GAED,SAAS4F,gBAAgB2D,KAAK;QAC5B,MAAM+B,SAAS,IAAI,CAACtD,cAAc,CAACuB;QACnC,MAAMW,WAAW,IAAI,CAAChD,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAClD,2EAA2E;QAC3E,SAAS;QACT2C,SAASpH,KAAK,GAAGyI,IAAAA,uCAAY,EAACD;QAC9B,mCAAmC;QACnCpB,SAASO,UAAU,GAAGC,IAAAA,qDAAmB,EAACY,QAAQX,WAAW;IAC/D;IAEA;;;GAGC,GAED,SAASjF;QACP,MAAM8F,WAAW,IAAI,CAACtE,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAClD,MAAM1H,QAAQ,IAAI,CAACuH,MAAM;QACzB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9C,sBAAsB;QACtB,IAAI,CAACzF,IAAI,CAACsJ,WAAW,GAAG;QACxB,IAAI5B,KAAKzC,IAAI,KAAK,QAAQ;YACxB,mCAAmC,GACnC,MAAMC,WAAWwE,SAASxE,QAAQ;YAClCwC,KAAKxC,QAAQ,GAAGA;QAClB,OAAO;YACLwC,KAAKiC,GAAG,GAAG5L;QACb;IACF;IAEA;;;GAGC,GAED,SAASoG;QACP,MAAMnE,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKqB,GAAG,GAAG/I;IACb;IAEA;;;GAGC,GAED,SAASoE;QACP,MAAMpE,OAAO,IAAI,CAACsF,MAAM;QACxB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKoB,KAAK,GAAG9I;IACf;IAEA;;;GAGC,GAED,SAASsE;QACP,IAAI,CAACtE,IAAI,CAACsJ,WAAW,GAAGpL;IAC1B;IAEA;;;GAGC,GAED,SAASwD;QACP,IAAI,CAAC1B,IAAI,CAACuJ,aAAa,GAAG;IAC5B;IAEA;;;GAGC,GAED,SAASrF,sBAAsBuD,KAAK;QAClC,MAAMzG,QAAQ,IAAI,CAACsE,MAAM;QACzB,MAAMoC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9C,2EAA2E;QAC3E,SAAS;QACTiC,KAAK1G,KAAK,GAAGA;QACb,mCAAmC;QACnC0G,KAAKiB,UAAU,GAAGC,IAAAA,qDAAmB,EACnC,IAAI,CAAC1C,cAAc,CAACuB,QACpBoB,WAAW;QACb,IAAI,CAAC7I,IAAI,CAACuJ,aAAa,GAAG;IAC5B;IAEA;;;GAGC,GAED,SAAS7G,+BAA+B+E,KAAK;QAC3C,IAAI,CAACzH,IAAI,CAAC4J,sBAAsB,GAAGnC,MAAMxC,IAAI;IAC/C;IAEA;;;GAGC,GACD,SAASpC,8BAA8B4E,KAAK;QAC1C,MAAMzH,OAAO,IAAI,CAACkG,cAAc,CAACuB;QACjC,MAAMxC,OAAO,IAAI,CAACjF,IAAI,CAAC4J,sBAAsB;QAC7C,mBAAmB,GACnB,IAAI7L;QACJ,IAAIkH,MAAM;YACRlH,QAAQ8L,IAAAA,6EAA+B,EACrC7J,MACAiF,SAAS,oCAAoC,KAAK;YAEpD,IAAI,CAACjF,IAAI,CAAC4J,sBAAsB,GAAG1L;QACrC,OAAO;YACL,MAAM4L,SAASC,IAAAA,4DAA6B,EAAC/J;YAC7CjC,QAAQ+L;QACV;QACA,MAAMnE,OAAO,IAAI,CAACP,KAAK,CAACQ,GAAG;QAC3BD,KAAK5H,KAAK,IAAIA;QACd4H,KAAKS,QAAQ,CAACM,GAAG,GAAGJ,MAAMmB,MAAMf,GAAG;IACrC;IAEA;;;GAGC,GACD,SAASpE,uBAAuBmF,KAAK;QACnCjF,WAAWuD,IAAI,CAAC,IAAI,EAAE0B;QACtB,MAAMC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKqB,GAAG,GAAG,IAAI,CAAC7C,cAAc,CAACuB;IACjC;IAEA;;;GAGC,GACD,SAASpF,oBAAoBoF,KAAK;QAChCjF,WAAWuD,IAAI,CAAC,IAAI,EAAE0B;QACtB,MAAMC,OAAO,IAAI,CAACtC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACK,MAAM,GAAG,EAAE;QAC9CiC,KAAKqB,GAAG,GAAG,YAAY,IAAI,CAAC7C,cAAc,CAACuB;IAC7C;IAEA,EAAE;IACF,YAAY;IACZ,EAAE;IAEF,0BAA0B,GAC1B,SAASpI;QACP,OAAO;YACL4F,MAAM;YACNC,UAAU,EAAE;QACd;IACF;IAEA,oBAAoB,GACpB,SAASzF;QACP,OAAO;YACLwF,MAAM;YACNsD,MAAM;YACNC,MAAM;YACNzK,OAAO;QACT;IACF;IAEA,0BAA0B,GAC1B,SAAS+B;QACP,OAAO;YACLmF,MAAM;YACNlH,OAAO;QACT;IACF;IAEA,0BAA0B,GAC1B,SAASmC;QACP,OAAO;YACL+E,MAAM;YACN0D,YAAY;YACZ3H,OAAO;YACP8H,OAAO;YACPC,KAAK;QACP;IACF;IAEA,wBAAwB,GACxB,SAASzI;QACP,OAAO;YACL2E,MAAM;YACNC,UAAU,EAAE;QACd;IACF;IAEA,uBAAuB,GACvB,SAAS9F;QACP,OAAO;YACL6F,MAAM;YACN,8CAA8C;YAC9C+D,OAAO;YACP9D,UAAU,EAAE;QACd;IACF;IAEA,qBAAqB,GACrB,SAAS1E;QACP,OAAO;YACLyE,MAAM;QACR;IACF;IAEA,oBAAoB,GACpB,SAAStE;QACP,OAAO;YACLsE,MAAM;YACNlH,OAAO;QACT;IACF;IAEA,qBAAqB,GACrB,SAASgD;QACP,OAAO;YACLkE,MAAM;YACN6D,OAAO;YACPC,KAAK;YACLY,KAAK;QACP;IACF;IAEA,oBAAoB,GACpB,SAAS5K;QACP,OAAO;YACLkG,MAAM;YACN6D,OAAO;YACPC,KAAK;YACL7D,UAAU,EAAE;QACd;IACF;IAEA;;;GAGC,GACD,SAAS7D,KAAKoG,KAAK;QACjB,OAAO;YACLxC,MAAM;YACN+E,SAASvC,MAAMxC,IAAI,KAAK;YACxBoB,OAAO;YACP4D,QAAQxC,MAAMN,OAAO;YACrBjC,UAAU,EAAE;QACd;IACF;IAEA;;;GAGC,GACD,SAASjE,SAASwG,KAAK;QACrB,OAAO;YACLxC,MAAM;YACNgF,QAAQxC,MAAMN,OAAO;YACrB+C,SAAS;YACThF,UAAU,EAAE;QACd;IACF;IAEA,yBAAyB,GACzB,SAAS1D;QACP,OAAO;YACLyD,MAAM;YACNC,UAAU,EAAE;QACd;IACF;IAEA,sBAAsB,GACtB,SAASnD;QACP,OAAO;YACLkD,MAAM;YACNC,UAAU,EAAE;QACd;IACF;IAEA,oBAAoB,GACpB,SAASiE;QACP,OAAO;YACLlE,MAAM;YACNlH,OAAO;QACT;IACF;IAEA,6BAA6B,GAC7B,SAASiE;QACP,OAAO;YACLiD,MAAM;QACR;IACF;AACF;AAEA;;;;;;;CAOC,GACD,SAASqB,MAAM6D,CAAC;IACd,OAAO;QACL5D,MAAM4D,EAAE5D,IAAI;QACZC,QAAQ2D,EAAE3D,MAAM;QAChBC,QAAQ0D,EAAE1D,MAAM;IAClB;AACF;AAEA;;;;CAIC,GACD,SAAS7B,UAAUwF,QAAQ,EAAEC,UAAU;IACrC,IAAI7E,QAAQ,CAAC;IACb,MAAO,EAAEA,QAAQ6E,WAAW5E,MAAM,CAAE;QAClC,MAAM1H,QAAQsM,UAAU,CAAC7E,MAAM;QAC/B,IAAI8E,MAAMC,OAAO,CAACxM,QAAQ;YACxB6G,UAAUwF,UAAUrM;QACtB,OAAO;YACLyM,UAAUJ,UAAUrM;QACtB;IACF;AACF;AAEA;;;;CAIC,GACD,SAASyM,UAAUJ,QAAQ,EAAEI,SAAS;IACpC,4BAA4B,GAC5B,IAAIC;IACJ,IAAKA,OAAOD,UAAW;QACrB,IAAI3M,IAAIkI,IAAI,CAACyE,WAAWC,MAAM;YAC5B,OAAQA;gBACN,KAAK;oBAAkB;wBACrB,MAAMC,QAAQF,SAAS,CAACC,IAAI;wBAC5B,IAAIC,OAAO;4BACTN,QAAQ,CAACK,IAAI,CAAC/E,IAAI,IAAIgF;wBACxB;wBACA;oBACF;gBACA,KAAK;oBAAc;wBACjB,MAAMA,QAAQF,SAAS,CAACC,IAAI;wBAC5B,IAAIC,OAAO;4BACTN,QAAQ,CAACK,IAAI,CAAC/E,IAAI,IAAIgF;wBACxB;wBACA;oBACF;gBACA,KAAK;gBACL,KAAK;oBAAQ;wBACX,MAAMA,QAAQF,SAAS,CAACC,IAAI;wBAC5B,IAAIC,OAAO;4BACT1E,OAAOC,MAAM,CAACmE,QAAQ,CAACK,IAAI,EAAEC;wBAC/B;wBACA;oBACF;YAEF;QACF;IACF;AACF;AAEA,yBAAyB,GACzB,SAASvE,eAAewE,IAAI,EAAED,KAAK;IACjC,IAAIC,MAAM;QACR,MAAM,IAAI3C,MACR,mBACE2C,KAAK1F,IAAI,GACT,QACAgD,IAAAA,6CAAiB,EAAC;YAChB5B,OAAOsE,KAAKtE,KAAK;YACjBK,KAAKiE,KAAKjE,GAAG;QACf,KACA,4BACAgE,MAAMzF,IAAI,GACV,QACAgD,IAAAA,6CAAiB,EAAC;YAChB5B,OAAOqE,MAAMrE,KAAK;YAClBK,KAAKgE,MAAMhE,GAAG;QAChB,KACA;IAEN,OAAO;QACL,MAAM,IAAIsB,MACR,sCACE0C,MAAMzF,IAAI,GACV,QACAgD,IAAAA,6CAAiB,EAAC;YAChB5B,OAAOqE,MAAMrE,KAAK;YAClBK,KAAKgE,MAAMhE,GAAG;QAChB,KACA;IAEN;AACF"}