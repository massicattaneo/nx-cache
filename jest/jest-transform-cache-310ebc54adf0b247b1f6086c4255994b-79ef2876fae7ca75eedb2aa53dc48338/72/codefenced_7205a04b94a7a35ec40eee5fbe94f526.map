{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-core-commonmark/lib/code-fenced.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n  const closeStart = {\n    tokenize: tokenizeCloseStart,\n    partial: true\n  }\n  let initialPrefix = 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of code.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse whitespace like `markdown-rs`.\n    return beforeSequenceOpen(code)\n  }\n\n  /**\n   * In opening fence, after prefix, at sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeSequenceOpen(code) {\n    const tail = self.events[self.events.length - 1]\n    initialPrefix =\n      tail && tail[1].type === 'linePrefix'\n        ? tail[2].sliceSerialize(tail[1], true).length\n        : 0\n    marker = code\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *      ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      sizeOpen++\n      effects.consume(code)\n      return sequenceOpen\n    }\n    if (sizeOpen < 3) {\n      return nok(code)\n    }\n    effects.exit('codeFencedFenceSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, infoBefore, 'whitespace')(code)\n      : infoBefore(code)\n  }\n\n  /**\n   * In opening fence, after the sequence (and optional whitespace), before info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function infoBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFencedFence')\n      return self.interrupt\n        ? ok(code)\n        : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)\n    }\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n\n  /**\n   * In info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function info(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return infoBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, metaBefore, 'whitespace')(code)\n    }\n    if (code === 96 && code === marker) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return info\n  }\n\n  /**\n   * In opening fence, after info and whitespace, before meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return infoBefore(code)\n    }\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return infoBefore(code)\n    }\n    if (code === 96 && code === marker) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * At eol/eof in code, before a non-lazy closing fence or content.\n   *\n   * ```markdown\n   * > | ~~~js\n   *          ^\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function atNonLazyBreak(code) {\n    return effects.attempt(closeStart, after, contentBefore)(code)\n  }\n\n  /**\n   * Before code content, not a closing fence, at eol.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentBefore(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return contentStart\n  }\n\n  /**\n   * Before code content, not a closing fence.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return initialPrefix > 0 && markdownSpace(code)\n      ? factorySpace(\n          effects,\n          beforeContentChunk,\n          'linePrefix',\n          initialPrefix + 1\n        )(code)\n      : beforeContentChunk(code)\n  }\n\n  /**\n   * Before code content, after optional prefix.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)\n    }\n    effects.enter('codeFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In code content.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^^^^^^^^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After code.\n   *\n   * ```markdown\n   *   | ~~~js\n   *   | alert(1)\n   * > | ~~~\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeCloseStart(effects, ok, nok) {\n    let size = 0\n    return startBefore\n\n    /**\n     *\n     *\n     * @type {State}\n     */\n    function startBefore(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return start\n    }\n\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      // Always populated by defaults.\n\n      // To do: `enter` here or in next state?\n      effects.enter('codeFencedFence')\n      return markdownSpace(code)\n        ? factorySpace(\n            effects,\n            beforeSequenceClose,\n            'linePrefix',\n            self.parser.constructs.disable.null.includes('codeIndented')\n              ? undefined\n              : 4\n          )(code)\n        : beforeSequenceClose(code)\n    }\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      if (code === marker) {\n        effects.enter('codeFencedFenceSequence')\n        return sequenceClose(code)\n      }\n      return nok(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === marker) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size >= sizeOpen) {\n        effects.exit('codeFencedFenceSequence')\n        return markdownSpace(code)\n          ? factorySpace(effects, sequenceCloseAfter, 'whitespace')(code)\n          : sequenceCloseAfter(code)\n      }\n      return nok(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceCloseAfter(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n"],"names":["codeFenced","nonLazyContinuation","tokenize","tokenizeNonLazyContinuation","partial","name","tokenizeCodeFenced","concrete","effects","ok","nok","self","closeStart","tokenizeCloseStart","initialPrefix","sizeOpen","marker","start","code","beforeSequenceOpen","tail","events","length","type","sliceSerialize","enter","sequenceOpen","consume","exit","markdownSpace","factorySpace","infoBefore","markdownLineEnding","interrupt","check","atNonLazyBreak","after","contentType","info","metaBefore","meta","attempt","contentBefore","contentStart","beforeContentChunk","contentChunk","size","startBefore","beforeSequenceClose","parser","constructs","disable","null","includes","undefined","sequenceClose","sequenceCloseAfter","lineStart","lazy","now","line"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}