{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/libs/common/trpc/src/lib/trpcAdaptersUtils.ts"],"sourcesContent":["import { AnyTRPCProcedure } from \"@trpc/server\"\nimport { Procedure, Router } from \"@trpc/server/dist/unstable-core-do-not-import\"\n\nexport type CustomProcedure = Procedure<\n  \"mutation\" | \"query\" | \"subscription\",\n  {\n    input: unknown\n    output: unknown\n  }\n>\n\nexport interface CustomRouterRecord {\n  [key: string]: CustomProcedure | CustomRouterRecord\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type CustomRouter = Router<any, CustomRouterRecord>\n\nexport const isProcedure = (obj: CustomRouterRecord | CustomProcedure): obj is CustomProcedure => {\n  return \"_def\" in obj\n}\n\nexport const isOpenApiMeta = (\n  meta: unknown,\n): meta is { openapi: { method: string; path: string } } => {\n  return typeof meta === \"object\" && meta !== null && \"openapi\" in meta\n}\n\nexport function getTrpcRouterPaths<T extends CustomRouter>(\n  router: T,\n): Array<{\n  procedure: CustomProcedure\n  path: string\n}> {\n  if (router._def && router._def.procedures) {\n    return Object.entries(router._def.procedures).map(([path, procedure]) => {\n      return { procedure: procedure as AnyTRPCProcedure, path }\n    })\n  }\n  return []\n}\n\nexport function matchPattern(url: string, pattern: string) {\n  // Convert the pattern into a regular expression\n  const paramNames: Array<string> = []\n  const regexPattern = pattern\n    .replace(/:[a-zA-Z0-9-_]+/g, match => {\n      const paramName = match.substring(1)\n      paramNames.push(paramName)\n      return \"([^/]+)\" // Capture everything between slashes\n    })\n    .replace(/::/g, \"([^/]+)\") // Handle cases like ::subId\n\n  const regex = new RegExp(`^${regexPattern}$`)\n  return {\n    match: !!url.match(regex),\n    paramNames,\n    matches: url.match(regex) ?? [],\n  }\n}\n\nexport function extractParams(url: string, pattern: string): Record<string, string> | null {\n  const { matches, match, paramNames } = matchPattern(url, pattern)\n\n  if (match) {\n    // Extract the parameter values using the captured groups\n    const params: Record<string, string> = {}\n    paramNames.forEach((paramName, index) => {\n      params[paramName] = matches[index + 1] // match[0] is the full URL match, params start at index 1\n    })\n    return params\n  }\n\n  return null // Return null if no match\n}\n"],"names":["extractParams","getTrpcRouterPaths","isOpenApiMeta","isProcedure","matchPattern","obj","meta","router","_def","procedures","Object","entries","map","path","procedure","url","pattern","paramNames","regexPattern","replace","match","paramName","substring","push","regex","RegExp","matches","params","forEach","index"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;;;;;;;;IA6DgBA,aAAa;eAAbA;;IAjCAC,kBAAkB;eAAlBA;;IANHC,aAAa;eAAbA;;IAJAC,WAAW;eAAXA;;IAwBGC,YAAY;eAAZA;;;AAxBT,MAAMD,cAAc,CAACE;IAC1B,OAAO,UAAUA;AACnB;AAEO,MAAMH,gBAAgB,CAC3BI;IAEA,OAAO,OAAOA,SAAS,YAAYA,SAAS,QAAQ,aAAaA;AACnE;AAEO,SAASL,mBACdM,MAAS;IAKT,IAAIA,OAAOC,IAAI,IAAID,OAAOC,IAAI,CAACC,UAAU,EAAE;QACzC,OAAOC,OAAOC,OAAO,CAACJ,OAAOC,IAAI,CAACC,UAAU,EAAEG,GAAG,CAAC,CAAC,CAACC,MAAMC,UAAU;YAClE,OAAO;gBAAEA,WAAWA;gBAA+BD;YAAK;QAC1D;IACF;IACA,OAAO,EAAE;AACX;AAEO,SAAST,aAAaW,GAAW,EAAEC,OAAe;IACvD,gDAAgD;IAChD,MAAMC,aAA4B,EAAE;IACpC,MAAMC,eAAeF,QAClBG,OAAO,CAAC,oBAAoBC,CAAAA;QAC3B,MAAMC,YAAYD,MAAME,SAAS,CAAC;QAClCL,WAAWM,IAAI,CAACF;QAChB,OAAO,UAAU,qCAAqC;;IACxD,GACCF,OAAO,CAAC,OAAO,WAAW,4BAA4B;;IAEzD,MAAMK,QAAQ,IAAIC,OAAO,CAAC,CAAC,EAAEP,aAAa,CAAC,CAAC;QAIjCH;IAHX,OAAO;QACLK,OAAO,CAAC,CAACL,IAAIK,KAAK,CAACI;QACnBP;QACAS,SAASX,CAAAA,aAAAA,IAAIK,KAAK,CAACI,oBAAVT,wBAAAA,aAAoB,EAAE;IACjC;AACF;AAEO,SAASf,cAAce,GAAW,EAAEC,OAAe;IACxD,MAAM,EAAEU,OAAO,EAAEN,KAAK,EAAEH,UAAU,EAAE,GAAGb,aAAaW,KAAKC;IAEzD,IAAII,OAAO;QACT,yDAAyD;QACzD,MAAMO,SAAiC,CAAC;QACxCV,WAAWW,OAAO,CAAC,CAACP,WAAWQ;YAC7BF,MAAM,CAACN,UAAU,GAAGK,OAAO,CAACG,QAAQ,EAAE,CAAC,0DAA0D;;QACnG;QACA,OAAOF;IACT;IAEA,OAAO,KAAK,0BAA0B;;AACxC"}