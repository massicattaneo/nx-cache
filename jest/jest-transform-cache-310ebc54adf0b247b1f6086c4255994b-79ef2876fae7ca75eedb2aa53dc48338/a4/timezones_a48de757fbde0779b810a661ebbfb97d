ccf1aa0a5600c4a2e3e256a913fe30a6
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    TIMEZONES: function() {
        return TIMEZONES;
    },
    timezoneToLabel: function() {
        return timezoneToLabel;
    }
});
const _datefns = require("date-fns");
const _utils = require("@rp/common/utils");
const _timezonesRawList = require("./timezonesRawList");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
const getOffset = (timeZone = "UTC", date = new Date())=>{
    const utcDate = new Date(date.toLocaleString("en-US", {
        timeZone: "UTC"
    }));
    const tzDate = new Date(date.toLocaleString("en-US", {
        timeZone
    }));
    return tzDate.getTime() - utcDate.getTime();
};
const timezoneToLabel = (timezone)=>{
    var _duration_hours, _duration_minutes;
    if (timezone.offset === 0) return `(${timezone.abbreviation})`;
    const duration = (0, _datefns.intervalToDuration)({
        start: 0,
        end: timezone.offset
    });
    const hours = (_duration_hours = duration.hours) === null || _duration_hours === void 0 ? void 0 : _duration_hours.toString();
    const minutes = (_duration_minutes = duration.minutes) === null || _duration_minutes === void 0 ? void 0 : _duration_minutes.toString().padStart(2, "0");
    return timezone.offset >= 0 ? `(UTC+${hours}:${minutes})` : `(UTC-${hours}:${minutes})`;
};
const LIST = _timezonesRawList.timezonesRawList.map((tz, index)=>{
    const offset = getOffset(tz.value);
    return _object_spread_props(_object_spread({}, tz), {
        id: index.toString(),
        offset
    });
});
const HUMAN_READABLE_OFFSET_USER_TIMEZONE = _object_spread_props(_object_spread({}, _utils.USER_TIMEZONE), {
    offset: _utils.USER_TIMEZONE.offset * -1
});
const TIMEZONES = [
    HUMAN_READABLE_OFFSET_USER_TIMEZONE
].concat(LIST.filter((tz)=>tz.value !== _utils.USER_TIMEZONE.value)).sort((first, second)=>{
    if (first.offset === second.offset) {
        return first.label.localeCompare(second.label);
    }
    return first.offset - second.offset;
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL2xpYnMvd2ViL3V0aWxzL3NyYy9saWIvdGltZXpvbmVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGludGVydmFsVG9EdXJhdGlvbiB9IGZyb20gXCJkYXRlLWZuc1wiXG5pbXBvcnQgeyBVU0VSX1RJTUVaT05FIH0gZnJvbSBcIkBycC9jb21tb24vdXRpbHNcIlxuaW1wb3J0IHsgdGltZXpvbmVzUmF3TGlzdCB9IGZyb20gXCIuL3RpbWV6b25lc1Jhd0xpc3RcIlxuXG50eXBlIFRpbWV6b25lID0geyBpZDogc3RyaW5nOyBsYWJlbDogc3RyaW5nOyBhYmJyZXZpYXRpb246IHN0cmluZzsgdmFsdWU6IHN0cmluZzsgb2Zmc2V0OiBudW1iZXIgfVxuXG5jb25zdCBnZXRPZmZzZXQgPSAodGltZVpvbmUgPSBcIlVUQ1wiLCBkYXRlID0gbmV3IERhdGUoKSkgPT4ge1xuICBjb25zdCB1dGNEYXRlID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHsgdGltZVpvbmU6IFwiVVRDXCIgfSkpXG4gIGNvbnN0IHR6RGF0ZSA9IG5ldyBEYXRlKGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lIH0pKVxuICByZXR1cm4gdHpEYXRlLmdldFRpbWUoKSAtIHV0Y0RhdGUuZ2V0VGltZSgpXG59XG5cbmNvbnN0IHRpbWV6b25lVG9MYWJlbCA9ICh0aW1lem9uZTogVGltZXpvbmUpID0+IHtcbiAgaWYgKHRpbWV6b25lLm9mZnNldCA9PT0gMCkgcmV0dXJuIGAoJHt0aW1lem9uZS5hYmJyZXZpYXRpb259KWBcbiAgY29uc3QgZHVyYXRpb24gPSBpbnRlcnZhbFRvRHVyYXRpb24oeyBzdGFydDogMCwgZW5kOiB0aW1lem9uZS5vZmZzZXQgfSlcbiAgY29uc3QgaG91cnMgPSBkdXJhdGlvbi5ob3Vycz8udG9TdHJpbmcoKVxuICBjb25zdCBtaW51dGVzID0gZHVyYXRpb24ubWludXRlcz8udG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIilcbiAgcmV0dXJuIHRpbWV6b25lLm9mZnNldCA+PSAwID8gYChVVEMrJHtob3Vyc306JHttaW51dGVzfSlgIDogYChVVEMtJHtob3Vyc306JHttaW51dGVzfSlgXG59XG5cbmNvbnN0IExJU1Q6IEFycmF5PFRpbWV6b25lPiA9IHRpbWV6b25lc1Jhd0xpc3QubWFwKCh0eiwgaW5kZXgpID0+IHtcbiAgY29uc3Qgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHR6LnZhbHVlKVxuICByZXR1cm4ge1xuICAgIC4uLnR6LFxuICAgIGlkOiBpbmRleC50b1N0cmluZygpLFxuICAgIG9mZnNldCxcbiAgfVxufSlcblxuY29uc3QgSFVNQU5fUkVBREFCTEVfT0ZGU0VUX1VTRVJfVElNRVpPTkU6IFRpbWV6b25lID0ge1xuICAuLi5VU0VSX1RJTUVaT05FLFxuICBvZmZzZXQ6IFVTRVJfVElNRVpPTkUub2Zmc2V0ICogLTEsXG59XG5cbmNvbnN0IFRJTUVaT05FUyA9IFtIVU1BTl9SRUFEQUJMRV9PRkZTRVRfVVNFUl9USU1FWk9ORV1cbiAgLmNvbmNhdChMSVNULmZpbHRlcih0eiA9PiB0ei52YWx1ZSAhPT0gVVNFUl9USU1FWk9ORS52YWx1ZSkpXG4gIC5zb3J0KChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgaWYgKGZpcnN0Lm9mZnNldCA9PT0gc2Vjb25kLm9mZnNldCkge1xuICAgICAgcmV0dXJuIGZpcnN0LmxhYmVsLmxvY2FsZUNvbXBhcmUoc2Vjb25kLmxhYmVsKVxuICAgIH1cbiAgICByZXR1cm4gZmlyc3Qub2Zmc2V0IC0gc2Vjb25kLm9mZnNldFxuICB9KVxuXG5leHBvcnQgeyBUSU1FWk9ORVMsIHRpbWV6b25lVG9MYWJlbCB9XG5leHBvcnQgdHlwZSB7IFRpbWV6b25lIH1cbiJdLCJuYW1lcyI6WyJUSU1FWk9ORVMiLCJ0aW1lem9uZVRvTGFiZWwiLCJnZXRPZmZzZXQiLCJ0aW1lWm9uZSIsImRhdGUiLCJEYXRlIiwidXRjRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwidHpEYXRlIiwiZ2V0VGltZSIsInRpbWV6b25lIiwiZHVyYXRpb24iLCJvZmZzZXQiLCJhYmJyZXZpYXRpb24iLCJpbnRlcnZhbFRvRHVyYXRpb24iLCJzdGFydCIsImVuZCIsImhvdXJzIiwidG9TdHJpbmciLCJtaW51dGVzIiwicGFkU3RhcnQiLCJMSVNUIiwidGltZXpvbmVzUmF3TGlzdCIsIm1hcCIsInR6IiwiaW5kZXgiLCJ2YWx1ZSIsImlkIiwiSFVNQU5fUkVBREFCTEVfT0ZGU0VUX1VTRVJfVElNRVpPTkUiLCJVU0VSX1RJTUVaT05FIiwiY29uY2F0IiwiZmlsdGVyIiwic29ydCIsImZpcnN0Iiwic2Vjb25kIiwibGFiZWwiLCJsb2NhbGVDb21wYXJlIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztJQTJDU0EsU0FBUztlQUFUQTs7SUFBV0MsZUFBZTtlQUFmQTs7O3lCQTNDZTt1QkFDTDtrQ0FDRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJakMsTUFBTUMsWUFBWSxDQUFDQyxXQUFXLEtBQUssRUFBRUMsT0FBTyxJQUFJQyxNQUFNO0lBQ3BELE1BQU1DLFVBQVUsSUFBSUQsS0FBS0QsS0FBS0csY0FBYyxDQUFDLFNBQVM7UUFBRUosVUFBVTtJQUFNO0lBQ3hFLE1BQU1LLFNBQVMsSUFBSUgsS0FBS0QsS0FBS0csY0FBYyxDQUFDLFNBQVM7UUFBRUo7SUFBUztJQUNoRSxPQUFPSyxPQUFPQyxPQUFPLEtBQUtILFFBQVFHLE9BQU87QUFDM0M7QUFFQSxNQUFNUixrQkFBa0IsQ0FBQ1M7UUFHVEMsaUJBQ0VBO0lBSGhCLElBQUlELFNBQVNFLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUVGLFNBQVNHLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDOUQsTUFBTUYsV0FBV0csSUFBQUEsMkJBQWtCLEVBQUM7UUFBRUMsT0FBTztRQUFHQyxLQUFLTixTQUFTRSxNQUFNO0lBQUM7SUFDckUsTUFBTUssU0FBUU4sa0JBQUFBLFNBQVNNLEtBQUssY0FBZE4sc0NBQUFBLGdCQUFnQk8sUUFBUTtJQUN0QyxNQUFNQyxXQUFVUixvQkFBQUEsU0FBU1EsT0FBTyxjQUFoQlIsd0NBQUFBLGtCQUFrQk8sUUFBUSxHQUFHRSxRQUFRLENBQUMsR0FBRztJQUN6RCxPQUFPVixTQUFTRSxNQUFNLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRUssTUFBTSxDQUFDLEVBQUVFLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUVGLE1BQU0sQ0FBQyxFQUFFRSxRQUFRLENBQUMsQ0FBQztBQUN6RjtBQUVBLE1BQU1FLE9BQXdCQyxrQ0FBZ0IsQ0FBQ0MsR0FBRyxDQUFDLENBQUNDLElBQUlDO0lBQ3RELE1BQU1iLFNBQVNWLFVBQVVzQixHQUFHRSxLQUFLO0lBQ2pDLE9BQU8sd0NBQ0ZGO1FBQ0hHLElBQUlGLE1BQU1QLFFBQVE7UUFDbEJOOztBQUVKO0FBRUEsTUFBTWdCLHNDQUFnRCx3Q0FDakRDLG9CQUFhO0lBQ2hCakIsUUFBUWlCLG9CQUFhLENBQUNqQixNQUFNLEdBQUcsQ0FBQzs7QUFHbEMsTUFBTVosWUFBWTtJQUFDNEI7Q0FBb0MsQ0FDcERFLE1BQU0sQ0FBQ1QsS0FBS1UsTUFBTSxDQUFDUCxDQUFBQSxLQUFNQSxHQUFHRSxLQUFLLEtBQUtHLG9CQUFhLENBQUNILEtBQUssR0FDekRNLElBQUksQ0FBQyxDQUFDQyxPQUFPQztJQUNaLElBQUlELE1BQU1yQixNQUFNLEtBQUtzQixPQUFPdEIsTUFBTSxFQUFFO1FBQ2xDLE9BQU9xQixNQUFNRSxLQUFLLENBQUNDLGFBQWEsQ0FBQ0YsT0FBT0MsS0FBSztJQUMvQztJQUNBLE9BQU9GLE1BQU1yQixNQUFNLEdBQUdzQixPQUFPdEIsTUFBTTtBQUNyQyJ9