{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/libs/react/tanstack-api/suggestion/src/utils/groupCompanySuggestions.ts"],"sourcesContent":["import { CompanySuggestion, EnhancedSuggestion, Suggestion } from \"../suggestion.types\"\nimport { makeSuggestionId } from \"./makeSuggestionId\"\n\ntype ExtendedCompanySuggestion = CompanySuggestion & EnhancedSuggestion\ntype Subsidiaries = Array<ExtendedCompanySuggestion>\n\n// Dictionary using the ultimate parent id as keys\n// Value is the item that should be at the top, and the array of subsidiaries\ntype CompaniesMap = Record<\n  Suggestion[\"key\"],\n  {\n    parent: ExtendedCompanySuggestion\n    subsidiaries: Subsidiaries\n    position: number\n  }\n>\n\nconst isNestableSuggestion = (\n  suggestion: EnhancedSuggestion,\n): suggestion is ExtendedCompanySuggestion => {\n  return (\n    \"typeDesc\" in suggestion &&\n    suggestion.queryType === \"entity\" &&\n    suggestion.typeDesc === \"Company\"\n  )\n}\n\nconst isWatchlistOrSavedSearchSuggestion = (\n  suggestion: EnhancedSuggestion,\n): suggestion is ExtendedCompanySuggestion => {\n  return (\n    \"queryType\" in suggestion &&\n    (suggestion.queryType === \"savedSearch\" || suggestion.queryType === \"watchlist\")\n  )\n}\n\nconst retypeSubsidiaries = (subsidiaries: Array<ExtendedCompanySuggestion>) => {\n  return subsidiaries.map((suggestion, index) => {\n    return {\n      ...suggestion,\n      nested: index === subsidiaries.length - 1 ? (\"last\" as const) : (\"default\" as const),\n      typeDesc: suggestion.parent1 === undefined ? \"Company\" : \"Subsidiary\",\n    }\n  })\n}\n\nconst groupCompanySuggestions = (\n  suggestions: Array<EnhancedSuggestion>,\n  displayGroups: Array<string>,\n  showCompanySuggestions = true,\n  bannedUltimates: Array<string> = [],\n  limit = 20,\n) => {\n  let currentPosition = 0\n  const groupedSuggestions: Array<\n    EnhancedSuggestion & {\n      nested?: \"last\" | \"default\"\n      subsidiaries?: Subsidiaries\n    }\n  > = []\n  const companiesMap: CompaniesMap = {}\n\n  for (const suggestion of suggestions) {\n    // If item doesn't look like a company, just leave it on the same position\n    if (showCompanySuggestions) {\n      if (!isNestableSuggestion(suggestion)) {\n        groupedSuggestions[currentPosition] = suggestion\n        currentPosition++\n        continue\n      }\n\n      // If company doesn't have ultimate parent, it is the ultimate parent\n      if (suggestion.parent1 === undefined) {\n        // If entry doesn't exist, create it\n        if (companiesMap[suggestion.key] === undefined) {\n          companiesMap[suggestion.key] = {\n            parent: suggestion,\n            subsidiaries: [],\n            position: currentPosition,\n          }\n          currentPosition++\n        }\n        // If entry exist, replace current parent\n        else {\n          const { parent, subsidiaries, position } = companiesMap[suggestion.key]\n          const newSubsidiaries = [...subsidiaries, parent]\n          companiesMap[suggestion.key] = {\n            parent: suggestion,\n            subsidiaries: newSubsidiaries,\n            position,\n          }\n        }\n      }\n      // Rest of the companies have to fight for their spot\n      else {\n        // If entry doesn't exist, create it\n        if (companiesMap[suggestion.parent1.key] === undefined) {\n          companiesMap[suggestion.parent1.key] = {\n            parent: suggestion,\n            subsidiaries: [],\n            position: currentPosition,\n          }\n          currentPosition++\n        }\n        // If entry exist, check if it should replace\n        else {\n          const { parent, subsidiaries, position } = companiesMap[suggestion.parent1.key]\n\n          const shouldReplace =\n            (suggestion.parent2 === undefined && parent.parent2 !== undefined) ||\n            (suggestion.parent3 === undefined && parent.parent3 !== undefined)\n\n          if (shouldReplace) {\n            const newSubsidiaries = [...subsidiaries, parent]\n            companiesMap[suggestion.parent1.key] = {\n              parent: suggestion,\n              subsidiaries: newSubsidiaries,\n              position,\n            }\n          } else {\n            companiesMap[suggestion.parent1.key] = {\n              parent,\n              subsidiaries: [...subsidiaries, suggestion],\n              position,\n            }\n          }\n        }\n      }\n    } else if (isWatchlistOrSavedSearchSuggestion(suggestion)) {\n      groupedSuggestions[currentPosition] = suggestion\n      currentPosition++\n      continue\n    }\n  }\n\n  // Keep track of the positions the nested subsidiaries will appear\n  const expandedDisplayGroups: Array<[position: number, subsidiaries: Subsidiaries]> = []\n\n  // Add every grouped suggestion to the list\n  for (const key in companiesMap) {\n    const { parent, subsidiaries, position } = companiesMap[key]\n    const { parent1: ultimateParent } = parent\n\n    // If parent is not ultimate parent, add it to the sublist\n    const extendedUltimateParent =\n      ultimateParent &&\n      !bannedUltimates.includes(makeSuggestionId(ultimateParent.key, ultimateParent.queryType))\n        ? {\n            ...ultimateParent,\n            type: ultimateParent.queryType,\n            label: ultimateParent.name,\n            value: ultimateParent.key,\n            id: makeSuggestionId(ultimateParent.key, ultimateParent.queryType),\n          }\n        : undefined\n\n    const finalSubsidiaries =\n      extendedUltimateParent !== undefined\n        ? [...subsidiaries, extendedUltimateParent]\n        : subsidiaries\n\n    const finalParent = extendedUltimateParent ? { ...parent, typeDesc: \"Subsidiary\" } : parent\n\n    groupedSuggestions[position] = { ...finalParent, subsidiaries: finalSubsidiaries }\n\n    // If this cluster is going to be filtered, avoid adding it to the display groups list\n    if (displayGroups.includes(parent.id)) {\n      expandedDisplayGroups.push([position, finalSubsidiaries])\n    }\n  }\n\n  // Limit top level suggestions to 9 (+ 1 keyword)\n  const limitedGroupedSuggestions = groupedSuggestions.slice(0, limit)\n  expandedDisplayGroups.sort((a, b) => a[0] - b[0])\n\n  const finalSuggestions = expandedDisplayGroups.length\n    ? expandedDisplayGroups.reduce<typeof groupedSuggestions>((acc, item, index) => {\n        const [position, subsidiaries] = item\n\n        const previousPosition = expandedDisplayGroups[index - 1]?.[0]\n\n        const startingPoint = previousPosition !== undefined ? previousPosition + 1 : 0\n        const isLastItem = index === expandedDisplayGroups.length - 1\n\n        const endingSlice = isLastItem ? limitedGroupedSuggestions.slice(position + 1) : []\n\n        return [\n          ...acc,\n          ...limitedGroupedSuggestions.slice(startingPoint, position + 1),\n          ...retypeSubsidiaries(subsidiaries),\n          ...endingSlice,\n        ]\n      }, [])\n    : limitedGroupedSuggestions\n\n  return finalSuggestions\n}\n\nexport { groupCompanySuggestions }\n"],"names":["groupCompanySuggestions","isNestableSuggestion","suggestion","queryType","typeDesc","isWatchlistOrSavedSearchSuggestion","retypeSubsidiaries","subsidiaries","map","index","nested","length","parent1","undefined","suggestions","displayGroups","showCompanySuggestions","bannedUltimates","limit","currentPosition","groupedSuggestions","companiesMap","key","parent","position","newSubsidiaries","shouldReplace","parent2","parent3","expandedDisplayGroups","ultimateParent","extendedUltimateParent","includes","makeSuggestionId","type","label","name","value","id","finalSubsidiaries","finalParent","push","limitedGroupedSuggestions","slice","sort","a","b","finalSuggestions","reduce","acc","item","previousPosition","startingPoint","isLastItem","endingSlice"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}