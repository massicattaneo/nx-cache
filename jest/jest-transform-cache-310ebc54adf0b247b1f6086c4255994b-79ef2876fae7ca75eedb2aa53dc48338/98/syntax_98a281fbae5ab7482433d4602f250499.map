{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (default: `true`).\n *\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {}\n  let single = options_.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n            const insideSpan = context.parser.constructs.insideSpan.null\n            if (insideSpan) {\n              // Between.\n              splice(\n                nextEvents,\n                nextEvents.length,\n                0,\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\n              )\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n    return events\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous)\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n"],"names":["gfmStrikethrough","options","options_","single","singleTilde","tokenizer","tokenize","tokenizeStrikethrough","resolveAll","resolveAllStrikethrough","undefined","text","insideSpan","null","attentionMarkers","events","context","index","length","type","_close","open","_open","end","offset","start","strikethrough","Object","assign","nextEvents","parser","constructs","splice","slice","effects","ok","nok","previous","size","code","enter","more","before","classifyCharacter","consume","token","exit","after","Boolean"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}