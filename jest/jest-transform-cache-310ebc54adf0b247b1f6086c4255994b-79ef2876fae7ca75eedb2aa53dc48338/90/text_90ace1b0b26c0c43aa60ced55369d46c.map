{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark/lib/initialize/text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\nexport const resolver = {\n  resolveAll: createResolver()\n}\nexport const string = initializeFactory('string')\nexport const text = initializeFactory('text')\n\n/**\n * @param {'string' | 'text'} field\n * @returns {InitialConstruct}\n */\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Initializer}\n   */\n  function initializeText(effects) {\n    const self = this\n    const constructs = this.parser.constructs[field]\n    const text = effects.attempt(constructs, start, notText)\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    /** @type {State} */\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n\n    /** @type {State} */\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      }\n\n      // Data.\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n    function atBreak(code) {\n      if (code === null) {\n        return true\n      }\n      const list = constructs[code]\n      let index = -1\n      if (list) {\n        // Always populated by defaults.\n\n        while (++index < list.length) {\n          const item = list[index]\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true\n          }\n        }\n      }\n      return false\n    }\n  }\n}\n\n/**\n * @param {Resolver | undefined} [extraResolver]\n * @returns {Resolver}\n */\nfunction createResolver(extraResolver) {\n  return resolveAllText\n\n  /** @type {Resolver} */\n  function resolveAllText(events, context) {\n    let index = -1\n    /** @type {number | undefined} */\n    let enter\n\n    // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n        enter = undefined\n      }\n    }\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0 // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      const data = events[eventIndex - 1][1]\n      const chunks = context.sliceStream(data)\n      let index = chunks.length\n      let bufferIndex = -1\n      let size = 0\n      /** @type {boolean | undefined} */\n      let tabs\n      while (index--) {\n        const chunk = chunks[index]\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n          if (bufferIndex) break\n          bufferIndex = -1\n        }\n        // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n      if (size) {\n        const token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        }\n        data.end = Object.assign({}, token.start)\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n      eventIndex++\n    }\n  }\n  return events\n}\n"],"names":["resolver","string","text","resolveAll","createResolver","initializeFactory","field","tokenize","initializeText","resolveAllLineSuffixes","undefined","effects","self","constructs","parser","attempt","start","notText","code","atBreak","consume","enter","data","exit","list","index","length","item","previous","call","extraResolver","resolveAllText","events","context","type","end","splice","eventIndex","chunks","sliceStream","bufferIndex","size","tabs","chunk","charCodeAt","token","line","column","offset","_index","_bufferIndex","Object","assign"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}