{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/libs/react/web/common/base-components/src/ImageCutter/imageCutterUtils.ts"],"sourcesContent":["export type CroppedAreaPixels = {\n  width: number\n  height: number\n  x: number\n  y: number\n}\n\nfunction blobToBase64(blob: Blob) {\n  return new Promise<string>((resolve, reject) => {\n    const reader = new FileReader()\n    reader.readAsDataURL(blob)\n    reader.onloadend = () => {\n      if (typeof reader.result === \"string\") {\n        resolve(reader.result)\n      }\n    }\n    reader.onerror = reject\n  })\n}\n\nasync function convertObjectURLToBase64(objectURL: string) {\n  const response = await fetch(objectURL)\n  const blob = await response.blob()\n  return blobToBase64(blob)\n}\n\nexport const getCroppedImg = async (\n  imageSrc: string,\n  croppedAreaPixels: CroppedAreaPixels,\n  outputWidth: number,\n  outputHeight: number,\n  format = \"image/jpeg\",\n) => {\n  return new Promise<string>((resolve, reject) => {\n    const image = new Image()\n    image.crossOrigin = \"anonymous\" // Prevent CORS issues\n    image.src = imageSrc\n\n    image.onload = () => {\n      const canvas = document.createElement(\"canvas\")\n      const ctx = canvas.getContext(\"2d\")\n\n      if (!ctx) {\n        reject(new Error(\"Failed to get canvas context\"))\n        return\n      }\n\n      // Set canvas to fixed output size\n      canvas.width = outputWidth\n      canvas.height = outputHeight\n\n      // Scale the cropped image to fit the output resolution\n      ctx.drawImage(\n        image,\n        croppedAreaPixels.x,\n        croppedAreaPixels.y,\n        croppedAreaPixels.width,\n        croppedAreaPixels.height,\n        0,\n        0,\n        outputWidth, // Force the output width\n        outputHeight, // Force the output height\n      )\n\n      canvas.toBlob(blob => {\n        if (!blob) {\n          reject(new Error(\"Canvas toBlob failed\"))\n          return\n        }\n        const fileUrl = URL.createObjectURL(blob)\n        resolve(convertObjectURLToBase64(fileUrl))\n      }, format)\n    }\n\n    image.onerror = error => reject(error)\n  })\n}\n"],"names":["getCroppedImg","blobToBase64","blob","Promise","resolve","reject","reader","FileReader","readAsDataURL","onloadend","result","onerror","convertObjectURLToBase64","objectURL","response","fetch","imageSrc","croppedAreaPixels","outputWidth","outputHeight","format","image","Image","crossOrigin","src","onload","canvas","document","createElement","ctx","getContext","Error","width","height","drawImage","x","y","toBlob","fileUrl","URL","createObjectURL","error"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BA0BaA;;;eAAAA;;;AAnBb,SAASC,aAAaC,IAAU;IAC9B,OAAO,IAAIC,QAAgB,CAACC,SAASC;QACnC,MAAMC,SAAS,IAAIC;QACnBD,OAAOE,aAAa,CAACN;QACrBI,OAAOG,SAAS,GAAG;YACjB,IAAI,OAAOH,OAAOI,MAAM,KAAK,UAAU;gBACrCN,QAAQE,OAAOI,MAAM;YACvB;QACF;QACAJ,OAAOK,OAAO,GAAGN;IACnB;AACF;AAEA,eAAeO,yBAAyBC,SAAiB;IACvD,MAAMC,WAAW,MAAMC,MAAMF;IAC7B,MAAMX,OAAO,MAAMY,SAASZ,IAAI;IAChC,OAAOD,aAAaC;AACtB;AAEO,MAAMF,gBAAgB,OAC3BgB,UACAC,mBACAC,aACAC,cACAC,SAAS,YAAY;IAErB,OAAO,IAAIjB,QAAgB,CAACC,SAASC;QACnC,MAAMgB,QAAQ,IAAIC;QAClBD,MAAME,WAAW,GAAG,YAAY,sBAAsB;;QACtDF,MAAMG,GAAG,GAAGR;QAEZK,MAAMI,MAAM,GAAG;YACb,MAAMC,SAASC,SAASC,aAAa,CAAC;YACtC,MAAMC,MAAMH,OAAOI,UAAU,CAAC;YAE9B,IAAI,CAACD,KAAK;gBACRxB,OAAO,IAAI0B,MAAM;gBACjB;YACF;YAEA,kCAAkC;YAClCL,OAAOM,KAAK,GAAGd;YACfQ,OAAOO,MAAM,GAAGd;YAEhB,uDAAuD;YACvDU,IAAIK,SAAS,CACXb,OACAJ,kBAAkBkB,CAAC,EACnBlB,kBAAkBmB,CAAC,EACnBnB,kBAAkBe,KAAK,EACvBf,kBAAkBgB,MAAM,EACxB,GACA,GACAf,aACAC;YAGFO,OAAOW,MAAM,CAACnC,CAAAA;gBACZ,IAAI,CAACA,MAAM;oBACTG,OAAO,IAAI0B,MAAM;oBACjB;gBACF;gBACA,MAAMO,UAAUC,IAAIC,eAAe,CAACtC;gBACpCE,QAAQQ,yBAAyB0B;YACnC,GAAGlB;QACL;QAEAC,MAAMV,OAAO,GAAG8B,CAAAA,QAASpC,OAAOoC;IAClC;AACF"}