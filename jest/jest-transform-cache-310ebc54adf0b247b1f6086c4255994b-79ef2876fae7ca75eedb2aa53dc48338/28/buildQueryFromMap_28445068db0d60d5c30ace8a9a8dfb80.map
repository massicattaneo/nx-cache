{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/libs/react/rpql/src/lib/rpql-utils/buildQueryFromMap.ts"],"sourcesContent":["import {\n  isRpqlArrayFilter,\n  isRpqlFlatDateFilter,\n  isRpqlFlatExclusiveArrayBaseFilter,\n  isRpqlFlatExclusiveArrayIdBaseFilter,\n  isRpqlFlatExclusiveLogicFilter,\n  isRpqlFlatLogicalGroup,\n  isRpqlFlatLogicalNot,\n  isRpqlFlatMatchFilter,\n  isRpqlFlatRangeFilter,\n} from \"@rp/common/api-types\"\nimport { RpqlFilter, RpqlLogicalGroupFilter, RpqlLogicalNotFilter } from \"@rp/common/api-types\"\nimport { RpqlFilterMap } from \"@rp/common/api-types\"\nimport { removeNotFromOperation, removeNotFromType } from \"../helpers\"\nimport { getFilterFromMap } from \"./getFilterFromMap\"\n\nconst buildQueryFromMap = (root: string, filterMap: RpqlFilterMap): RpqlFilter => {\n  const base = getFilterFromMap(root, filterMap)\n\n  if (base === null) {\n    // This should never happen since `buildQuery` is internal and only ever called\n    // with the root ID.\n    throw new Error(\"Attempting to build filter from non-existent root\")\n  }\n\n  if (isRpqlFlatLogicalNot(base)) {\n    return {\n      type: \"not\",\n      value: buildQueryFromMap(base.value, filterMap),\n    }\n  }\n\n  if (isRpqlFlatMatchFilter(base)) {\n    const { id: _id, ...rest } = base\n\n    return {\n      ...rest,\n      value: base.value.map(v => {\n        const child = buildQueryFromMap(v, filterMap)\n        if (!isRpqlArrayFilter(child)) {\n          // This is only while MatchFilters === Macro search\n          throw new Error(\"Match Filter only accepts ArrayFilters inside\")\n        }\n        return child\n      }),\n    }\n  }\n\n  if (isRpqlFlatLogicalGroup(base)) {\n    if (isRpqlFlatExclusiveLogicFilter(base)) {\n      const child: RpqlLogicalGroupFilter = {\n        type: removeNotFromType(base.type),\n        value: base.value.map(v => buildQueryFromMap(v, filterMap)),\n      }\n      const result: RpqlLogicalNotFilter = {\n        type: \"not\",\n        value: child,\n      }\n\n      return result\n    }\n\n    const { id: _id, ...rest } = base\n\n    return {\n      ...rest,\n      value: base.value.map(v => buildQueryFromMap(v, filterMap)),\n    }\n  }\n\n  if (isRpqlFlatExclusiveArrayBaseFilter(base) || isRpqlFlatExclusiveArrayIdBaseFilter(base)) {\n    const { id: _id, ...rest } = base\n    return {\n      type: \"not\",\n      value: {\n        ...rest,\n        operation: removeNotFromOperation(base.operation),\n      },\n    }\n  }\n\n  if (isRpqlFlatRangeFilter(base)) {\n    const rangeFilter = {\n      type: base.type,\n      start: base.value[0],\n      end: base.value[1],\n    }\n\n    if (base.operation === \"between\") {\n      return rangeFilter\n    }\n\n    return {\n      type: \"not\",\n      value: rangeFilter,\n    }\n  }\n  if (isRpqlFlatDateFilter(base)) {\n    return Array.isArray(base.value)\n      ? {\n          type: \"date\",\n          operation: \"between\",\n          value: [base.value[0], base.value[1]],\n        }\n      : { type: \"date\", value: base.value }\n  }\n\n  const { id: _id, ...rest } = base\n  return rest\n}\n\nexport { buildQueryFromMap }\n"],"names":["buildQueryFromMap","root","filterMap","base","getFilterFromMap","Error","isRpqlFlatLogicalNot","type","value","isRpqlFlatMatchFilter","id","_id","rest","map","v","child","isRpqlArrayFilter","isRpqlFlatLogicalGroup","isRpqlFlatExclusiveLogicFilter","removeNotFromType","result","isRpqlFlatExclusiveArrayBaseFilter","isRpqlFlatExclusiveArrayIdBaseFilter","operation","removeNotFromOperation","isRpqlFlatRangeFilter","rangeFilter","start","end","isRpqlFlatDateFilter","Array","isArray"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BA+GSA;;;eAAAA;;;0BArGF;yBAGmD;kCACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEjC,MAAMA,oBAAoB,CAACC,MAAcC;IACvC,MAAMC,OAAOC,IAAAA,kCAAgB,EAACH,MAAMC;IAEpC,IAAIC,SAAS,MAAM;QACjB,+EAA+E;QAC/E,oBAAoB;QACpB,MAAM,IAAIE,MAAM;IAClB;IAEA,IAAIC,IAAAA,8BAAoB,EAACH,OAAO;QAC9B,OAAO;YACLI,MAAM;YACNC,OAAOR,kBAAkBG,KAAKK,KAAK,EAAEN;QACvC;IACF;IAEA,IAAIO,IAAAA,+BAAqB,EAACN,OAAO;QAC/B,MAAM,EAAEO,IAAIC,GAAG,EAAW,GAAGR,MAATS,kCAAST;YAArBO;;QAER,OAAO,wCACFE;YACHJ,OAAOL,KAAKK,KAAK,CAACK,GAAG,CAACC,CAAAA;gBACpB,MAAMC,QAAQf,kBAAkBc,GAAGZ;gBACnC,IAAI,CAACc,IAAAA,2BAAiB,EAACD,QAAQ;oBAC7B,mDAAmD;oBACnD,MAAM,IAAIV,MAAM;gBAClB;gBACA,OAAOU;YACT;;IAEJ;IAEA,IAAIE,IAAAA,gCAAsB,EAACd,OAAO;QAChC,IAAIe,IAAAA,wCAA8B,EAACf,OAAO;YACxC,MAAMY,QAAgC;gBACpCR,MAAMY,IAAAA,0BAAiB,EAAChB,KAAKI,IAAI;gBACjCC,OAAOL,KAAKK,KAAK,CAACK,GAAG,CAACC,CAAAA,IAAKd,kBAAkBc,GAAGZ;YAClD;YACA,MAAMkB,SAA+B;gBACnCb,MAAM;gBACNC,OAAOO;YACT;YAEA,OAAOK;QACT;QAEA,MAAM,EAAEV,IAAIC,GAAG,EAAW,GAAGR,MAATS,kCAAST;YAArBO;;QAER,OAAO,wCACFE;YACHJ,OAAOL,KAAKK,KAAK,CAACK,GAAG,CAACC,CAAAA,IAAKd,kBAAkBc,GAAGZ;;IAEpD;IAEA,IAAImB,IAAAA,4CAAkC,EAAClB,SAASmB,IAAAA,8CAAoC,EAACnB,OAAO;QAC1F,MAAM,EAAEO,IAAIC,GAAG,EAAW,GAAGR,MAATS,kCAAST;YAArBO;;QACR,OAAO;YACLH,MAAM;YACNC,OAAO,wCACFI;gBACHW,WAAWC,IAAAA,+BAAsB,EAACrB,KAAKoB,SAAS;;QAEpD;IACF;IAEA,IAAIE,IAAAA,+BAAqB,EAACtB,OAAO;QAC/B,MAAMuB,cAAc;YAClBnB,MAAMJ,KAAKI,IAAI;YACfoB,OAAOxB,KAAKK,KAAK,CAAC,EAAE;YACpBoB,KAAKzB,KAAKK,KAAK,CAAC,EAAE;QACpB;QAEA,IAAIL,KAAKoB,SAAS,KAAK,WAAW;YAChC,OAAOG;QACT;QAEA,OAAO;YACLnB,MAAM;YACNC,OAAOkB;QACT;IACF;IACA,IAAIG,IAAAA,8BAAoB,EAAC1B,OAAO;QAC9B,OAAO2B,MAAMC,OAAO,CAAC5B,KAAKK,KAAK,IAC3B;YACED,MAAM;YACNgB,WAAW;YACXf,OAAO;gBAACL,KAAKK,KAAK,CAAC,EAAE;gBAAEL,KAAKK,KAAK,CAAC,EAAE;aAAC;QACvC,IACA;YAAED,MAAM;YAAQC,OAAOL,KAAKK,KAAK;QAAC;IACxC;IAEA,MAAM,EAAEE,IAAIC,GAAG,EAAW,GAAGR,MAATS,kCAAST;QAArBO;;IACR,OAAOE;AACT"}