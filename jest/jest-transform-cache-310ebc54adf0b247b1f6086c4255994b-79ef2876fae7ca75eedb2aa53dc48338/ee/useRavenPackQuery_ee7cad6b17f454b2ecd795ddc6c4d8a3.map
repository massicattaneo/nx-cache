{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/libs/react/rpql/src/lib/useRavenPackQuery.ts"],"sourcesContent":["import { useEffect, useMemo, useState } from \"react\"\nimport {\n  RpqlFilter,\n  RpqlFilterMap,\n  RpqlFlatFilter,\n  isRpqlFlatLogicalGroup,\n} from \"@rp/common/api-types\"\nimport { generateId } from \"./helpers\"\nimport { addFilterToMap } from \"./rpql-utils/addFilterToMap\"\nimport { buildQueryFromMap } from \"./rpql-utils/buildQueryFromMap\"\nimport { collectFiltersFromLogicalGroups } from \"./rpql-utils/collectFiltersFromLogicalGroups\"\nimport { flattenQuery } from \"./rpql-utils/flattenQuery\"\nimport { generateMapBuilder } from \"./rpql-utils/generateMapBuilder\"\nimport { getFilterFromMap } from \"./rpql-utils/getFilterFromMap\"\nimport { removeFiltersFromMap } from \"./rpql-utils/removeFiltersFromMap\"\nimport { UpdateSignature, updateFilterInMap } from \"./rpql-utils/updateFilterInMap\"\n\nconst useRavenPackQuery = (query: RpqlFilter) => {\n  const flat = useMemo(() => flattenQuery(query), [query])\n  const [filterMap, setFilterMap] = useState(flat.filterMap)\n  const [root, setRoot] = useState(flat.root)\n  const [expression, setExpression] = useState<RpqlFilter>(buildQueryFromMap(root, filterMap))\n\n  const getFilter = <TFilter extends RpqlFlatFilter = RpqlFlatFilter>(id: string) =>\n    getFilterFromMap<TFilter>(id, filterMap)\n\n  const findChild = (nodeId: string, condition: (filter: RpqlFlatFilter) => boolean) => {\n    const rootNode = getFilter(nodeId)\n\n    if (rootNode === null) {\n      throw new Error(\"Attempting to find child to non-existant node\")\n    }\n\n    if (!isRpqlFlatLogicalGroup(rootNode)) {\n      throw new Error(\"Unable to find child in non-logical filters\")\n    }\n\n    const childId = rootNode.value.find(cid => {\n      const childFilter = getFilter(cid)\n      if (childFilter === null) {\n        // This is another case where this should never happen since everything\n        // is handled internally\n        return false\n      }\n      return condition(childFilter)\n    })\n\n    if (childId === undefined) {\n      return null\n    }\n\n    return getFilter(childId)\n  }\n\n  const addFilter = (parentId: string, filter: RpqlFilter) => {\n    const parentFilter = getFilter(parentId)\n    const { map, error } = addFilterToMap(filterMap, parentFilter, filter)\n    if (error) throw new Error(error)\n    setFilterMap(map)\n    return buildQueryFromMap(root, map)\n  }\n\n  const removeFilter = (idToRemove: string) => {\n    const allFilters = collectFiltersFromLogicalGroups([idToRemove], getFilter)\n    const { map, error } = removeFiltersFromMap(filterMap, allFilters, root)\n    if (error) throw new Error(error)\n    setFilterMap(map)\n    return buildQueryFromMap(root, map)\n  }\n\n  const updateFilter = <TFilter extends RpqlFlatFilter = RpqlFlatFilter>(\n    filterId: string,\n    update: UpdateSignature<TFilter>,\n  ) => {\n    const filter = getFilter<TFilter>(filterId)\n    const { map, error } = updateFilterInMap(filterMap, filter, update)\n    if (error) throw new Error(error)\n    setFilterMap(map)\n    return buildQueryFromMap(root, map)\n  }\n\n  const clear = () => {\n    const newRoot = generateId()\n    setRoot(newRoot)\n    const newFilterMap: RpqlFilterMap = { [newRoot]: { id: newRoot, type: \"and\", value: [] } }\n    setFilterMap(newFilterMap)\n    return buildQueryFromMap(newRoot, newFilterMap)\n  }\n\n  const resetExpression = (newExpression: RpqlFilter) => {\n    const flat = flattenQuery(newExpression)\n\n    setFilterMap(flat.filterMap)\n    setRoot(flat.root)\n    return buildQueryFromMap(root, filterMap)\n  }\n\n  const builder = generateMapBuilder(root, filterMap, setFilterMap)\n\n  useEffect(() => {\n    setExpression(buildQueryFromMap(root, filterMap))\n  }, [root, filterMap])\n\n  return {\n    root,\n    filterMap,\n    expression,\n    resetExpression,\n    getFilter,\n    addFilter,\n    findChild,\n    removeFilter,\n    updateFilter,\n    clear,\n    builder,\n  }\n}\n\nexport { useRavenPackQuery }\n"],"names":["useRavenPackQuery","query","flat","useMemo","flattenQuery","filterMap","setFilterMap","useState","root","setRoot","expression","setExpression","buildQueryFromMap","getFilter","id","getFilterFromMap","findChild","nodeId","condition","rootNode","Error","isRpqlFlatLogicalGroup","childId","value","find","cid","childFilter","undefined","addFilter","parentId","filter","parentFilter","map","error","addFilterToMap","removeFilter","idToRemove","allFilters","collectFiltersFromLogicalGroups","removeFiltersFromMap","updateFilter","filterId","update","updateFilterInMap","clear","newRoot","generateId","newFilterMap","type","resetExpression","newExpression","builder","generateMapBuilder","useEffect"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}