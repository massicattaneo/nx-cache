{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark/lib/create-tokenizer.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * @callback Restore\n * @returns {undefined}\n *\n * @typedef Info\n * @property {Restore} restore\n * @property {number} from\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n * @param {Info} info\n * @returns {undefined}\n */\n\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesn’t receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n * @param {InitialConstruct} initialize\n * @param {Omit<Point, '_bufferIndex' | '_index'> | undefined} [from]\n * @returns {TokenizeContext}\n */\nexport function createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  let point = Object.assign(\n    from\n      ? Object.assign({}, from)\n      : {\n          line: 1,\n          column: 1,\n          offset: 0\n        },\n    {\n      _index: 0,\n      _bufferIndex: -1\n    }\n  )\n  /** @type {Record<string, number>} */\n  const columnStart = {}\n  /** @type {Array<Construct>} */\n  const resolveAllConstructs = []\n  /** @type {Array<Chunk>} */\n  let chunks = []\n  /** @type {Array<Token>} */\n  let stack = []\n  /** @type {boolean | undefined} */\n  let consumed = true\n\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n  const effects = {\n    consume,\n    enter,\n    exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    })\n  }\n\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n  const context = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser,\n    sliceStream,\n    sliceSerialize,\n    now,\n    defineSkip,\n    write\n  }\n\n  /**\n   * The state function.\n   *\n   * @type {State | undefined}\n   */\n  let state = initialize.tokenize.call(context, effects)\n\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n  let expectedCode\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  }\n  return context\n\n  /** @type {TokenizeContext['write']} */\n  function write(slice) {\n    chunks = push(chunks, slice)\n    main()\n\n    // Exit if we’re not done, resolve might change stuff.\n    if (chunks[chunks.length - 1] !== null) {\n      return []\n    }\n    addResult(initialize, 0)\n\n    // Otherwise, resolve, and exit.\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n    return context.events\n  }\n\n  //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs)\n  }\n\n  /** @type {TokenizeContext['sliceStream']} */\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n\n  /** @type {TokenizeContext['now']} */\n  function now() {\n    // This is a hot path, so we clone manually instead of `Object.assign({}, point)`\n    const {line, column, offset, _index, _bufferIndex} = point\n    return {\n      line,\n      column,\n      offset,\n      _index,\n      _bufferIndex\n    }\n  }\n\n  /** @type {TokenizeContext['defineSkip']} */\n  function defineSkip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n  }\n\n  //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {undefined}\n   */\n  function main() {\n    /** @type {number} */\n    let chunkIndex\n    while (point._index < chunks.length) {\n      const chunk = chunks[point._index]\n\n      // If we’re in a buffer chunk, loop through it.\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  }\n\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   * @returns {undefined}\n   */\n  function go(code) {\n    consumed = undefined\n    expectedCode = code\n    state = state(code)\n  }\n\n  /** @type {Effects['consume']} */\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === -3 ? 2 : 1\n      accountForPotentialSkip()\n    } else if (code !== -1) {\n      point.column++\n      point.offset++\n    }\n\n    // Not in a string chunk.\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++\n\n      // At end of string chunk.\n      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference\n      // strings.\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    }\n\n    // Expose the previous character.\n    context.previous = code\n\n    // Mark as consumed.\n    consumed = true\n  }\n\n  /** @type {Effects['enter']} */\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    const token = fields || {}\n    token.type = type\n    token.start = now()\n    context.events.push(['enter', token, context])\n    stack.push(token)\n    return token\n  }\n\n  /** @type {Effects['exit']} */\n  function exit(type) {\n    const token = stack.pop()\n    token.end = now()\n    context.events.push(['exit', token, context])\n    return token\n  }\n\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  }\n\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulcheck(_, info) {\n    info.restore()\n  }\n\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   * @param {{interrupt?: boolean | undefined} | undefined} [fields]\n   */\n  function constructFactory(onreturn, fields) {\n    return hook\n\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Array<Construct> | Construct | ConstructRecord} constructs\n     * @param {State} returnState\n     * @param {State | undefined} [bogusState]\n     * @returns {State}\n     */\n    function hook(constructs, returnState, bogusState) {\n      /** @type {Array<Construct>} */\n      let listOfConstructs\n      /** @type {number} */\n      let constructIndex\n      /** @type {Construct} */\n      let currentConstruct\n      /** @type {Info} */\n      let info\n      return Array.isArray(constructs) /* c8 ignore next 1 */\n        ? handleListOfConstructs(constructs)\n        : 'tokenize' in constructs\n        ? // @ts-expect-error Looks like a construct.\n          handleListOfConstructs([constructs])\n        : handleMapOfConstructs(constructs)\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       * @returns {State}\n       */\n      function handleMapOfConstructs(map) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          const def = code !== null && map[code]\n          const all = code !== null && map.null\n          const list = [\n            // To do: add more extension tests.\n            /* c8 ignore next 2 */\n            ...(Array.isArray(def) ? def : def ? [def] : []),\n            ...(Array.isArray(all) ? all : all ? [all] : [])\n          ]\n          return handleListOfConstructs(list)(code)\n        }\n      }\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {Array<Construct>} list\n       * @returns {State}\n       */\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n        if (list.length === 0) {\n          return bogusState\n        }\n        return handleConstruct(list[constructIndex])\n      }\n\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       * @returns {State}\n       */\n      function handleConstruct(construct) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesn’t work because `inspect` in document does a check\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          // Always populated by defaults.\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.includes(construct.name)\n          ) {\n            return nok(code)\n          }\n          return construct.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a “live binding”, which is needed for `interrupt`.\n            fields ? Object.assign(Object.create(context), fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n\n      /** @type {State} */\n      function ok(code) {\n        consumed = true\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n\n      /** @type {State} */\n      function nok(code) {\n        consumed = true\n        info.restore()\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n        return bogusState\n      }\n    }\n  }\n\n  /**\n   * @param {Construct} construct\n   * @param {number} from\n   * @returns {undefined}\n   */\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct)\n    }\n    if (construct.resolve) {\n      splice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n  }\n\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   */\n  function store() {\n    const startPoint = now()\n    const startPrevious = context.previous\n    const startCurrentConstruct = context.currentConstruct\n    const startEventsIndex = context.events.length\n    const startStack = Array.from(stack)\n    return {\n      restore,\n      from: startEventsIndex\n    }\n\n    /**\n     * Restore state.\n     *\n     * @returns {undefined}\n     */\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n    }\n  }\n\n  /**\n   * Move the current point a bit forward in the line when it’s on a column\n   * skip.\n   *\n   * @returns {undefined}\n   */\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {Array<Chunk>} chunks\n * @param {Pick<Token, 'end' | 'start'>} token\n * @returns {Array<Chunk>}\n */\nfunction sliceChunks(chunks, token) {\n  const startIndex = token.start._index\n  const startBufferIndex = token.start._bufferIndex\n  const endIndex = token.end._index\n  const endBufferIndex = token.end._bufferIndex\n  /** @type {Array<Chunk>} */\n  let view\n  if (startIndex === endIndex) {\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n    if (startBufferIndex > -1) {\n      const head = view[0]\n      if (typeof head === 'string') {\n        view[0] = head.slice(startBufferIndex)\n      } else {\n        view.shift()\n      }\n    }\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n  return view\n}\n\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @param {boolean | undefined} [expandTabs=false]\n * @returns {string}\n */\nfunction serializeChunks(chunks, expandTabs) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case -5: {\n          value = '\\r'\n          break\n        }\n        case -4: {\n          value = '\\n'\n          break\n        }\n        case -3: {\n          value = '\\r' + '\\n'\n          break\n        }\n        case -2: {\n          value = expandTabs ? ' ' : '\\t'\n          break\n        }\n        case -1: {\n          if (!expandTabs && atTab) continue\n          value = ' '\n          break\n        }\n        default: {\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk)\n        }\n      }\n    atTab = chunk === -2\n    result.push(value)\n  }\n  return result.join('')\n}\n"],"names":["createTokenizer","parser","initialize","from","point","Object","assign","line","column","offset","_index","_bufferIndex","columnStart","resolveAllConstructs","chunks","stack","consumed","effects","consume","enter","exit","attempt","constructFactory","onsuccessfulconstruct","check","onsuccessfulcheck","interrupt","context","previous","code","containerState","events","sliceStream","sliceSerialize","now","defineSkip","write","state","tokenize","call","expectedCode","resolveAll","push","slice","main","length","addResult","token","expandTabs","serializeChunks","sliceChunks","value","accountForPotentialSkip","chunkIndex","chunk","go","charCodeAt","undefined","markdownLineEnding","type","fields","start","pop","end","construct","info","_","restore","onreturn","hook","constructs","returnState","bogusState","listOfConstructs","constructIndex","currentConstruct","Array","isArray","handleListOfConstructs","handleMapOfConstructs","map","def","all","null","list","handleConstruct","store","partial","name","disable","includes","nok","create","ok","resolve","splice","resolveTo","startPoint","startPrevious","startCurrentConstruct","startEventsIndex","startStack","startIndex","startBufferIndex","endIndex","endBufferIndex","view","head","shift","index","result","atTab","String","fromCharCode","join"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}