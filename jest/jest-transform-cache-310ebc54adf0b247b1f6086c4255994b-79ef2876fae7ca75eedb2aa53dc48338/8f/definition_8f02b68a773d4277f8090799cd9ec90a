8fe6b318bceb3b89c448ffcba6dd42f2
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "definition", {
    enumerable: true,
    get: function() {
        return definition;
    }
});
const _micromarkfactorydestination = require("micromark-factory-destination");
const _micromarkfactorylabel = require("micromark-factory-label");
const _micromarkfactoryspace = require("micromark-factory-space");
const _micromarkfactorytitle = require("micromark-factory-title");
const _micromarkfactorywhitespace = require("micromark-factory-whitespace");
const _micromarkutilcharacter = require("micromark-util-character");
const _micromarkutilnormalizeidentifier = require("micromark-util-normalize-identifier");
const definition = {
    name: 'definition',
    tokenize: tokenizeDefinition
};
/** @type {Construct} */ const titleBefore = {
    tokenize: tokenizeTitleBefore,
    partial: true
};
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeDefinition(effects, ok, nok) {
    const self = this;
    /** @type {string} */ let identifier;
    return start;
    /**
   * At start of a definition.
   *
   * ```markdown
   * > | [a]: b "c"
   *     ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        // Do not interrupt paragraphs (but do follow definitions).
        // To do: do `interrupt` the way `markdown-rs` does.
        // To do: parse whitespace the way `markdown-rs` does.
        effects.enter('definition');
        return before(code);
    }
    /**
   * After optional whitespace, at `[`.
   *
   * ```markdown
   * > | [a]: b "c"
   *     ^
   * ```
   *
   * @type {State}
   */ function before(code) {
        // To do: parse whitespace the way `markdown-rs` does.
        return _micromarkfactorylabel.factoryLabel.call(self, effects, labelAfter, // Note: we don’t need to reset the way `markdown-rs` does.
        nok, 'definitionLabel', 'definitionLabelMarker', 'definitionLabelString')(code);
    }
    /**
   * After label.
   *
   * ```markdown
   * > | [a]: b "c"
   *        ^
   * ```
   *
   * @type {State}
   */ function labelAfter(code) {
        identifier = (0, _micromarkutilnormalizeidentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));
        if (code === 58) {
            effects.enter('definitionMarker');
            effects.consume(code);
            effects.exit('definitionMarker');
            return markerAfter;
        }
        return nok(code);
    }
    /**
   * After marker.
   *
   * ```markdown
   * > | [a]: b "c"
   *         ^
   * ```
   *
   * @type {State}
   */ function markerAfter(code) {
        // Note: whitespace is optional.
        return (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkfactorywhitespace.factoryWhitespace)(effects, destinationBefore)(code) : destinationBefore(code);
    }
    /**
   * Before destination.
   *
   * ```markdown
   * > | [a]: b "c"
   *          ^
   * ```
   *
   * @type {State}
   */ function destinationBefore(code) {
        return (0, _micromarkfactorydestination.factoryDestination)(effects, destinationAfter, // Note: we don’t need to reset the way `markdown-rs` does.
        nok, 'definitionDestination', 'definitionDestinationLiteral', 'definitionDestinationLiteralMarker', 'definitionDestinationRaw', 'definitionDestinationString')(code);
    }
    /**
   * After destination.
   *
   * ```markdown
   * > | [a]: b "c"
   *           ^
   * ```
   *
   * @type {State}
   */ function destinationAfter(code) {
        return effects.attempt(titleBefore, after, after)(code);
    }
    /**
   * After definition.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */ function after(code) {
        return (0, _micromarkutilcharacter.markdownSpace)(code) ? (0, _micromarkfactoryspace.factorySpace)(effects, afterWhitespace, 'whitespace')(code) : afterWhitespace(code);
    }
    /**
   * After definition, after optional whitespace.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */ function afterWhitespace(code) {
        if (code === null || (0, _micromarkutilcharacter.markdownLineEnding)(code)) {
            effects.exit('definition');
            // Note: we don’t care about uniqueness.
            // It’s likely that that doesn’t happen very frequently.
            // It is more likely that it wastes precious time.
            self.parser.defined.push(identifier);
            // To do: `markdown-rs` interrupt.
            // // You’d be interrupting.
            // tokenizer.interrupt = true
            return ok(code);
        }
        return nok(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeTitleBefore(effects, ok, nok) {
    return titleBefore;
    /**
   * After destination, at whitespace.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *           ^
   * ```
   *
   * @type {State}
   */ function titleBefore(code) {
        return (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkfactorywhitespace.factoryWhitespace)(effects, beforeMarker)(code) : nok(code);
    }
    /**
   * At title.
   *
   * ```markdown
   *   | [a]: b
   * > | "c"
   *     ^
   * ```
   *
   * @type {State}
   */ function beforeMarker(code) {
        return (0, _micromarkfactorytitle.factoryTitle)(effects, titleAfter, nok, 'definitionTitle', 'definitionTitleMarker', 'definitionTitleString')(code);
    }
    /**
   * After title.
   *
   * ```markdown
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */ function titleAfter(code) {
        return (0, _micromarkutilcharacter.markdownSpace)(code) ? (0, _micromarkfactoryspace.factorySpace)(effects, titleAfterOptionalWhitespace, 'whitespace')(code) : titleAfterOptionalWhitespace(code);
    }
    /**
   * After title, after optional whitespace.
   *
   * ```markdown
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */ function titleAfterOptionalWhitespace(code) {
        return code === null || (0, _micromarkutilcharacter.markdownLineEnding)(code) ? ok(code) : nok(code);
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9taWNyb21hcmstY29yZS1jb21tb25tYXJrL2xpYi9kZWZpbml0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db25zdHJ1Y3R9IENvbnN0cnVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqL1xuXG5pbXBvcnQge2ZhY3RvcnlEZXN0aW5hdGlvbn0gZnJvbSAnbWljcm9tYXJrLWZhY3RvcnktZGVzdGluYXRpb24nXG5pbXBvcnQge2ZhY3RvcnlMYWJlbH0gZnJvbSAnbWljcm9tYXJrLWZhY3RvcnktbGFiZWwnXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge2ZhY3RvcnlUaXRsZX0gZnJvbSAnbWljcm9tYXJrLWZhY3RvcnktdGl0bGUnXG5pbXBvcnQge2ZhY3RvcnlXaGl0ZXNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS13aGl0ZXNwYWNlJ1xuaW1wb3J0IHtcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93blNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7bm9ybWFsaXplSWRlbnRpZmllcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXInXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmV4cG9ydCBjb25zdCBkZWZpbml0aW9uID0ge1xuICBuYW1lOiAnZGVmaW5pdGlvbicsXG4gIHRva2VuaXplOiB0b2tlbml6ZURlZmluaXRpb25cbn1cblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3R9ICovXG5jb25zdCB0aXRsZUJlZm9yZSA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplVGl0bGVCZWZvcmUsXG4gIHBhcnRpYWw6IHRydWVcbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVEZWZpbml0aW9uKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBpZGVudGlmaWVyXG4gIHJldHVybiBzdGFydFxuXG4gIC8qKlxuICAgKiBBdCBzdGFydCBvZiBhIGRlZmluaXRpb24uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV06IGIgXCJjXCJcbiAgICogICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAvLyBEbyBub3QgaW50ZXJydXB0IHBhcmFncmFwaHMgKGJ1dCBkbyBmb2xsb3cgZGVmaW5pdGlvbnMpLlxuICAgIC8vIFRvIGRvOiBkbyBgaW50ZXJydXB0YCB0aGUgd2F5IGBtYXJrZG93bi1yc2AgZG9lcy5cbiAgICAvLyBUbyBkbzogcGFyc2Ugd2hpdGVzcGFjZSB0aGUgd2F5IGBtYXJrZG93bi1yc2AgZG9lcy5cbiAgICBlZmZlY3RzLmVudGVyKCdkZWZpbml0aW9uJylcbiAgICByZXR1cm4gYmVmb3JlKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgb3B0aW9uYWwgd2hpdGVzcGFjZSwgYXQgYFtgLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW2FdOiBiIFwiY1wiXG4gICAqICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBiZWZvcmUoY29kZSkge1xuICAgIC8vIFRvIGRvOiBwYXJzZSB3aGl0ZXNwYWNlIHRoZSB3YXkgYG1hcmtkb3duLXJzYCBkb2VzLlxuXG4gICAgcmV0dXJuIGZhY3RvcnlMYWJlbC5jYWxsKFxuICAgICAgc2VsZixcbiAgICAgIGVmZmVjdHMsXG4gICAgICBsYWJlbEFmdGVyLFxuICAgICAgLy8gTm90ZTogd2UgZG9u4oCZdCBuZWVkIHRvIHJlc2V0IHRoZSB3YXkgYG1hcmtkb3duLXJzYCBkb2VzLlxuICAgICAgbm9rLFxuICAgICAgJ2RlZmluaXRpb25MYWJlbCcsXG4gICAgICAnZGVmaW5pdGlvbkxhYmVsTWFya2VyJyxcbiAgICAgICdkZWZpbml0aW9uTGFiZWxTdHJpbmcnXG4gICAgKShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGxhYmVsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW2FdOiBiIFwiY1wiXG4gICAqICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBsYWJlbEFmdGVyKGNvZGUpIHtcbiAgICBpZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgIHNlbGYuc2xpY2VTZXJpYWxpemUoc2VsZi5ldmVudHNbc2VsZi5ldmVudHMubGVuZ3RoIC0gMV1bMV0pLnNsaWNlKDEsIC0xKVxuICAgIClcbiAgICBpZiAoY29kZSA9PT0gNTgpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2RlZmluaXRpb25NYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2RlZmluaXRpb25NYXJrZXInKVxuICAgICAgcmV0dXJuIG1hcmtlckFmdGVyXG4gICAgfVxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBtYXJrZXIuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV06IGIgXCJjXCJcbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBtYXJrZXJBZnRlcihjb2RlKSB7XG4gICAgLy8gTm90ZTogd2hpdGVzcGFjZSBpcyBvcHRpb25hbC5cbiAgICByZXR1cm4gbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICAgPyBmYWN0b3J5V2hpdGVzcGFjZShlZmZlY3RzLCBkZXN0aW5hdGlvbkJlZm9yZSkoY29kZSlcbiAgICAgIDogZGVzdGluYXRpb25CZWZvcmUoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgZGVzdGluYXRpb24uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV06IGIgXCJjXCJcbiAgICogICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZGVzdGluYXRpb25CZWZvcmUoY29kZSkge1xuICAgIHJldHVybiBmYWN0b3J5RGVzdGluYXRpb24oXG4gICAgICBlZmZlY3RzLFxuICAgICAgZGVzdGluYXRpb25BZnRlcixcbiAgICAgIC8vIE5vdGU6IHdlIGRvbuKAmXQgbmVlZCB0byByZXNldCB0aGUgd2F5IGBtYXJrZG93bi1yc2AgZG9lcy5cbiAgICAgIG5vayxcbiAgICAgICdkZWZpbml0aW9uRGVzdGluYXRpb24nLFxuICAgICAgJ2RlZmluaXRpb25EZXN0aW5hdGlvbkxpdGVyYWwnLFxuICAgICAgJ2RlZmluaXRpb25EZXN0aW5hdGlvbkxpdGVyYWxNYXJrZXInLFxuICAgICAgJ2RlZmluaXRpb25EZXN0aW5hdGlvblJhdycsXG4gICAgICAnZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nJ1xuICAgICkoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZXN0aW5hdGlvbi5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXTogYiBcImNcIlxuICAgKiAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZGVzdGluYXRpb25BZnRlcihjb2RlKSB7XG4gICAgcmV0dXJuIGVmZmVjdHMuYXR0ZW1wdCh0aXRsZUJlZm9yZSwgYWZ0ZXIsIGFmdGVyKShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGRlZmluaXRpb24uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV06IGJcbiAgICogICAgICAgICAgIF5cbiAgICogPiB8IFthXTogYiBcImNcIlxuICAgKiAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICByZXR1cm4gbWFya2Rvd25TcGFjZShjb2RlKVxuICAgICAgPyBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYWZ0ZXJXaGl0ZXNwYWNlLCAnd2hpdGVzcGFjZScpKGNvZGUpXG4gICAgICA6IGFmdGVyV2hpdGVzcGFjZShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGRlZmluaXRpb24sIGFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV06IGJcbiAgICogICAgICAgICAgIF5cbiAgICogPiB8IFthXTogYiBcImNcIlxuICAgKiAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGFmdGVyV2hpdGVzcGFjZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2RlZmluaXRpb24nKVxuXG4gICAgICAvLyBOb3RlOiB3ZSBkb27igJl0IGNhcmUgYWJvdXQgdW5pcXVlbmVzcy5cbiAgICAgIC8vIEl04oCZcyBsaWtlbHkgdGhhdCB0aGF0IGRvZXNu4oCZdCBoYXBwZW4gdmVyeSBmcmVxdWVudGx5LlxuICAgICAgLy8gSXQgaXMgbW9yZSBsaWtlbHkgdGhhdCBpdCB3YXN0ZXMgcHJlY2lvdXMgdGltZS5cbiAgICAgIHNlbGYucGFyc2VyLmRlZmluZWQucHVzaChpZGVudGlmaWVyKVxuXG4gICAgICAvLyBUbyBkbzogYG1hcmtkb3duLXJzYCBpbnRlcnJ1cHQuXG4gICAgICAvLyAvLyBZb3XigJlkIGJlIGludGVycnVwdGluZy5cbiAgICAgIC8vIHRva2VuaXplci5pbnRlcnJ1cHQgPSB0cnVlXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplVGl0bGVCZWZvcmUoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gdGl0bGVCZWZvcmVcblxuICAvKipcbiAgICogQWZ0ZXIgZGVzdGluYXRpb24sIGF0IHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbYV06IGJcbiAgICogICAgICAgICAgIF5cbiAgICogPiB8IFthXTogYiBcImNcIlxuICAgKiAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gdGl0bGVCZWZvcmUoY29kZSkge1xuICAgIHJldHVybiBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgICA/IGZhY3RvcnlXaGl0ZXNwYWNlKGVmZmVjdHMsIGJlZm9yZU1hcmtlcikoY29kZSlcbiAgICAgIDogbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQXQgdGl0bGUuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCBbYV06IGJcbiAgICogPiB8IFwiY1wiXG4gICAqICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBiZWZvcmVNYXJrZXIoY29kZSkge1xuICAgIHJldHVybiBmYWN0b3J5VGl0bGUoXG4gICAgICBlZmZlY3RzLFxuICAgICAgdGl0bGVBZnRlcixcbiAgICAgIG5vayxcbiAgICAgICdkZWZpbml0aW9uVGl0bGUnLFxuICAgICAgJ2RlZmluaXRpb25UaXRsZU1hcmtlcicsXG4gICAgICAnZGVmaW5pdGlvblRpdGxlU3RyaW5nJ1xuICAgICkoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciB0aXRsZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXTogYiBcImNcIlxuICAgKiAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRpdGxlQWZ0ZXIoY29kZSkge1xuICAgIHJldHVybiBtYXJrZG93blNwYWNlKGNvZGUpXG4gICAgICA/IGZhY3RvcnlTcGFjZShlZmZlY3RzLCB0aXRsZUFmdGVyT3B0aW9uYWxXaGl0ZXNwYWNlLCAnd2hpdGVzcGFjZScpKGNvZGUpXG4gICAgICA6IHRpdGxlQWZ0ZXJPcHRpb25hbFdoaXRlc3BhY2UoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciB0aXRsZSwgYWZ0ZXIgb3B0aW9uYWwgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFthXTogYiBcImNcIlxuICAgKiAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRpdGxlQWZ0ZXJPcHRpb25hbFdoaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBudWxsIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSA/IG9rKGNvZGUpIDogbm9rKGNvZGUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJkZWZpbml0aW9uIiwibmFtZSIsInRva2VuaXplIiwidG9rZW5pemVEZWZpbml0aW9uIiwidGl0bGVCZWZvcmUiLCJ0b2tlbml6ZVRpdGxlQmVmb3JlIiwicGFydGlhbCIsImVmZmVjdHMiLCJvayIsIm5vayIsInNlbGYiLCJpZGVudGlmaWVyIiwic3RhcnQiLCJjb2RlIiwiZW50ZXIiLCJiZWZvcmUiLCJmYWN0b3J5TGFiZWwiLCJjYWxsIiwibGFiZWxBZnRlciIsIm5vcm1hbGl6ZUlkZW50aWZpZXIiLCJzbGljZVNlcmlhbGl6ZSIsImV2ZW50cyIsImxlbmd0aCIsInNsaWNlIiwiY29uc3VtZSIsImV4aXQiLCJtYXJrZXJBZnRlciIsIm1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UiLCJmYWN0b3J5V2hpdGVzcGFjZSIsImRlc3RpbmF0aW9uQmVmb3JlIiwiZmFjdG9yeURlc3RpbmF0aW9uIiwiZGVzdGluYXRpb25BZnRlciIsImF0dGVtcHQiLCJhZnRlciIsIm1hcmtkb3duU3BhY2UiLCJmYWN0b3J5U3BhY2UiLCJhZnRlcldoaXRlc3BhY2UiLCJtYXJrZG93bkxpbmVFbmRpbmciLCJwYXJzZXIiLCJkZWZpbmVkIiwicHVzaCIsImJlZm9yZU1hcmtlciIsImZhY3RvcnlUaXRsZSIsInRpdGxlQWZ0ZXIiLCJ0aXRsZUFmdGVyT3B0aW9uYWxXaGl0ZXNwYWNlIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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