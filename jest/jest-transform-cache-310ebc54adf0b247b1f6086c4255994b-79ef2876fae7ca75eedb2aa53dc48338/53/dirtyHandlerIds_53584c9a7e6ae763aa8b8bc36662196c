6da9785ac00512a75dc5ac1079527628
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "reduce", {
    enumerable: true,
    get: function() {
        return reduce;
    }
});
const _index = require("../actions/dragDrop/index.js");
const _registry = require("../actions/registry.js");
const _dirtiness = require("../utils/dirtiness.js");
const _equality = require("../utils/equality.js");
const _js_utils = require("../utils/js_utils.js");
function reduce(_state = _dirtiness.NONE, action) {
    switch(action.type){
        case _index.HOVER:
            break;
        case _registry.ADD_SOURCE:
        case _registry.ADD_TARGET:
        case _registry.REMOVE_TARGET:
        case _registry.REMOVE_SOURCE:
            return _dirtiness.NONE;
        case _index.BEGIN_DRAG:
        case _index.PUBLISH_DRAG_SOURCE:
        case _index.END_DRAG:
        case _index.DROP:
        default:
            return _dirtiness.ALL;
    }
    const { targetIds = [], prevTargetIds = [] } = action.payload;
    const result = (0, _js_utils.xor)(targetIds, prevTargetIds);
    const didChange = result.length > 0 || !(0, _equality.areArraysEqual)(targetIds, prevTargetIds);
    if (!didChange) {
        return _dirtiness.NONE;
    }
    // Check the target ids at the innermost position. If they are valid, add them
    // to the result
    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
    const innermostTargetId = targetIds[targetIds.length - 1];
    if (prevInnermostTargetId !== innermostTargetId) {
        if (prevInnermostTargetId) {
            result.push(prevInnermostTargetId);
        }
        if (innermostTargetId) {
            result.push(innermostTargetId);
        }
    }
    return result;
} //# sourceMappingURL=dirtyHandlerIds.js.map

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy9kaXJ0eUhhbmRsZXJJZHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QkVHSU5fRFJBRyxcblx0RFJPUCxcblx0RU5EX0RSQUcsXG5cdEhPVkVSLFxuXHRQVUJMSVNIX0RSQUdfU09VUkNFLFxufSBmcm9tICcuLi9hY3Rpb25zL2RyYWdEcm9wL2luZGV4LmpzJ1xuaW1wb3J0IHtcblx0QUREX1NPVVJDRSxcblx0QUREX1RBUkdFVCxcblx0UkVNT1ZFX1NPVVJDRSxcblx0UkVNT1ZFX1RBUkdFVCxcbn0gZnJvbSAnLi4vYWN0aW9ucy9yZWdpc3RyeS5qcydcbmltcG9ydCB0eXBlIHsgQWN0aW9uIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy5qcydcbmltcG9ydCB7IEFMTCwgTk9ORSB9IGZyb20gJy4uL3V0aWxzL2RpcnRpbmVzcy5qcydcbmltcG9ydCB7IGFyZUFycmF5c0VxdWFsIH0gZnJvbSAnLi4vdXRpbHMvZXF1YWxpdHkuanMnXG5pbXBvcnQgeyB4b3IgfSBmcm9tICcuLi91dGlscy9qc191dGlscy5qcydcblxuZXhwb3J0IHR5cGUgU3RhdGUgPSBzdHJpbmdbXVxuXG5leHBvcnQgaW50ZXJmYWNlIERpcnR5SGFuZGxlcklkUGF5bG9hZCB7XG5cdHRhcmdldElkczogc3RyaW5nW11cblx0cHJldlRhcmdldElkczogc3RyaW5nW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZShcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuXHRfc3RhdGU6IFN0YXRlID0gTk9ORSxcblx0YWN0aW9uOiBBY3Rpb248RGlydHlIYW5kbGVySWRQYXlsb2FkPixcbik6IFN0YXRlIHtcblx0c3dpdGNoIChhY3Rpb24udHlwZSkge1xuXHRcdGNhc2UgSE9WRVI6XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgQUREX1NPVVJDRTpcblx0XHRjYXNlIEFERF9UQVJHRVQ6XG5cdFx0Y2FzZSBSRU1PVkVfVEFSR0VUOlxuXHRcdGNhc2UgUkVNT1ZFX1NPVVJDRTpcblx0XHRcdHJldHVybiBOT05FXG5cdFx0Y2FzZSBCRUdJTl9EUkFHOlxuXHRcdGNhc2UgUFVCTElTSF9EUkFHX1NPVVJDRTpcblx0XHRjYXNlIEVORF9EUkFHOlxuXHRcdGNhc2UgRFJPUDpcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIEFMTFxuXHR9XG5cblx0Y29uc3QgeyB0YXJnZXRJZHMgPSBbXSwgcHJldlRhcmdldElkcyA9IFtdIH0gPSBhY3Rpb24ucGF5bG9hZFxuXHRjb25zdCByZXN1bHQgPSB4b3IodGFyZ2V0SWRzLCBwcmV2VGFyZ2V0SWRzKVxuXHRjb25zdCBkaWRDaGFuZ2UgPVxuXHRcdHJlc3VsdC5sZW5ndGggPiAwIHx8ICFhcmVBcnJheXNFcXVhbCh0YXJnZXRJZHMsIHByZXZUYXJnZXRJZHMpXG5cblx0aWYgKCFkaWRDaGFuZ2UpIHtcblx0XHRyZXR1cm4gTk9ORVxuXHR9XG5cblx0Ly8gQ2hlY2sgdGhlIHRhcmdldCBpZHMgYXQgdGhlIGlubmVybW9zdCBwb3NpdGlvbi4gSWYgdGhleSBhcmUgdmFsaWQsIGFkZCB0aGVtXG5cdC8vIHRvIHRoZSByZXN1bHRcblx0Y29uc3QgcHJldklubmVybW9zdFRhcmdldElkID0gcHJldlRhcmdldElkc1twcmV2VGFyZ2V0SWRzLmxlbmd0aCAtIDFdXG5cdGNvbnN0IGlubmVybW9zdFRhcmdldElkID0gdGFyZ2V0SWRzW3RhcmdldElkcy5sZW5ndGggLSAxXVxuXHRpZiAocHJldklubmVybW9zdFRhcmdldElkICE9PSBpbm5lcm1vc3RUYXJnZXRJZCkge1xuXHRcdGlmIChwcmV2SW5uZXJtb3N0VGFyZ2V0SWQpIHtcblx0XHRcdHJlc3VsdC5wdXNoKHByZXZJbm5lcm1vc3RUYXJnZXRJZClcblx0XHR9XG5cdFx0aWYgKGlubmVybW9zdFRhcmdldElkKSB7XG5cdFx0XHRyZXN1bHQucHVzaChpbm5lcm1vc3RUYXJnZXRJZClcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOlsicmVkdWNlIiwiX3N0YXRlIiwiTk9ORSIsImFjdGlvbiIsInR5cGUiLCJIT1ZFUiIsIkFERF9TT1VSQ0UiLCJBRERfVEFSR0VUIiwiUkVNT1ZFX1RBUkdFVCIsIlJFTU9WRV9TT1VSQ0UiLCJCRUdJTl9EUkFHIiwiUFVCTElTSF9EUkFHX1NPVVJDRSIsIkVORF9EUkFHIiwiRFJPUCIsIkFMTCIsInRhcmdldElkcyIsInByZXZUYXJnZXRJZHMiLCJwYXlsb2FkIiwicmVzdWx0IiwieG9yIiwiZGlkQ2hhbmdlIiwibGVuZ3RoIiwiYXJlQXJyYXlzRXF1YWwiLCJwcmV2SW5uZXJtb3N0VGFyZ2V0SWQiLCJpbm5lcm1vc3RUYXJnZXRJZCIsInB1c2giXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJtYXBwaW5ncyI6Ijs7OzsrQkF5QmdCQTs7O2VBQUFBOzs7dUJBbkJUOzBCQU1BOzJCQUVtQjswQkFDSzswQkFDWDtBQVNiLFNBQVNBLE9BRWZDLFNBQWdCQyxlQUFJLEVBQ3BCQyxNQUFxQztJQUVyQyxPQUFRQSxPQUFPQyxJQUFJO1FBQ2xCLEtBQUtDLFlBQUs7WUFDVDtRQUNELEtBQUtDLG9CQUFVO1FBQ2YsS0FBS0Msb0JBQVU7UUFDZixLQUFLQyx1QkFBYTtRQUNsQixLQUFLQyx1QkFBYTtZQUNqQixPQUFPUCxlQUFJO1FBQ1osS0FBS1EsaUJBQVU7UUFDZixLQUFLQywwQkFBbUI7UUFDeEIsS0FBS0MsZUFBUTtRQUNiLEtBQUtDLFdBQUk7UUFDVDtZQUNDLE9BQU9DLGNBQUc7O0lBR1osTUFBTSxFQUFFQyxZQUFZLEVBQUUsRUFBRUMsZ0JBQWdCLEVBQUUsRUFBRSxHQUFHYixPQUFPYyxPQUFPO0lBQzdELE1BQU1DLFNBQVNDLElBQUFBLGFBQUcsRUFBQ0osV0FBV0M7SUFDOUIsTUFBTUksWUFDTEYsT0FBT0csTUFBTSxHQUFHLEtBQUssQ0FBQ0MsSUFBQUEsd0JBQWMsRUFBQ1AsV0FBV0M7SUFFakQsSUFBSSxDQUFDSSxXQUFXO1FBQ2YsT0FBT2xCLGVBQUk7O0lBR1osOEVBQThFO0lBQzlFLGdCQUFnQjtJQUNoQixNQUFNcUIsd0JBQXdCUCxhQUFhLENBQUNBLGNBQWNLLE1BQU0sR0FBRyxFQUFFO0lBQ3JFLE1BQU1HLG9CQUFvQlQsU0FBUyxDQUFDQSxVQUFVTSxNQUFNLEdBQUcsRUFBRTtJQUN6RCxJQUFJRSwwQkFBMEJDLG1CQUFtQjtRQUNoRCxJQUFJRCx1QkFBdUI7WUFDMUJMLE9BQU9PLElBQUksQ0FBQ0Y7O1FBRWIsSUFBSUMsbUJBQW1CO1lBQ3RCTixPQUFPTyxJQUFJLENBQUNEOzs7SUFJZCxPQUFPTiJ9