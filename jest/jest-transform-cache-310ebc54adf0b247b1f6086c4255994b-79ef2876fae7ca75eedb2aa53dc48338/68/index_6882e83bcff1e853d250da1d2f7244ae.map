{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/mdast-util-find-and-replace/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasn’t a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n"],"names":["findAndReplace","tree","list","options","settings","ignored","convert","ignore","pairs","toPairs","pairIndex","length","visitParents","visitor","node","parents","index","grandparent","parent","siblings","children","undefined","indexOf","handler","find","replace","start","change","nodes","lastIndex","match","exec","value","position","matchObject","input","stack","type","push","slice","Array","isArray","global","splice","tupleOrList","result","TypeError","tuple","toExpression","toFunction","RegExp","escape"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}