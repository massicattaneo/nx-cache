{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-extension-gfm-table/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {EditMap} from './edit-map.js'\nimport {gfmTableAlign} from './infer.js'\n\n/**\n * Create an HTML extension for `micromark` to support GitHub tables syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   table syntax.\n */\nexport function gfmTable() {\n  return {\n    flow: {\n      null: {\n        tokenize: tokenizeTable,\n        resolveAll: resolveTable\n      }\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  let size = 0\n  let sizeB = 0\n  /** @type {boolean | undefined} */\n  let seen\n  return start\n\n  /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length - 1\n    while (index > -1) {\n      const type = self.events[index][1].type\n      if (\n        type === 'lineEnding' ||\n        // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n        type === 'linePrefix'\n      )\n        index--\n      else break\n    }\n    const tail = index > -1 ? self.events[index][1].type : null\n    const next =\n      tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore\n\n    // Don’t allow lazy body rows.\n    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n    return next(code)\n  }\n\n  /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBefore(code) {\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n    return headRowStart(code)\n  }\n\n  /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowStart(code) {\n    if (code === 124) {\n      return headRowBreak(code)\n    }\n\n    // To do: micromark-js should let us parse our own whitespace in extensions,\n    // like `markdown-rs`:\n    //\n    // ```js\n    // // 4+ spaces.\n    // if (markdownSpace(code)) {\n    //   return nok(code)\n    // }\n    // ```\n\n    seen = true\n    // Count the first character, that isn’t a pipe, double.\n    sizeB += 1\n    return headRowBreak(code)\n  }\n\n  /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBreak(code) {\n    if (code === null) {\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n      return nok(code)\n    }\n    if (markdownLineEnding(code)) {\n      // If anything other than one pipe (ignoring whitespace) was used, it’s fine.\n      if (sizeB > 1) {\n        sizeB = 0\n        // To do: check if this works.\n        // Feel free to interrupt:\n        self.interrupt = true\n        effects.exit('tableRow')\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return headDelimiterStart\n      }\n\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n      return nok(code)\n    }\n    if (markdownSpace(code)) {\n      // To do: check if this is fine.\n      // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n      // State::Retry(space_or_tab(tokenizer))\n      return factorySpace(effects, headRowBreak, 'whitespace')(code)\n    }\n    sizeB += 1\n    if (seen) {\n      seen = false\n      // Header cell count.\n      size += 1\n    }\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      // Whether a delimiter was seen.\n      seen = true\n      return headRowBreak\n    }\n\n    // Anything else is cell data.\n    effects.enter('data')\n    return headRowData(code)\n  }\n\n  /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowData(code) {\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('data')\n      return headRowBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? headRowEscape : headRowData\n  }\n\n  /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowEscape(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return headRowData\n    }\n    return headRowData(code)\n  }\n\n  /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterStart(code) {\n    // Reset `interrupt`.\n    self.interrupt = false\n\n    // Note: in `markdown-rs`, we need to handle piercing here too.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n    effects.enter('tableDelimiterRow')\n    // Track if we’ve seen a `:` or `|`.\n    seen = false\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        headDelimiterBefore,\n        'linePrefix',\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : 4\n      )(code)\n    }\n    return headDelimiterBefore(code)\n  }\n\n  /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterBefore(code) {\n    if (code === 45 || code === 58) {\n      return headDelimiterValueBefore(code)\n    }\n    if (code === 124) {\n      seen = true\n      // If we start with a pipe, we open a cell marker.\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return headDelimiterCellBefore\n    }\n\n    // More whitespace / empty row not allowed at start.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellBefore(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterValueBefore, 'whitespace')(code)\n    }\n    return headDelimiterValueBefore(code)\n  }\n\n  /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterValueBefore(code) {\n    // Align: left.\n    if (code === 58) {\n      sizeB += 1\n      seen = true\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterLeftAlignmentAfter\n    }\n\n    // Align: none.\n    if (code === 45) {\n      sizeB += 1\n      // To do: seems weird that this *isn’t* left aligned, but that state is used?\n      return headDelimiterLeftAlignmentAfter(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      return headDelimiterCellAfter(code)\n    }\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterLeftAlignmentAfter(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      return headDelimiterFiller(code)\n    }\n\n    // Anything else is not ok after the left-align colon.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterFiller(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return headDelimiterFiller\n    }\n\n    // Align is `center` if it was `left`, `right` otherwise.\n    if (code === 58) {\n      seen = true\n      effects.exit('tableDelimiterFiller')\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterRightAlignmentAfter\n    }\n    effects.exit('tableDelimiterFiller')\n    return headDelimiterRightAlignmentAfter(code)\n  }\n\n  /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterRightAlignmentAfter(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterCellAfter, 'whitespace')(code)\n    }\n    return headDelimiterCellAfter(code)\n  }\n\n  /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellAfter(code) {\n    if (code === 124) {\n      return headDelimiterBefore(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      // Exit when:\n      // * there was no `:` or `|` at all (it’s a thematic break or setext\n      //   underline instead)\n      // * the header cell count is not the delimiter cell count\n      if (!seen || size !== sizeB) {\n        return headDelimiterNok(code)\n      }\n\n      // Note: in markdown-rs`, a reset is needed here.\n      effects.exit('tableDelimiterRow')\n      effects.exit('tableHead')\n      // To do: in `markdown-rs`, resolvers need to be registered manually.\n      // effects.register_resolver(ResolveName::GfmTable)\n      return ok(code)\n    }\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterNok(code) {\n    // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n    return nok(code)\n  }\n\n  /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowStart(code) {\n    // Note: in `markdown-rs` we need to manually take care of a prefix,\n    // but in `micromark-js` that is done for us, so if we’re here, we’re\n    // never at whitespace.\n    effects.enter('tableRow')\n    return bodyRowBreak(code)\n  }\n\n  /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowBreak(code) {\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return bodyRowBreak\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('tableRow')\n      return ok(code)\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, bodyRowBreak, 'whitespace')(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('data')\n    return bodyRowData(code)\n  }\n\n  /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowData(code) {\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('data')\n      return bodyRowBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? bodyRowEscape : bodyRowData\n  }\n\n  /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowEscape(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return bodyRowData\n    }\n    return bodyRowData(code)\n  }\n}\n\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  let inFirstCellAwaitingPipe = true\n  /** @type {RowKind} */\n  let rowKind = 0\n  /** @type {Range} */\n  let lastCell = [0, 0, 0, 0]\n  /** @type {Range} */\n  let cell = [0, 0, 0, 0]\n  let afterHeadAwaitingFirstBodyRow = false\n  let lastTableEnd = 0\n  /** @type {Token | undefined} */\n  let currentTable\n  /** @type {Token | undefined} */\n  let currentBody\n  /** @type {Token | undefined} */\n  let currentCell\n  const map = new EditMap()\n  while (++index < events.length) {\n    const event = events[index]\n    const token = event[1]\n    if (event[0] === 'enter') {\n      // Start of head.\n      if (token.type === 'tableHead') {\n        afterHeadAwaitingFirstBodyRow = false\n\n        // Inject previous (body end and) table end.\n        if (lastTableEnd !== 0) {\n          flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n          currentBody = undefined\n          lastTableEnd = 0\n        }\n\n        // Inject table start.\n        currentTable = {\n          type: 'table',\n          start: Object.assign({}, token.start),\n          // Note: correct end is set later.\n          end: Object.assign({}, token.end)\n        }\n        map.add(index, 0, [['enter', currentTable, context]])\n      } else if (\n        token.type === 'tableRow' ||\n        token.type === 'tableDelimiterRow'\n      ) {\n        inFirstCellAwaitingPipe = true\n        currentCell = undefined\n        lastCell = [0, 0, 0, 0]\n        cell = [0, index + 1, 0, 0]\n\n        // Inject table body start.\n        if (afterHeadAwaitingFirstBodyRow) {\n          afterHeadAwaitingFirstBodyRow = false\n          currentBody = {\n            type: 'tableBody',\n            start: Object.assign({}, token.start),\n            // Note: correct end is set later.\n            end: Object.assign({}, token.end)\n          }\n          map.add(index, 0, [['enter', currentBody, context]])\n        }\n        rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1\n      }\n      // Cell data.\n      else if (\n        rowKind &&\n        (token.type === 'data' ||\n          token.type === 'tableDelimiterMarker' ||\n          token.type === 'tableDelimiterFiller')\n      ) {\n        inFirstCellAwaitingPipe = false\n\n        // First value in cell.\n        if (cell[2] === 0) {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n            lastCell = [0, 0, 0, 0]\n          }\n          cell[2] = index\n        }\n      } else if (token.type === 'tableCellDivider') {\n        if (inFirstCellAwaitingPipe) {\n          inFirstCellAwaitingPipe = false\n        } else {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n          }\n          lastCell = cell\n          cell = [lastCell[1], index, 0, 0]\n        }\n      }\n    }\n    // Exit events.\n    else if (token.type === 'tableHead') {\n      afterHeadAwaitingFirstBodyRow = true\n      lastTableEnd = index\n    } else if (\n      token.type === 'tableRow' ||\n      token.type === 'tableDelimiterRow'\n    ) {\n      lastTableEnd = index\n      if (lastCell[1] !== 0) {\n        cell[0] = cell[1]\n        currentCell = flushCell(\n          map,\n          context,\n          lastCell,\n          rowKind,\n          index,\n          currentCell\n        )\n      } else if (cell[1] !== 0) {\n        currentCell = flushCell(map, context, cell, rowKind, index, currentCell)\n      }\n      rowKind = 0\n    } else if (\n      rowKind &&\n      (token.type === 'data' ||\n        token.type === 'tableDelimiterMarker' ||\n        token.type === 'tableDelimiterFiller')\n    ) {\n      cell[3] = index\n    }\n  }\n  if (lastTableEnd !== 0) {\n    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n  }\n  map.consume(context.events)\n\n  // To do: move this into `html`, when events are exposed there.\n  // That’s what `markdown-rs` does.\n  // That needs updates to `mdast-util-gfm-table`.\n  index = -1\n  while (++index < context.events.length) {\n    const event = context.events[index]\n    if (event[0] === 'enter' && event[1].type === 'table') {\n      event[1]._align = gfmTableAlign(context.events, index)\n    }\n  }\n  return events\n}\n\n/**\n * Generate a cell.\n *\n * @param {EditMap} map\n * @param {Readonly<TokenizeContext>} context\n * @param {Readonly<Range>} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */\n// eslint-disable-next-line max-params\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n  const groupName =\n    rowKind === 1\n      ? 'tableHeader'\n      : rowKind === 2\n      ? 'tableDelimiter'\n      : 'tableData'\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n  const valueName = 'tableContent'\n\n  // Insert an exit for the previous cell, if there is one.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //          ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[0] !== 0) {\n    previousCell.end = Object.assign({}, getPoint(context.events, range[0]))\n    map.add(range[0], 0, [['exit', previousCell, context]])\n  }\n\n  // Insert enter of this cell.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //           ^-- enter\n  //           ^^^^-- this cell\n  // ```\n  const now = getPoint(context.events, range[1])\n  previousCell = {\n    type: groupName,\n    start: Object.assign({}, now),\n    // Note: correct end is set later.\n    end: Object.assign({}, now)\n  }\n  map.add(range[1], 0, [['enter', previousCell, context]])\n\n  // Insert text start at first data start and end at last data end, and\n  // remove events between.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //            ^-- enter\n  //             ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[2] !== 0) {\n    const relatedStart = getPoint(context.events, range[2])\n    const relatedEnd = getPoint(context.events, range[3])\n    /** @type {Token} */\n    const valueToken = {\n      type: valueName,\n      start: Object.assign({}, relatedStart),\n      end: Object.assign({}, relatedEnd)\n    }\n    map.add(range[2], 0, [['enter', valueToken, context]])\n    if (rowKind !== 2) {\n      // Fix positional info on remaining events\n      const start = context.events[range[2]]\n      const end = context.events[range[3]]\n      start[1].end = Object.assign({}, end[1].end)\n      start[1].type = 'chunkText'\n      start[1].contentType = 'text'\n\n      // Remove if needed.\n      if (range[3] > range[2] + 1) {\n        const a = range[2] + 1\n        const b = range[3] - range[2] - 1\n        map.add(a, b, [])\n      }\n    }\n    map.add(range[3] + 1, 0, [['exit', valueToken, context]])\n  }\n\n  // Insert an exit for the last cell, if at the row end.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //                    ^-- exit\n  //               ^^^^^^-- this cell (the last one contains two “between” parts)\n  // ```\n  if (rowEnd !== undefined) {\n    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd))\n    map.add(rowEnd, 0, [['exit', previousCell, context]])\n    previousCell = undefined\n  }\n  return previousCell\n}\n\n/**\n * Generate table end (and table body end).\n *\n * @param {Readonly<EditMap>} map\n * @param {Readonly<TokenizeContext>} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */\n// eslint-disable-next-line max-params\nfunction flushTableEnd(map, context, index, table, tableBody) {\n  /** @type {Array<Event>} */\n  const exits = []\n  const related = getPoint(context.events, index)\n  if (tableBody) {\n    tableBody.end = Object.assign({}, related)\n    exits.push(['exit', tableBody, context])\n  }\n  table.end = Object.assign({}, related)\n  exits.push(['exit', table, context])\n  map.add(index + 1, 0, exits)\n}\n\n/**\n * @param {Readonly<Array<Event>>} events\n * @param {number} index\n * @returns {Readonly<Point>}\n */\nfunction getPoint(events, index) {\n  const event = events[index]\n  const side = event[0] === 'enter' ? 'start' : 'end'\n  return event[1][side]\n}\n"],"names":["gfmTable","flow","null","tokenize","tokenizeTable","resolveAll","resolveTable","effects","ok","nok","self","size","sizeB","seen","start","code","index","events","length","type","tail","next","bodyRowStart","headRowBefore","parser","lazy","now","line","enter","headRowStart","headRowBreak","markdownLineEnding","interrupt","exit","consume","headDelimiterStart","markdownSpace","factorySpace","headRowData","markdownLineEndingOrSpace","headRowEscape","headDelimiterBefore","constructs","disable","includes","undefined","headDelimiterValueBefore","headDelimiterCellBefore","headDelimiterNok","headDelimiterLeftAlignmentAfter","headDelimiterCellAfter","headDelimiterFiller","headDelimiterRightAlignmentAfter","bodyRowBreak","bodyRowData","bodyRowEscape","context","inFirstCellAwaitingPipe","rowKind","lastCell","cell","afterHeadAwaitingFirstBodyRow","lastTableEnd","currentTable","currentBody","currentCell","map","EditMap","event","token","flushTableEnd","Object","assign","end","add","flushCell","_align","gfmTableAlign","range","rowEnd","previousCell","groupName","valueName","getPoint","relatedStart","relatedEnd","valueToken","contentType","a","b","table","tableBody","exits","related","push","side"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}