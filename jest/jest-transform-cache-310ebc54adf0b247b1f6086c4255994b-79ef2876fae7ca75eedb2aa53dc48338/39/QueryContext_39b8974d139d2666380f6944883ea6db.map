{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/libs/react/web/common/providers/src/QueryContext/QueryContext.tsx"],"sourcesContent":["import React, {\n  SetStateAction,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport {\n  CqsQueryScopeEnum,\n  CqsQuerySortEnum,\n  CqsSavedQuery,\n  CqsSavedQueryContext,\n  CqsSavedStatus,\n  CqsSearchQuery,\n} from \"@rp/common/api-types\"\nimport {\n  isRpqlFlatArrayFilter,\n  isRpqlFlatLogicalGroup,\n  isRpqlFlatMatchFilter,\n  isRpqlLogicalGroup,\n} from \"@rp/common/api-types\"\nimport {\n  RpqlArrayOperations,\n  RpqlDateFilter,\n  RpqlFilter,\n  RpqlFlatArrayFilter,\n  RpqlFlatFilter,\n  RpqlFlatLogicalFilter,\n  RpqlFlatMatchFilter,\n} from \"@rp/common/api-types\"\nimport { useRavenPackQuery } from \"@rp/react/rpql\"\nimport {\n  EntityItem,\n  FilterItem,\n  GenericItem,\n  LanguageItem,\n  SourceItem,\n  TopicItem,\n} from \"@rp/react/tanstack-api/cqs-query-context\"\nimport {\n  QueryUpdate,\n  useSavedQuery,\n  useUpdateSavedQueryField,\n} from \"@rp/react/tanstack-api/user-data-queries\"\nimport { useDynamicCQSName } from \"@rp/react/tanstack-api/user-data-queries\"\nimport { useHandleNewQuery } from \"@rp/react/web/common/hooks\"\nimport { ResultsPageState } from \"@rp/react/web/common/types\"\nimport {\n  addCqsQueryItem,\n  removeLastTick,\n  useDiscoveryPanelKey,\n} from \"@rp/react/web/cqs-query-context\"\nimport {\n  DEFAULT_OPERATION,\n  ExtendedArrayOperations,\n  convertItemToFilter,\n  isMacroSearchItem,\n  matchFilter,\n} from \"@rp/react/web/cqs-query-context\"\nimport { DEFAULT_EXPRESSION } from \"@rp/react/web/cqs-utils\"\nimport { isCqsQueryNotEmpty } from \"@rp/react/web/cqs-utils\"\nimport { decodeString } from \"@rp/web/utils\"\nimport { useQueryClient } from \"@tanstack/react-query\"\nimport { useSnackbar } from \"../Snackbar\"\n\ntype SetAtomState = (state: ResultsPageState) => void\ntype Update<TFilter> = Omit<TFilter, \"id\">\n\ntype ContextActions = {\n  clearInternalState: () => void\n  setFilterKeyword: (value: string) => void\n  setSort: (value: CqsQuerySortEnum) => void\n  setScope: (value: CqsQueryScopeEnum) => void\n  setDate: (value: RpqlDateFilter) => void\n  expression: {\n    addItem: (value: FilterItem, operation?: ExtendedArrayOperations) => Promise<void>\n    removeItem: (value: FilterItem) => Promise<void>\n    updateItems: (id: string, filter: Array<FilterItem>) => Promise<void>\n    removeMacroSearchContent: (macroId: string, groupToRemove: RpqlFlatArrayFilter) => Promise<void>\n    removeFilters: (ids: Array<string>) => Promise<void>\n    getFilter: (id: string) => RpqlFlatFilter | null\n    getRoot: () => RpqlFlatLogicalFilter | null\n    updateFilter: <TFilter extends RpqlFlatFilter>(\n      id: string,\n      updateFunc: (filter: Update<TFilter>) => Update<TFilter>,\n    ) => Promise<void>\n    excludeItemFromDP: (\n      item: EntityItem | SourceItem | TopicItem | LanguageItem | GenericItem,\n      newItem?: boolean,\n      onSuccess?: () => void,\n    ) => Promise<void>\n  }\n}\n\ntype QueryContextType = {\n  searchQuery: CqsSearchQuery\n  savedQuery: CqsSavedQueryContext\n  uiState: {\n    filterKeyword: string\n    isLoading: boolean\n    isError: boolean\n    isSummaryLoading: boolean\n    setIsSummaryLoading: React.Dispatch<React.SetStateAction<boolean>>\n  }\n  queryBar: {\n    actions: ContextActions\n    filters: Array<string>\n    id: string\n    saveStatus: CqsSavedStatus | undefined\n  }\n  actions: ContextActions\n  queryId: string\n}\n\n// ============================\n// Defaults\n// ============================\n\nconst DEFAULT_SCOPE = CqsQueryScopeEnum.All\nconst DEFAULT_SORT_TYPE = CqsQuerySortEnum.Relevance\n\n// ============================\n// Context\n// ============================\n\nconst QueryContext = createContext<QueryContextType | undefined>(undefined)\n\ntype QueryProviderProps = {\n  id: string\n  children: React.ReactNode\n  setResultsState?: SetAtomState\n  patchCheck?: (query?: CqsSavedQuery, updates?: QueryUpdate) => boolean\n}\n\nconst QueryProvider: React.FC<QueryProviderProps> = ({\n  id,\n  children,\n  patchCheck = () => false,\n  setResultsState,\n}) => {\n  // Show me some hooks!\n  const { enqueueError } = useSnackbar()\n  const queryClient = useQueryClient()\n  const { mutateAsync, isPending, isError } = useUpdateSavedQueryField({ enqueueError })\n  const { makeDynamicName } = useDynamicCQSName()\n  const [isSummaryLoading, setIsSummaryLoading] = useState(false)\n\n  // UI State - NOT SAVED IN THE QUERY\n  const [filterKeyword, setFilterKeyword] = useState(\"\")\n  const [scope, setScope] = useState(DEFAULT_SCOPE)\n  const [searchQueryExpression, setSearchQueryExpression] = useState<RpqlFilter | undefined>()\n  const [sort, setSort] = useState(DEFAULT_SORT_TYPE)\n\n  // Get the data we need from the saved search\n  const { data } = useSavedQuery(id)\n\n  // Recent search behavior\n  const shouldCreateNewQuery = useRef(false)\n  const { handleNewQueryFromExpression } = useHandleNewQuery()\n\n  // If the expression coming from BE is not valid, we wrap it on a logicalFilter\n  let initialExpression = data?.query.expression ?? DEFAULT_EXPRESSION\n  if (!isRpqlLogicalGroup(initialExpression)) {\n    initialExpression = {\n      type: \"and\",\n      value: [initialExpression],\n    }\n  }\n\n  const rpql = useRavenPackQuery(initialExpression)\n  const getDiscoveryPanelKey = useDiscoveryPanelKey()\n\n  // Before a search is patched, we can check some defaults\n  const checkDefaults = ({ id, fields }: QueryUpdate, previousQuery: CqsSavedQuery | undefined) => {\n    const { query: { expression = DEFAULT_EXPRESSION } = {} } = fields\n\n    // If there are no sentences or the expression is empty...\n    // ...we update the cache but return false, so we don't patch the query\n    if (!isCqsQueryNotEmpty({ expression })) {\n      queryClient.setQueryData([\"query\", id], {\n        ...previousQuery,\n        query: {\n          ...previousQuery?.query,\n          sentences: [],\n          expression: DEFAULT_EXPRESSION,\n        },\n      })\n      removeLastTick(getDiscoveryPanelKey(searchQuery), queryClient)\n      return false\n    }\n\n    let modifiedFields = fields\n    if (previousQuery?.saveStatus === \"unsaved\" && !fields.name) {\n      const name = decodeString(makeDynamicName(fields))\n      modifiedFields = { ...modifiedFields, name }\n    }\n    return { id, fields: modifiedFields }\n  }\n\n  const patchQuery = (newData: QueryUpdate, enableNewQuery = false) => {\n    if (enableNewQuery && shouldCreateNewQuery.current && newData.fields.query?.expression) {\n      handleNewQueryFromExpression(newData.fields.query?.expression)\n      shouldCreateNewQuery.current = false\n      return\n    }\n\n    if (!patchCheck(data, newData)) {\n      rpql.resetExpression(data?.query.expression ?? DEFAULT_EXPRESSION)\n      // So we undo the setResultsState(\"loading\") change.\n      setResultsState?.(\"results\")\n      return\n    }\n\n    const queryContent = checkDefaults(newData, data)\n\n    if (queryContent) {\n      return mutateAsync(queryContent)\n    }\n\n    // If the query is empty, and the search is not saved,\n    // next change should trigger a new search\n    if (data?.saveStatus === \"unsaved\") {\n      shouldCreateNewQuery.current = true\n    }\n    return\n  }\n\n  const patchExpression = (newExpression: RpqlFilter | undefined) => {\n    if (isCqsQueryNotEmpty({ ...data?.query, expression: newExpression })) {\n      setResultsState?.(\"loading\")\n    }\n    patchQuery({ id, fields: { query: { ...data?.query, expression: newExpression } } }, true)\n  }\n\n  const patchSort = useCallback(\n    (value: SetStateAction<CqsQuerySortEnum>) => {\n      setResultsState?.(\"loading\")\n      setSort(value)\n    },\n    [setResultsState],\n  )\n\n  const patchScope = useCallback((value: CqsQueryScopeEnum) => {\n    setScope(value)\n  }, [])\n\n  const setDate = (date: RpqlDateFilter) => {\n    setResultsState?.(\"loading\")\n    if (date?.value === \"any_time\") {\n      return patchQuery({ id, fields: { query: { ...data?.query, date: null } } })\n    }\n    return patchQuery({ id, fields: { query: { ...data?.query, date: [date] } } })\n  }\n\n  const addItem = async (\n    item: FilterItem,\n    operation: ExtendedArrayOperations = DEFAULT_OPERATION,\n  ) => {\n    const builder = rpql.builder()\n    addCqsQueryItem(rpql.root, builder, item, operation, rpql.filterMap)\n    const expression = builder.generate()\n    await patchExpression(expression)\n  }\n\n  const updateFilter = async <TFilter extends RpqlFlatFilter>(\n    id: string,\n    updateFunc: (filter: Update<TFilter>) => Update<TFilter>,\n  ) => {\n    const expression = rpql.updateFilter<TFilter>(id, updateFunc)\n    await patchExpression(expression)\n    return\n  }\n\n  const updateItems = async (filterId: string, filters: Array<FilterItem>) => {\n    const rpqlBuilder = rpql.builder()\n    rpqlBuilder.remove(filterId)\n    filters.forEach(item => {\n      const operation = item.operation || DEFAULT_OPERATION\n      const isCorrectFilter = matchFilter(item, operation)\n      const parent = rpqlBuilder.findChild(isCorrectFilter)\n      if (parent === null) {\n        rpqlBuilder.add(rpql.root, convertItemToFilter(item, operation as RpqlArrayOperations))\n      } else if (\n        isRpqlFlatArrayFilter(parent) &&\n        !isMacroSearchItem(item) &&\n        !parent.value.includes(item.value)\n      ) {\n        rpqlBuilder.update<typeof parent>(parent.id, filter => ({\n          ...filter,\n          value: [...filter.value, item.value],\n        }))\n      }\n    })\n    const expression = rpqlBuilder.generate()\n    await patchExpression(expression)\n    return\n  }\n\n  const excludeItemFromDP = async (\n    item: EntityItem | SourceItem | TopicItem | LanguageItem | GenericItem,\n    newItem = false,\n    onSuccess?: () => void,\n  ) => {\n    if (newItem) {\n      addItem(item, \"not-in\")\n      onSuccess?.()\n      return\n    }\n\n    const rpqlBuilder = rpql.builder()\n    const parent = rpql.findChild(\n      rpql.root,\n      flatFilter => isRpqlFlatArrayFilter(flatFilter) && flatFilter.value.includes(item.value),\n    )\n\n    // Invalid parent, this should never happen\n    if (parent === null || !isRpqlFlatArrayFilter(parent)) {\n      return\n    }\n\n    if (parent.operation === \"not-in\") {\n      return\n    }\n\n    if (parent.value.length === 1) {\n      rpqlBuilder.remove(parent.id)\n      rpqlBuilder.add(rpql.root, convertItemToFilter(item, \"not-in\"))\n    } else {\n      rpqlBuilder.update<typeof parent>(parent.id, filter => ({\n        ...filter,\n        value: filter.value.filter(key => key !== item.value),\n      }))\n      rpqlBuilder.add(rpql.root, convertItemToFilter(item, \"not-in\"))\n    }\n\n    const expression = rpqlBuilder.generate()\n    onSuccess?.()\n    return patchExpression(expression)\n  }\n\n  const removeItem = async (item: FilterItem) => {\n    if (isMacroSearchItem(item)) {\n      return\n    }\n\n    const container = rpql.findChild(\n      rpql.root,\n      filter => isRpqlFlatArrayFilter(filter) && filter.value.includes(item.value),\n    )\n\n    if (container === null || !isRpqlFlatArrayFilter(container)) {\n      return\n    }\n\n    if (container.value.length === 1) {\n      const expression = rpql.removeFilter(container.id)\n      await patchExpression(expression)\n      return\n    }\n\n    const expression = rpql.updateFilter<typeof container>(container.id, filter => {\n      return {\n        ...filter,\n        value: filter.value.filter(id => id !== item.value),\n      }\n    })\n    await patchExpression(expression)\n    return\n  }\n\n  const removeFilters = async (filters: Array<string>) => {\n    const rpqlBuilder = rpql.builder()\n    filters.forEach(filterId => {\n      rpqlBuilder.remove(filterId)\n    })\n    const expression = rpqlBuilder.generate()\n    await patchExpression(expression)\n    return\n  }\n\n  const removeMacroSearchContent = async (macroId: string, groupToRemove: RpqlFlatArrayFilter) => {\n    const existingGroup = rpql.filterMap[groupToRemove.id]\n    if (!existingGroup || !isRpqlFlatArrayFilter(existingGroup)) {\n      throw new Error(\"Trying to remove an invalid filter as a macro-search group\")\n    }\n\n    const parent = rpql.filterMap[macroId]\n    if (!parent || !isRpqlFlatMatchFilter(parent)) {\n      throw new Error(\"Selected Macro-search is invalid or does not exist\")\n    }\n\n    const builder = rpql.builder()\n    // We always have to remove the labels related to the items to be removed.\n    const invalidLabels = groupToRemove.value.map(key => `${groupToRemove.type}-${key}`)\n    const updatedLabels = { ...parent.metadata?.labels }\n\n    for (const labelToRemove of invalidLabels) {\n      delete updatedLabels[labelToRemove]\n    }\n\n    builder.update<RpqlFlatMatchFilter>(macroId, macroFilter => ({\n      ...macroFilter,\n      metadata: {\n        ...macroFilter.metadata,\n        labels: updatedLabels,\n      },\n    }))\n\n    // Then, if the group is completely empty, we remove the children\n    if (groupToRemove.value.length === existingGroup.value.length) {\n      builder.update<RpqlFlatMatchFilter>(macroId, macroFilter => ({\n        ...macroFilter,\n        value: macroFilter.value.filter(childId => childId !== groupToRemove.id),\n      }))\n    } else {\n      builder.update<RpqlFlatArrayFilter>(existingGroup.id, filter => ({\n        ...filter,\n        value: filter.value.filter(key => !groupToRemove.value.includes(key)),\n      }))\n    }\n\n    const expression = builder.generate()\n    await patchExpression(expression)\n  }\n\n  const getRoot = () => {\n    const rootFilter = rpql.getFilter(rpql.root)\n    if (rootFilter === null || !isRpqlFlatLogicalGroup(rootFilter)) {\n      return null\n    }\n    return rootFilter\n  }\n\n  const clearInternalState = () => {\n    rpql.clear()\n  }\n\n  // Easily modify elements in the main query\n  const actions: ContextActions = {\n    expression: {\n      addItem,\n      removeItem,\n      updateItems,\n      removeFilters,\n      removeMacroSearchContent,\n      getFilter: rpql.getFilter,\n      getRoot: getRoot,\n      updateFilter,\n      excludeItemFromDP,\n    },\n    clearInternalState,\n    setFilterKeyword,\n    setSort: patchSort,\n    setScope: patchScope,\n    setDate,\n  }\n\n  const date = data?.query.date ?? null\n\n  const baseQuery: CqsSearchQuery = {\n    queryId: id,\n    expression: rpql.expression,\n    sort,\n    ranking: data?.query.ranking,\n    scope,\n  }\n\n  const searchQuery = useMemo(\n    () => ({\n      sort,\n      scope,\n      ranking: data?.query.ranking,\n      expression: searchQueryExpression,\n      queryId: id,\n    }),\n    [data?.query.ranking, id, scope, searchQueryExpression, sort],\n  )\n\n  useEffect(() => {\n    setSearchQueryExpression({\n      type: \"and\",\n      value: data?.query?.date\n        ? [rpql.expression, ...(data.query.date || null)]\n        : [rpql.expression],\n    })\n  }, [rpql.expression, data])\n\n  return (\n    <QueryContext.Provider\n      value={{\n        savedQuery: { ...data, id, query: { ...baseQuery, date } },\n        // The Search Query contains additional filters that are not saved to the search\n        searchQuery,\n        uiState: {\n          filterKeyword,\n          isLoading: isPending,\n          isError,\n          isSummaryLoading,\n          setIsSummaryLoading,\n        },\n        actions,\n        queryId: id,\n        queryBar: {\n          actions,\n          filters: getRoot()?.value ?? [],\n          id,\n          saveStatus: data?.saveStatus,\n        },\n      }}\n    >\n      {children}\n    </QueryContext.Provider>\n  )\n}\n\n// ============================\n// Hooks\n// ============================\nconst useQueryContext = () => {\n  const context = useContext(QueryContext)\n  if (!context) {\n    throw new Error(\"useQueryContext must be used within a QueryProvider\")\n  }\n  return context\n}\n\nexport { QueryProvider, useQueryContext }\n"],"names":["QueryProvider","useQueryContext","DEFAULT_SCOPE","CqsQueryScopeEnum","All","DEFAULT_SORT_TYPE","CqsQuerySortEnum","Relevance","QueryContext","createContext","undefined","id","children","patchCheck","setResultsState","getRoot","enqueueError","useSnackbar","queryClient","useQueryClient","mutateAsync","isPending","isError","useUpdateSavedQueryField","makeDynamicName","useDynamicCQSName","isSummaryLoading","setIsSummaryLoading","useState","filterKeyword","setFilterKeyword","scope","setScope","searchQueryExpression","setSearchQueryExpression","sort","setSort","data","useSavedQuery","shouldCreateNewQuery","useRef","handleNewQueryFromExpression","useHandleNewQuery","initialExpression","query","expression","DEFAULT_EXPRESSION","isRpqlLogicalGroup","type","value","rpql","useRavenPackQuery","getDiscoveryPanelKey","useDiscoveryPanelKey","checkDefaults","fields","previousQuery","isCqsQueryNotEmpty","setQueryData","sentences","removeLastTick","searchQuery","modifiedFields","saveStatus","name","decodeString","patchQuery","newData","enableNewQuery","current","resetExpression","queryContent","patchExpression","newExpression","patchSort","useCallback","patchScope","setDate","date","addItem","item","operation","DEFAULT_OPERATION","builder","addCqsQueryItem","root","filterMap","generate","updateFilter","updateFunc","updateItems","filterId","filters","rpqlBuilder","remove","forEach","isCorrectFilter","matchFilter","parent","findChild","add","convertItemToFilter","isRpqlFlatArrayFilter","isMacroSearchItem","includes","update","filter","excludeItemFromDP","newItem","onSuccess","flatFilter","length","key","removeItem","container","removeFilter","removeFilters","removeMacroSearchContent","macroId","groupToRemove","existingGroup","Error","isRpqlFlatMatchFilter","invalidLabels","map","updatedLabels","metadata","labels","labelToRemove","macroFilter","childId","rootFilter","getFilter","isRpqlFlatLogicalGroup","clearInternalState","clear","actions","baseQuery","queryId","ranking","useMemo","useEffect","Provider","savedQuery","uiState","isLoading","queryBar","context","useContext"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}