{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-extension-gfm-footnote/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    }\n\n    // Exit if weâ€™ve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n  return start\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token | undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  /** @type {Token} */\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We canâ€™t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteCallString')\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code)\n      }\n      effects.enter('gfmFootnoteCallLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteCallLabelMarker')\n      effects.exit('gfmFootnoteCall')\n      return ok\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? callEscape : callData\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n    return callData(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean | undefined} */\n  let data\n  return start\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelAtMarker\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      effects.enter('chunkString').contentType = 'string'\n      return labelInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In label.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n      if (!defined.includes(identifier)) {\n        defined.push(identifier)\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(\n        effects,\n        whitespaceAfter,\n        'gfmFootnoteDefinitionWhitespace'\n      )\n    }\n    return nok(code)\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n"],"names":["gfmFootnote","indent","tokenize","tokenizeIndent","partial","document","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","exit","gfmFootnoteDefinitionEnd","text","tokenizeGfmFootnoteCall","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","effects","ok","nok","self","index","events","length","defined","parser","gfmFootnotes","labelStart","token","type","start","code","_balanced","id","normalizeIdentifier","sliceSerialize","end","now","codePointAt","includes","slice","enter","consume","context","call","Object","assign","marker","column","offset","_bufferIndex","string","chunk","contentType","replacement","splice","size","data","callStart","callData","markdownLineEndingOrSpace","callEscape","identifier","_container","labelAtMarker","labelInside","labelAfter","labelEscape","push","factorySpace","whitespaceAfter","check","blankLine","attempt","afterPrefix","tail"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}