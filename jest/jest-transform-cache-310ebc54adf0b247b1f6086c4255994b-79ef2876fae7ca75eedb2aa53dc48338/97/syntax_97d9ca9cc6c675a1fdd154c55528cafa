13df28a2986101f6569e1e2ade34733b
/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "gfmFootnote", {
    enumerable: true,
    get: function() {
        return gfmFootnote;
    }
});
const _micromarkcorecommonmark = require("micromark-core-commonmark");
const _micromarkfactoryspace = require("micromark-factory-space");
const _micromarkutilcharacter = require("micromark-util-character");
const _micromarkutilnormalizeidentifier = require("micromark-util-normalize-identifier");
const indent = {
    tokenize: tokenizeIndent,
    partial: true
};
function gfmFootnote() {
    /** @type {Extension} */ return {
        document: {
            [91]: {
                tokenize: tokenizeDefinitionStart,
                continuation: {
                    tokenize: tokenizeDefinitionContinuation
                },
                exit: gfmFootnoteDefinitionEnd
            }
        },
        text: {
            [91]: {
                tokenize: tokenizeGfmFootnoteCall
            },
            [93]: {
                add: 'after',
                tokenize: tokenizePotentialGfmFootnoteCall,
                resolveTo: resolveToPotentialGfmFootnoteCall
            }
        }
    };
}
// To do: remove after micromark update.
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizePotentialGfmFootnoteCall(effects, ok, nok) {
    const self = this;
    let index = self.events.length;
    const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
    /** @type {Token} */ let labelStart;
    // Find an opening.
    while(index--){
        const token = self.events[index][1];
        if (token.type === 'labelImage') {
            labelStart = token;
            break;
        }
        // Exit if weâ€™ve walked far enough.
        if (token.type === 'gfmFootnoteCall' || token.type === 'labelLink' || token.type === 'label' || token.type === 'image' || token.type === 'link') {
            break;
        }
    }
    return start;
    /**
   * @type {State}
   */ function start(code) {
        if (!labelStart || !labelStart._balanced) {
            return nok(code);
        }
        const id = (0, _micromarkutilnormalizeidentifier.normalizeIdentifier)(self.sliceSerialize({
            start: labelStart.end,
            end: self.now()
        }));
        if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
            return nok(code);
        }
        effects.enter('gfmFootnoteCallLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallLabelMarker');
        return ok(code);
    }
}
// To do: remove after micromark update.
/** @type {Resolver} */ function resolveToPotentialGfmFootnoteCall(events, context) {
    let index = events.length;
    /** @type {Token | undefined} */ let labelStart;
    // Find an opening.
    while(index--){
        if (events[index][1].type === 'labelImage' && events[index][0] === 'enter') {
            labelStart = events[index][1];
            break;
        }
    }
    // Change the `labelImageMarker` to a `data`.
    events[index + 1][1].type = 'data';
    events[index + 3][1].type = 'gfmFootnoteCallLabelMarker';
    // The whole (without `!`):
    /** @type {Token} */ const call = {
        type: 'gfmFootnoteCall',
        start: Object.assign({}, events[index + 3][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
    };
    // The `^` marker
    /** @type {Token} */ const marker = {
        type: 'gfmFootnoteCallMarker',
        start: Object.assign({}, events[index + 3][1].end),
        end: Object.assign({}, events[index + 3][1].end)
    };
    // Increment the end 1 character.
    marker.end.column++;
    marker.end.offset++;
    marker.end._bufferIndex++;
    /** @type {Token} */ const string = {
        type: 'gfmFootnoteCallString',
        start: Object.assign({}, marker.end),
        end: Object.assign({}, events[events.length - 1][1].start)
    };
    /** @type {Token} */ const chunk = {
        type: 'chunkString',
        contentType: 'string',
        start: Object.assign({}, string.start),
        end: Object.assign({}, string.end)
    };
    /** @type {Array<Event>} */ const replacement = [
        // Take the `labelImageMarker` (now `data`, the `!`)
        events[index + 1],
        events[index + 2],
        [
            'enter',
            call,
            context
        ],
        // The `[`
        events[index + 3],
        events[index + 4],
        // The `^`.
        [
            'enter',
            marker,
            context
        ],
        [
            'exit',
            marker,
            context
        ],
        // Everything in between.
        [
            'enter',
            string,
            context
        ],
        [
            'enter',
            chunk,
            context
        ],
        [
            'exit',
            chunk,
            context
        ],
        [
            'exit',
            string,
            context
        ],
        // The ending (`]`, properly parsed and labelled).
        events[events.length - 2],
        events[events.length - 1],
        [
            'exit',
            call,
            context
        ]
    ];
    events.splice(index, events.length - index + 1, ...replacement);
    return events;
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeGfmFootnoteCall(effects, ok, nok) {
    const self = this;
    const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
    let size = 0;
    /** @type {boolean} */ let data;
    // Note: the implementation of `markdown-rs` is different, because it houses
    // core *and* extensions in one project.
    // Therefore, it can include footnote logic inside `label-end`.
    // We canâ€™t do that, but luckily, we can parse footnotes in a simpler way than
    // needed for labels.
    return start;
    /**
   * Start of footnote label.
   *
   * ```markdown
   * > | a [^b] c
   *       ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        effects.enter('gfmFootnoteCall');
        effects.enter('gfmFootnoteCallLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallLabelMarker');
        return callStart;
    }
    /**
   * After `[`, at `^`.
   *
   * ```markdown
   * > | a [^b] c
   *        ^
   * ```
   *
   * @type {State}
   */ function callStart(code) {
        if (code !== 94) return nok(code);
        effects.enter('gfmFootnoteCallMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallMarker');
        effects.enter('gfmFootnoteCallString');
        effects.enter('chunkString').contentType = 'string';
        return callData;
    }
    /**
   * In label.
   *
   * ```markdown
   * > | a [^b] c
   *         ^
   * ```
   *
   * @type {State}
   */ function callData(code) {
        if (// Too long.
        size > 999 || // Closing brace with nothing.
        code === 93 && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code === null || code === 91 || (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code)) {
            return nok(code);
        }
        if (code === 93) {
            effects.exit('chunkString');
            const token = effects.exit('gfmFootnoteCallString');
            if (!defined.includes((0, _micromarkutilnormalizeidentifier.normalizeIdentifier)(self.sliceSerialize(token)))) {
                return nok(code);
            }
            effects.enter('gfmFootnoteCallLabelMarker');
            effects.consume(code);
            effects.exit('gfmFootnoteCallLabelMarker');
            effects.exit('gfmFootnoteCall');
            return ok;
        }
        if (!(0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code)) {
            data = true;
        }
        size++;
        effects.consume(code);
        return code === 92 ? callEscape : callData;
    }
    /**
   * On character after escape.
   *
   * ```markdown
   * > | a [^b\c] d
   *           ^
   * ```
   *
   * @type {State}
   */ function callEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
            effects.consume(code);
            size++;
            return callData;
        }
        return callData(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeDefinitionStart(effects, ok, nok) {
    const self = this;
    const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
    /** @type {string} */ let identifier;
    let size = 0;
    /** @type {boolean | undefined} */ let data;
    return start;
    /**
   * Start of GFM footnote definition.
   *
   * ```markdown
   * > | [^a]: b
   *     ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        effects.enter('gfmFootnoteDefinition')._container = true;
        effects.enter('gfmFootnoteDefinitionLabel');
        effects.enter('gfmFootnoteDefinitionLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteDefinitionLabelMarker');
        return labelAtMarker;
    }
    /**
   * In label, at caret.
   *
   * ```markdown
   * > | [^a]: b
   *      ^
   * ```
   *
   * @type {State}
   */ function labelAtMarker(code) {
        if (code === 94) {
            effects.enter('gfmFootnoteDefinitionMarker');
            effects.consume(code);
            effects.exit('gfmFootnoteDefinitionMarker');
            effects.enter('gfmFootnoteDefinitionLabelString');
            effects.enter('chunkString').contentType = 'string';
            return labelInside;
        }
        return nok(code);
    }
    /**
   * In label.
   *
   * > ðŸ‘‰ **Note**: `cmark-gfm` prevents whitespace from occurring in footnote
   * > definition labels.
   *
   * ```markdown
   * > | [^a]: b
   *       ^
   * ```
   *
   * @type {State}
   */ function labelInside(code) {
        if (// Too long.
        size > 999 || // Closing brace with nothing.
        code === 93 && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code === null || code === 91 || (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code)) {
            return nok(code);
        }
        if (code === 93) {
            effects.exit('chunkString');
            const token = effects.exit('gfmFootnoteDefinitionLabelString');
            identifier = (0, _micromarkutilnormalizeidentifier.normalizeIdentifier)(self.sliceSerialize(token));
            effects.enter('gfmFootnoteDefinitionLabelMarker');
            effects.consume(code);
            effects.exit('gfmFootnoteDefinitionLabelMarker');
            effects.exit('gfmFootnoteDefinitionLabel');
            return labelAfter;
        }
        if (!(0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code)) {
            data = true;
        }
        size++;
        effects.consume(code);
        return code === 92 ? labelEscape : labelInside;
    }
    /**
   * After `\`, at a special character.
   *
   * > ðŸ‘‰ **Note**: `cmark-gfm` currently does not support escaped brackets:
   * > <https://github.com/github/cmark-gfm/issues/240>
   *
   * ```markdown
   * > | [^a\*b]: c
   *         ^
   * ```
   *
   * @type {State}
   */ function labelEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
            effects.consume(code);
            size++;
            return labelInside;
        }
        return labelInside(code);
    }
    /**
   * After definition label.
   *
   * ```markdown
   * > | [^a]: b
   *         ^
   * ```
   *
   * @type {State}
   */ function labelAfter(code) {
        if (code === 58) {
            effects.enter('definitionMarker');
            effects.consume(code);
            effects.exit('definitionMarker');
            if (!defined.includes(identifier)) {
                defined.push(identifier);
            }
            // Any whitespace after the marker is eaten, forming indented code
            // is not possible.
            // No space is also fine, just like a block quote marker.
            return (0, _micromarkfactoryspace.factorySpace)(effects, whitespaceAfter, 'gfmFootnoteDefinitionWhitespace');
        }
        return nok(code);
    }
    /**
   * After definition prefix.
   *
   * ```markdown
   * > | [^a]: b
   *           ^
   * ```
   *
   * @type {State}
   */ function whitespaceAfter(code) {
        // `markdown-rs` has a wrapping token for the prefix that is closed here.
        return ok(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeDefinitionContinuation(effects, ok, nok) {
    /// Start of footnote definition continuation.
    ///
    /// ```markdown
    ///   | [^a]: b
    /// > |     c
    ///     ^
    /// ```
    //
    // Either a blank line, which is okay, or an indented thing.
    return effects.check(_micromarkcorecommonmark.blankLine, ok, effects.attempt(indent, ok, nok));
}
/** @type {Exiter} */ function gfmFootnoteDefinitionEnd(effects) {
    effects.exit('gfmFootnoteDefinition');
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeIndent(effects, ok, nok) {
    const self = this;
    return (0, _micromarkfactoryspace.factorySpace)(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', 4 + 1);
    /**
   * @type {State}
   */ function afterPrefix(code) {
        const tail = self.events[self.events.length - 1];
        return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok(code) : nok(code);
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1mb290bm90ZS9saWIvc3ludGF4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXhpdGVyfSBFeGl0ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqL1xuXG5pbXBvcnQge2JsYW5rTGluZX0gZnJvbSAnbWljcm9tYXJrLWNvcmUtY29tbW9ubWFyaydcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2hhcmFjdGVyJ1xuaW1wb3J0IHtub3JtYWxpemVJZGVudGlmaWVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllcidcbmNvbnN0IGluZGVudCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplSW5kZW50LFxuICBwYXJ0aWFsOiB0cnVlXG59XG5cbi8vIFRvIGRvOiBtaWNyb21hcmsgc2hvdWxkIHN1cHBvcnQgYSBgX2hpZGRlbkdmbUZvb3Rub3RlU3VwcG9ydGAsIHdoaWNoIG9ubHlcbi8vIGFmZmVjdHMgbGFiZWwgc3RhcnQgKGltYWdlKS5cbi8vIFRoYXQgd2lsbCBsZXQgdXMgZHJvcCBgdG9rZW5pemVQb3RlbnRpYWxHZm1Gb290bm90ZSpgLlxuLy8gSXQgY3VycmVudGx5IGhhcyBhIGBfaGlkZGVuRm9vdG5vdGVTdXBwb3J0YCwgd2hpY2ggYWZmZWN0cyB0aGF0IGFuZCBtb3JlLlxuLy8gVGhhdCBjYW4gYmUgcmVtb3ZlZCB3aGVuIGBtaWNyb21hcmstZXh0ZW5zaW9uLWZvb3Rub3RlYCBpcyBhcmNoaXZlZC5cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0byBlbmFibGUgR0ZNIGZvb3Rub3RlIHN5bnRheC5cbiAqXG4gKiBAcmV0dXJucyB7RXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRoYXQgY2FuIGJlIHBhc3NlZCBpbiBgZXh0ZW5zaW9uc2AgdG9cbiAqICAgZW5hYmxlIEdGTSBmb290bm90ZSBzeW50YXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1Gb290bm90ZSgpIHtcbiAgLyoqIEB0eXBlIHtFeHRlbnNpb259ICovXG4gIHJldHVybiB7XG4gICAgZG9jdW1lbnQ6IHtcbiAgICAgIFs5MV06IHtcbiAgICAgICAgdG9rZW5pemU6IHRva2VuaXplRGVmaW5pdGlvblN0YXJ0LFxuICAgICAgICBjb250aW51YXRpb246IHtcbiAgICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVEZWZpbml0aW9uQ29udGludWF0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGV4aXQ6IGdmbUZvb3Rub3RlRGVmaW5pdGlvbkVuZFxuICAgICAgfVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgWzkxXToge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVHZm1Gb290bm90ZUNhbGxcbiAgICAgIH0sXG4gICAgICBbOTNdOiB7XG4gICAgICAgIGFkZDogJ2FmdGVyJyxcbiAgICAgICAgdG9rZW5pemU6IHRva2VuaXplUG90ZW50aWFsR2ZtRm9vdG5vdGVDYWxsLFxuICAgICAgICByZXNvbHZlVG86IHJlc29sdmVUb1BvdGVudGlhbEdmbUZvb3Rub3RlQ2FsbFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBUbyBkbzogcmVtb3ZlIGFmdGVyIG1pY3JvbWFyayB1cGRhdGUuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVBvdGVudGlhbEdmbUZvb3Rub3RlQ2FsbChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBpbmRleCA9IHNlbGYuZXZlbnRzLmxlbmd0aFxuICBjb25zdCBkZWZpbmVkID0gc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzIHx8IChzZWxmLnBhcnNlci5nZm1Gb290bm90ZXMgPSBbXSlcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgbGV0IGxhYmVsU3RhcnRcblxuICAvLyBGaW5kIGFuIG9wZW5pbmcuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgY29uc3QgdG9rZW4gPSBzZWxmLmV2ZW50c1tpbmRleF1bMV1cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xhYmVsSW1hZ2UnKSB7XG4gICAgICBsYWJlbFN0YXJ0ID0gdG9rZW5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gRXhpdCBpZiB3ZeKAmXZlIHdhbGtlZCBmYXIgZW5vdWdoLlxuICAgIGlmIChcbiAgICAgIHRva2VuLnR5cGUgPT09ICdnZm1Gb290bm90ZUNhbGwnIHx8XG4gICAgICB0b2tlbi50eXBlID09PSAnbGFiZWxMaW5rJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xhYmVsJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2ltYWdlJyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2xpbmsnXG4gICAgKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhcnRcblxuICAvKipcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGlmICghbGFiZWxTdGFydCB8fCAhbGFiZWxTdGFydC5fYmFsYW5jZWQpIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG4gICAgY29uc3QgaWQgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgc2VsZi5zbGljZVNlcmlhbGl6ZSh7XG4gICAgICAgIHN0YXJ0OiBsYWJlbFN0YXJ0LmVuZCxcbiAgICAgICAgZW5kOiBzZWxmLm5vdygpXG4gICAgICB9KVxuICAgIClcbiAgICBpZiAoaWQuY29kZVBvaW50QXQoMCkgIT09IDk0IHx8ICFkZWZpbmVkLmluY2x1ZGVzKGlkLnNsaWNlKDEpKSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cblxuLy8gVG8gZG86IHJlbW92ZSBhZnRlciBtaWNyb21hcmsgdXBkYXRlLlxuLyoqIEB0eXBlIHtSZXNvbHZlcn0gKi9cbmZ1bmN0aW9uIHJlc29sdmVUb1BvdGVudGlhbEdmbUZvb3Rub3RlQ2FsbChldmVudHMsIGNvbnRleHQpIHtcbiAgbGV0IGluZGV4ID0gZXZlbnRzLmxlbmd0aFxuICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgbGFiZWxTdGFydFxuXG4gIC8vIEZpbmQgYW4gb3BlbmluZy5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBpZiAoXG4gICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdsYWJlbEltYWdlJyAmJlxuICAgICAgZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJ1xuICAgICkge1xuICAgICAgbGFiZWxTdGFydCA9IGV2ZW50c1tpbmRleF1bMV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIC8vIENoYW5nZSB0aGUgYGxhYmVsSW1hZ2VNYXJrZXJgIHRvIGEgYGRhdGFgLlxuICBldmVudHNbaW5kZXggKyAxXVsxXS50eXBlID0gJ2RhdGEnXG4gIGV2ZW50c1tpbmRleCArIDNdWzFdLnR5cGUgPSAnZ2ZtRm9vdG5vdGVDYWxsTGFiZWxNYXJrZXInXG5cbiAgLy8gVGhlIHdob2xlICh3aXRob3V0IGAhYCk6XG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gIGNvbnN0IGNhbGwgPSB7XG4gICAgdHlwZTogJ2dmbUZvb3Rub3RlQ2FsbCcsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleCArIDNdWzFdLnN0YXJ0KSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uZW5kKVxuICB9XG4gIC8vIFRoZSBgXmAgbWFya2VyXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gIGNvbnN0IG1hcmtlciA9IHtcbiAgICB0eXBlOiAnZ2ZtRm9vdG5vdGVDYWxsTWFya2VyJyxcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4ICsgM11bMV0uZW5kKSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleCArIDNdWzFdLmVuZClcbiAgfVxuICAvLyBJbmNyZW1lbnQgdGhlIGVuZCAxIGNoYXJhY3Rlci5cbiAgbWFya2VyLmVuZC5jb2x1bW4rK1xuICBtYXJrZXIuZW5kLm9mZnNldCsrXG4gIG1hcmtlci5lbmQuX2J1ZmZlckluZGV4KytcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgY29uc3Qgc3RyaW5nID0ge1xuICAgIHR5cGU6ICdnZm1Gb290bm90ZUNhbGxTdHJpbmcnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBtYXJrZXIuZW5kKSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uc3RhcnQpXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgY29uc3QgY2h1bmsgPSB7XG4gICAgdHlwZTogJ2NodW5rU3RyaW5nJyxcbiAgICBjb250ZW50VHlwZTogJ3N0cmluZycsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIHN0cmluZy5zdGFydCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBzdHJpbmcuZW5kKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gIGNvbnN0IHJlcGxhY2VtZW50ID0gW1xuICAgIC8vIFRha2UgdGhlIGBsYWJlbEltYWdlTWFya2VyYCAobm93IGBkYXRhYCwgdGhlIGAhYClcbiAgICBldmVudHNbaW5kZXggKyAxXSxcbiAgICBldmVudHNbaW5kZXggKyAyXSxcbiAgICBbJ2VudGVyJywgY2FsbCwgY29udGV4dF0sXG4gICAgLy8gVGhlIGBbYFxuICAgIGV2ZW50c1tpbmRleCArIDNdLFxuICAgIGV2ZW50c1tpbmRleCArIDRdLFxuICAgIC8vIFRoZSBgXmAuXG4gICAgWydlbnRlcicsIG1hcmtlciwgY29udGV4dF0sXG4gICAgWydleGl0JywgbWFya2VyLCBjb250ZXh0XSxcbiAgICAvLyBFdmVyeXRoaW5nIGluIGJldHdlZW4uXG4gICAgWydlbnRlcicsIHN0cmluZywgY29udGV4dF0sXG4gICAgWydlbnRlcicsIGNodW5rLCBjb250ZXh0XSxcbiAgICBbJ2V4aXQnLCBjaHVuaywgY29udGV4dF0sXG4gICAgWydleGl0Jywgc3RyaW5nLCBjb250ZXh0XSxcbiAgICAvLyBUaGUgZW5kaW5nIChgXWAsIHByb3Blcmx5IHBhcnNlZCBhbmQgbGFiZWxsZWQpLlxuICAgIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMl0sXG4gICAgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXSxcbiAgICBbJ2V4aXQnLCBjYWxsLCBjb250ZXh0XVxuICBdXG4gIGV2ZW50cy5zcGxpY2UoaW5kZXgsIGV2ZW50cy5sZW5ndGggLSBpbmRleCArIDEsIC4uLnJlcGxhY2VtZW50KVxuICByZXR1cm4gZXZlbnRzXG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplR2ZtRm9vdG5vdGVDYWxsKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgZGVmaW5lZCA9IHNlbGYucGFyc2VyLmdmbUZvb3Rub3RlcyB8fCAoc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzID0gW10pXG4gIGxldCBzaXplID0gMFxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIGxldCBkYXRhXG5cbiAgLy8gTm90ZTogdGhlIGltcGxlbWVudGF0aW9uIG9mIGBtYXJrZG93bi1yc2AgaXMgZGlmZmVyZW50LCBiZWNhdXNlIGl0IGhvdXNlc1xuICAvLyBjb3JlICphbmQqIGV4dGVuc2lvbnMgaW4gb25lIHByb2plY3QuXG4gIC8vIFRoZXJlZm9yZSwgaXQgY2FuIGluY2x1ZGUgZm9vdG5vdGUgbG9naWMgaW5zaWRlIGBsYWJlbC1lbmRgLlxuICAvLyBXZSBjYW7igJl0IGRvIHRoYXQsIGJ1dCBsdWNraWx5LCB3ZSBjYW4gcGFyc2UgZm9vdG5vdGVzIGluIGEgc2ltcGxlciB3YXkgdGhhblxuICAvLyBuZWVkZWQgZm9yIGxhYmVscy5cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIGZvb3Rub3RlIGxhYmVsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSBbXmJdIGNcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbCcpXG4gICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVDYWxsTGFiZWxNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVDYWxsTGFiZWxNYXJrZXInKVxuICAgIHJldHVybiBjYWxsU3RhcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBgW2AsIGF0IGBeYC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGEgW15iXSBjXG4gICAqICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBjYWxsU3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlICE9PSA5NCkgcmV0dXJuIG5vayhjb2RlKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGxNYXJrZXInKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbFN0cmluZycpXG4gICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnKS5jb250ZW50VHlwZSA9ICdzdHJpbmcnXG4gICAgcmV0dXJuIGNhbGxEYXRhXG4gIH1cblxuICAvKipcbiAgICogSW4gbGFiZWwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIFteYl0gY1xuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGNhbGxEYXRhKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICAvLyBUb28gbG9uZy5cbiAgICAgIHNpemUgPiA5OTkgfHxcbiAgICAgIC8vIENsb3NpbmcgYnJhY2Ugd2l0aCBub3RoaW5nLlxuICAgICAgKGNvZGUgPT09IDkzICYmICFkYXRhKSB8fFxuICAgICAgLy8gU3BhY2Ugb3IgdGFiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgR0ZNIGZvciBzb21lIHJlYXNvbi5cbiAgICAgIC8vIGBcXG5gIGFuZCBgW2Agbm90IGJlaW5nIHN1cHBvcnRlZCBtYWtlcyBzZW5zZS5cbiAgICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIGNvZGUgPT09IDkxIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuICAgIGlmIChjb2RlID09PSA5Mykge1xuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICBjb25zdCB0b2tlbiA9IGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nJylcbiAgICAgIGlmICghZGVmaW5lZC5pbmNsdWRlcyhub3JtYWxpemVJZGVudGlmaWVyKHNlbGYuc2xpY2VTZXJpYWxpemUodG9rZW4pKSkpIHtcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfVxuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVDYWxsTGFiZWxNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVDYWxsJylcbiAgICAgIHJldHVybiBva1xuICAgIH1cbiAgICBpZiAoIW1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkpIHtcbiAgICAgIGRhdGEgPSB0cnVlXG4gICAgfVxuICAgIHNpemUrK1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBjb2RlID09PSA5MiA/IGNhbGxFc2NhcGUgOiBjYWxsRGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGNoYXJhY3RlciBhZnRlciBlc2NhcGUuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIFteYlxcY10gZFxuICAgKiAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsbEVzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDkxIHx8IGNvZGUgPT09IDkyIHx8IGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUrK1xuICAgICAgcmV0dXJuIGNhbGxEYXRhXG4gICAgfVxuICAgIHJldHVybiBjYWxsRGF0YShjb2RlKVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplRGVmaW5pdGlvblN0YXJ0KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgZGVmaW5lZCA9IHNlbGYucGFyc2VyLmdmbUZvb3Rub3RlcyB8fCAoc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzID0gW10pXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgaWRlbnRpZmllclxuICBsZXQgc2l6ZSA9IDBcbiAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgZGF0YVxuICByZXR1cm4gc3RhcnRcblxuICAvKipcbiAgICogU3RhcnQgb2YgR0ZNIGZvb3Rub3RlIGRlZmluaXRpb24uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbXmFdOiBiXG4gICAqICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uJykuX2NvbnRhaW5lciA9IHRydWVcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbCcpXG4gICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxNYXJrZXInKVxuICAgIHJldHVybiBsYWJlbEF0TWFya2VyXG4gIH1cblxuICAvKipcbiAgICogSW4gbGFiZWwsIGF0IGNhcmV0LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW15hXTogYlxuICAgKiAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGxhYmVsQXRNYXJrZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5NCkge1xuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZURlZmluaXRpb25NYXJrZXInKVxuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmcnKVxuICAgICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnKS5jb250ZW50VHlwZSA9ICdzdHJpbmcnXG4gICAgICByZXR1cm4gbGFiZWxJbnNpZGVcbiAgICB9XG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIGxhYmVsLlxuICAgKlxuICAgKiA+IPCfkYkgKipOb3RlKio6IGBjbWFyay1nZm1gIHByZXZlbnRzIHdoaXRlc3BhY2UgZnJvbSBvY2N1cnJpbmcgaW4gZm9vdG5vdGVcbiAgICogPiBkZWZpbml0aW9uIGxhYmVscy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFteYV06IGJcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gbGFiZWxJbnNpZGUoY29kZSkge1xuICAgIGlmIChcbiAgICAgIC8vIFRvbyBsb25nLlxuICAgICAgc2l6ZSA+IDk5OSB8fFxuICAgICAgLy8gQ2xvc2luZyBicmFjZSB3aXRoIG5vdGhpbmcuXG4gICAgICAoY29kZSA9PT0gOTMgJiYgIWRhdGEpIHx8XG4gICAgICAvLyBTcGFjZSBvciB0YWIgaXMgbm90IHN1cHBvcnRlZCBieSBHRk0gZm9yIHNvbWUgcmVhc29uLlxuICAgICAgLy8gYFxcbmAgYW5kIGBbYCBub3QgYmVpbmcgc3VwcG9ydGVkIG1ha2VzIHNlbnNlLlxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgY29kZSA9PT0gOTEgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDkzKSB7XG4gICAgICBlZmZlY3RzLmV4aXQoJ2NodW5rU3RyaW5nJylcbiAgICAgIGNvbnN0IHRva2VuID0gZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZycpXG4gICAgICBpZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihzZWxmLnNsaWNlU2VyaWFsaXplKHRva2VuKSlcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbE1hcmtlcicpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsJylcbiAgICAgIHJldHVybiBsYWJlbEFmdGVyXG4gICAgfVxuICAgIGlmICghbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSkge1xuICAgICAgZGF0YSA9IHRydWVcbiAgICB9XG4gICAgc2l6ZSsrXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IDkyID8gbGFiZWxFc2NhcGUgOiBsYWJlbEluc2lkZVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGBcXGAsIGF0IGEgc3BlY2lhbCBjaGFyYWN0ZXIuXG4gICAqXG4gICAqID4g8J+RiSAqKk5vdGUqKjogYGNtYXJrLWdmbWAgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgZXNjYXBlZCBicmFja2V0czpcbiAgICogPiA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vaXNzdWVzLzI0MD5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IFteYVxcKmJdOiBjXG4gICAqICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gbGFiZWxFc2NhcGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA5MSB8fCBjb2RlID09PSA5MiB8fCBjb2RlID09PSA5Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBzaXplKytcbiAgICAgIHJldHVybiBsYWJlbEluc2lkZVxuICAgIH1cbiAgICByZXR1cm4gbGFiZWxJbnNpZGUoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZWZpbml0aW9uIGxhYmVsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW15hXTogYlxuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGxhYmVsQWZ0ZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA1OCkge1xuICAgICAgZWZmZWN0cy5lbnRlcignZGVmaW5pdGlvbk1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnZGVmaW5pdGlvbk1hcmtlcicpXG4gICAgICBpZiAoIWRlZmluZWQuaW5jbHVkZXMoaWRlbnRpZmllcikpIHtcbiAgICAgICAgZGVmaW5lZC5wdXNoKGlkZW50aWZpZXIpXG4gICAgICB9XG5cbiAgICAgIC8vIEFueSB3aGl0ZXNwYWNlIGFmdGVyIHRoZSBtYXJrZXIgaXMgZWF0ZW4sIGZvcm1pbmcgaW5kZW50ZWQgY29kZVxuICAgICAgLy8gaXMgbm90IHBvc3NpYmxlLlxuICAgICAgLy8gTm8gc3BhY2UgaXMgYWxzbyBmaW5lLCBqdXN0IGxpa2UgYSBibG9jayBxdW90ZSBtYXJrZXIuXG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICB3aGl0ZXNwYWNlQWZ0ZXIsXG4gICAgICAgICdnZm1Gb290bm90ZURlZmluaXRpb25XaGl0ZXNwYWNlJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgZGVmaW5pdGlvbiBwcmVmaXguXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbXmFdOiBiXG4gICAqICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiB3aGl0ZXNwYWNlQWZ0ZXIoY29kZSkge1xuICAgIC8vIGBtYXJrZG93bi1yc2AgaGFzIGEgd3JhcHBpbmcgdG9rZW4gZm9yIHRoZSBwcmVmaXggdGhhdCBpcyBjbG9zZWQgaGVyZS5cbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZURlZmluaXRpb25Db250aW51YXRpb24oZWZmZWN0cywgb2ssIG5vaykge1xuICAvLy8gU3RhcnQgb2YgZm9vdG5vdGUgZGVmaW5pdGlvbiBjb250aW51YXRpb24uXG4gIC8vL1xuICAvLy8gYGBgbWFya2Rvd25cbiAgLy8vICAgfCBbXmFdOiBiXG4gIC8vLyA+IHwgICAgIGNcbiAgLy8vICAgICBeXG4gIC8vLyBgYGBcbiAgLy9cbiAgLy8gRWl0aGVyIGEgYmxhbmsgbGluZSwgd2hpY2ggaXMgb2theSwgb3IgYW4gaW5kZW50ZWQgdGhpbmcuXG4gIHJldHVybiBlZmZlY3RzLmNoZWNrKGJsYW5rTGluZSwgb2ssIGVmZmVjdHMuYXR0ZW1wdChpbmRlbnQsIG9rLCBub2spKVxufVxuXG4vKiogQHR5cGUge0V4aXRlcn0gKi9cbmZ1bmN0aW9uIGdmbUZvb3Rub3RlRGVmaW5pdGlvbkVuZChlZmZlY3RzKSB7XG4gIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uJylcbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVJbmRlbnQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgIGVmZmVjdHMsXG4gICAgYWZ0ZXJQcmVmaXgsXG4gICAgJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkluZGVudCcsXG4gICAgNCArIDFcbiAgKVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBhZnRlclByZWZpeChjb2RlKSB7XG4gICAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIHRhaWwgJiZcbiAgICAgIHRhaWxbMV0udHlwZSA9PT0gJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkluZGVudCcgJiZcbiAgICAgIHRhaWxbMl0uc2xpY2VTZXJpYWxpemUodGFpbFsxXSwgdHJ1ZSkubGVuZ3RoID09PSA0XG4gICAgICA/IG9rKGNvZGUpXG4gICAgICA6IG5vayhjb2RlKVxuICB9XG59XG4iXSwibmFtZXMiOlsiZ2ZtRm9vdG5vdGUiLCJpbmRlbnQiLCJ0b2tlbml6ZSIsInRva2VuaXplSW5kZW50IiwicGFydGlhbCIsImRvY3VtZW50IiwidG9rZW5pemVEZWZpbml0aW9uU3RhcnQiLCJjb250aW51YXRpb24iLCJ0b2tlbml6ZURlZmluaXRpb25Db250aW51YXRpb24iLCJleGl0IiwiZ2ZtRm9vdG5vdGVEZWZpbml0aW9uRW5kIiwidGV4dCIsInRva2VuaXplR2ZtRm9vdG5vdGVDYWxsIiwiYWRkIiwidG9rZW5pemVQb3RlbnRpYWxHZm1Gb290bm90ZUNhbGwiLCJyZXNvbHZlVG8iLCJyZXNvbHZlVG9Qb3RlbnRpYWxHZm1Gb290bm90ZUNhbGwiLCJlZmZlY3RzIiwib2siLCJub2siLCJzZWxmIiwiaW5kZXgiLCJldmVudHMiLCJsZW5ndGgiLCJkZWZpbmVkIiwicGFyc2VyIiwiZ2ZtRm9vdG5vdGVzIiwibGFiZWxTdGFydCIsInRva2VuIiwidHlwZSIsInN0YXJ0IiwiY29kZSIsIl9iYWxhbmNlZCIsImlkIiwibm9ybWFsaXplSWRlbnRpZmllciIsInNsaWNlU2VyaWFsaXplIiwiZW5kIiwibm93IiwiY29kZVBvaW50QXQiLCJpbmNsdWRlcyIsInNsaWNlIiwiZW50ZXIiLCJjb25zdW1lIiwiY29udGV4dCIsImNhbGwiLCJPYmplY3QiLCJhc3NpZ24iLCJtYXJrZXIiLCJjb2x1bW4iLCJvZmZzZXQiLCJfYnVmZmVySW5kZXgiLCJzdHJpbmciLCJjaHVuayIsImNvbnRlbnRUeXBlIiwicmVwbGFjZW1lbnQiLCJzcGxpY2UiLCJzaXplIiwiZGF0YSIsImNhbGxTdGFydCIsImNhbGxEYXRhIiwibWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSIsImNhbGxFc2NhcGUiLCJpZGVudGlmaWVyIiwiX2NvbnRhaW5lciIsImxhYmVsQXRNYXJrZXIiLCJsYWJlbEluc2lkZSIsImxhYmVsQWZ0ZXIiLCJsYWJlbEVzY2FwZSIsInB1c2giLCJmYWN0b3J5U3BhY2UiLCJ3aGl0ZXNwYWNlQWZ0ZXIiLCJjaGVjayIsImJsYW5rTGluZSIsImF0dGVtcHQiLCJhZnRlclByZWZpeCIsInRhaWwiXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0NBU0M7Ozs7K0JBd0JlQTs7O2VBQUFBOzs7eUNBdEJRO3VDQUNHO3dDQUNhO2tEQUNOO0FBQ2xDLE1BQU1DLFNBQVM7SUFDYkMsVUFBVUM7SUFDVkMsU0FBUztBQUNYO0FBZU8sU0FBU0o7SUFDZCxzQkFBc0IsR0FDdEIsT0FBTztRQUNMSyxVQUFVO1lBQ1IsQ0FBQyxHQUFHLEVBQUU7Z0JBQ0pILFVBQVVJO2dCQUNWQyxjQUFjO29CQUNaTCxVQUFVTTtnQkFDWjtnQkFDQUMsTUFBTUM7WUFDUjtRQUNGO1FBQ0FDLE1BQU07WUFDSixDQUFDLEdBQUcsRUFBRTtnQkFDSlQsVUFBVVU7WUFDWjtZ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