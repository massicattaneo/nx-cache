e7244db5f3f558fcdff2b0575691d146
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Previous} Previous
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "gfmAutolinkLiteral", {
    enumerable: true,
    get: function() {
        return gfmAutolinkLiteral;
    }
});
const _micromarkutilcharacter = require("micromark-util-character");
const wwwPrefix = {
    tokenize: tokenizeWwwPrefix,
    partial: true
};
const domain = {
    tokenize: tokenizeDomain,
    partial: true
};
const path = {
    tokenize: tokenizePath,
    partial: true
};
const trail = {
    tokenize: tokenizeTrail,
    partial: true
};
const emailDomainDotTrail = {
    tokenize: tokenizeEmailDomainDotTrail,
    partial: true
};
const wwwAutolink = {
    tokenize: tokenizeWwwAutolink,
    previous: previousWww
};
const protocolAutolink = {
    tokenize: tokenizeProtocolAutolink,
    previous: previousProtocol
};
const emailAutolink = {
    tokenize: tokenizeEmailAutolink,
    previous: previousEmail
};
/** @type {ConstructRecord} */ const text = {};
function gfmAutolinkLiteral() {
    return {
        text
    };
}
/** @type {Code} */ let code = 48;
// Add alphanumerics.
while(code < 123){
    text[code] = emailAutolink;
    code++;
    if (code === 58) code = 65;
    else if (code === 91) code = 97;
}
text[43] = emailAutolink;
text[45] = emailAutolink;
text[46] = emailAutolink;
text[95] = emailAutolink;
text[72] = [
    emailAutolink,
    protocolAutolink
];
text[104] = [
    emailAutolink,
    protocolAutolink
];
text[87] = [
    emailAutolink,
    wwwAutolink
];
text[119] = [
    emailAutolink,
    wwwAutolink
];
// To do: perform email autolink literals on events, afterwards.
// That’s where `markdown-rs` and `cmark-gfm` perform it.
// It should look for `@`, then for atext backwards, and then for a label
// forwards.
// To do: `mailto:`, `xmpp:` protocol as prefix.
/**
 * Email autolink literal.
 *
 * ```markdown
 * > | a contact@example.org b
 *       ^^^^^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeEmailAutolink(effects, ok, nok) {
    const self = this;
    /** @type {boolean | undefined} */ let dot;
    /** @type {boolean} */ let data;
    return start;
    /**
   * Start of email autolink literal.
   *
   * ```markdown
   * > | a contact@example.org b
   *       ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {
            return nok(code);
        }
        effects.enter('literalAutolink');
        effects.enter('literalAutolinkEmail');
        return atext(code);
    }
    /**
   * In email atext.
   *
   * ```markdown
   * > | a contact@example.org b
   *       ^
   * ```
   *
   * @type {State}
   */ function atext(code) {
        if (gfmAtext(code)) {
            effects.consume(code);
            return atext;
        }
        if (code === 64) {
            effects.consume(code);
            return emailDomain;
        }
        return nok(code);
    }
    /**
   * In email domain.
   *
   * The reference code is a bit overly complex as it handles the `@`, of which
   * there may be just one.
   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>
   *
   * ```markdown
   * > | a contact@example.org b
   *               ^
   * ```
   *
   * @type {State}
   */ function emailDomain(code) {
        // Dot followed by alphanumerical (not `-` or `_`).
        if (code === 46) {
            return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);
        }
        // Alphanumerical, `-`, and `_`.
        if (code === 45 || code === 95 || (0, _micromarkutilcharacter.asciiAlphanumeric)(code)) {
            data = true;
            effects.consume(code);
            return emailDomain;
        }
        // To do: `/` if xmpp.
        // Note: normally we’d truncate trailing punctuation from the link.
        // However, email autolink literals cannot contain any of those markers,
        // except for `.`, but that can only occur if it isn’t trailing.
        // So we can ignore truncating!
        return emailDomainAfter(code);
    }
    /**
   * In email domain, on dot that is not a trail.
   *
   * ```markdown
   * > | a contact@example.org b
   *                      ^
   * ```
   *
   * @type {State}
   */ function emailDomainDot(code) {
        effects.consume(code);
        dot = true;
        return emailDomain;
    }
    /**
   * After email domain.
   *
   * ```markdown
   * > | a contact@example.org b
   *                          ^
   * ```
   *
   * @type {State}
   */ function emailDomainAfter(code) {
        // Domain must not be empty, must include a dot, and must end in alphabetical.
        // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.
        if (data && dot && (0, _micromarkutilcharacter.asciiAlpha)(self.previous)) {
            effects.exit('literalAutolinkEmail');
            effects.exit('literalAutolink');
            return ok(code);
        }
        return nok(code);
    }
}
/**
 * `www` autolink literal.
 *
 * ```markdown
 * > | a www.example.org b
 *       ^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeWwwAutolink(effects, ok, nok) {
    const self = this;
    return wwwStart;
    /**
   * Start of www autolink literal.
   *
   * ```markdown
   * > | www.example.com/a?b#c
   *     ^
   * ```
   *
   * @type {State}
   */ function wwwStart(code) {
        if (code !== 87 && code !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {
            return nok(code);
        }
        effects.enter('literalAutolink');
        effects.enter('literalAutolinkWww');
        // Note: we *check*, so we can discard the `www.` we parsed.
        // If it worked, we consider it as a part of the domain.
        return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);
    }
    /**
   * After a www autolink literal.
   *
   * ```markdown
   * > | www.example.com/a?b#c
   *                          ^
   * ```
   *
   * @type {State}
   */ function wwwAfter(code) {
        effects.exit('literalAutolinkWww');
        effects.exit('literalAutolink');
        return ok(code);
    }
}
/**
 * Protocol autolink literal.
 *
 * ```markdown
 * > | a https://example.org b
 *       ^^^^^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeProtocolAutolink(effects, ok, nok) {
    const self = this;
    let buffer = '';
    let seen = false;
    return protocolStart;
    /**
   * Start of protocol autolink literal.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *     ^
   * ```
   *
   * @type {State}
   */ function protocolStart(code) {
        if ((code === 72 || code === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {
            effects.enter('literalAutolink');
            effects.enter('literalAutolinkHttp');
            buffer += String.fromCodePoint(code);
            effects.consume(code);
            return protocolPrefixInside;
        }
        return nok(code);
    }
    /**
   * In protocol.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *     ^^^^^
   * ```
   *
   * @type {State}
   */ function protocolPrefixInside(code) {
        // `5` is size of `https`
        if ((0, _micromarkutilcharacter.asciiAlpha)(code) && buffer.length < 5) {
            // @ts-expect-error: definitely number.
            buffer += String.fromCodePoint(code);
            effects.consume(code);
            return protocolPrefixInside;
        }
        if (code === 58) {
            const protocol = buffer.toLowerCase();
            if (protocol === 'http' || protocol === 'https') {
                effects.consume(code);
                return protocolSlashesInside;
            }
        }
        return nok(code);
    }
    /**
   * In slashes.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *           ^^
   * ```
   *
   * @type {State}
   */ function protocolSlashesInside(code) {
        if (code === 47) {
            effects.consume(code);
            if (seen) {
                return afterProtocol;
            }
            seen = true;
            return protocolSlashesInside;
        }
        return nok(code);
    }
    /**
   * After protocol, before domain.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *             ^
   * ```
   *
   * @type {State}
   */ function afterProtocol(code) {
        // To do: this is different from `markdown-rs`:
        // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182
        return code === null || (0, _micromarkutilcharacter.asciiControl)(code) || (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) || (0, _micromarkutilcharacter.unicodeWhitespace)(code) || (0, _micromarkutilcharacter.unicodePunctuation)(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);
    }
    /**
   * After a protocol autolink literal.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *                              ^
   * ```
   *
   * @type {State}
   */ function protocolAfter(code) {
        effects.exit('literalAutolinkHttp');
        effects.exit('literalAutolink');
        return ok(code);
    }
}
/**
 * `www` prefix.
 *
 * ```markdown
 * > | a www.example.org b
 *       ^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeWwwPrefix(effects, ok, nok) {
    let size = 0;
    return wwwPrefixInside;
    /**
   * In www prefix.
   *
   * ```markdown
   * > | www.example.com
   *     ^^^^
   * ```
   *
   * @type {State}
   */ function wwwPrefixInside(code) {
        if ((code === 87 || code === 119) && size < 3) {
            size++;
            effects.consume(code);
            return wwwPrefixInside;
        }
        if (code === 46 && size === 3) {
            effects.consume(code);
            return wwwPrefixAfter;
        }
        return nok(code);
    }
    /**
   * After www prefix.
   *
   * ```markdown
   * > | www.example.com
   *         ^
   * ```
   *
   * @type {State}
   */ function wwwPrefixAfter(code) {
        // If there is *anything*, we can link.
        return code === null ? nok(code) : ok(code);
    }
}
/**
 * Domain.
 *
 * ```markdown
 * > | a https://example.org b
 *               ^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeDomain(effects, ok, nok) {
    /** @type {boolean | undefined} */ let underscoreInLastSegment;
    /** @type {boolean | undefined} */ let underscoreInLastLastSegment;
    /** @type {boolean | undefined} */ let seen;
    return domainInside;
    /**
   * In domain.
   *
   * ```markdown
   * > | https://example.com/a
   *             ^^^^^^^^^^^
   * ```
   *
   * @type {State}
   */ function domainInside(code) {
        // Check whether this marker, which is a trailing punctuation
        // marker, optionally followed by more trailing markers, and then
        // followed by an end.
        if (code === 46 || code === 95) {
            return effects.check(trail, domainAfter, domainAtPunctuation)(code);
        }
        // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can
        // occur, which sounds like ASCII only, but they also support `www.點看.com`,
        // so that’s Unicode.
        // Instead of some new production for Unicode alphanumerics, markdown
        // already has that for Unicode punctuation and whitespace, so use those.
        // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.
        if (code === null || (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) || (0, _micromarkutilcharacter.unicodeWhitespace)(code) || code !== 45 && (0, _micromarkutilcharacter.unicodePunctuation)(code)) {
            return domainAfter(code);
        }
        seen = true;
        effects.consume(code);
        return domainInside;
    }
    /**
   * In domain, at potential trailing punctuation, that was not trailing.
   *
   * ```markdown
   * > | https://example.com
   *                    ^
   * ```
   *
   * @type {State}
   */ function domainAtPunctuation(code) {
        // There is an underscore in the last segment of the domain
        if (code === 95) {
            underscoreInLastSegment = true;
        } else {
            underscoreInLastLastSegment = underscoreInLastSegment;
            underscoreInLastSegment = undefined;
        }
        effects.consume(code);
        return domainInside;
    }
    /**
   * After domain.
   *
   * ```markdown
   * > | https://example.com/a
   *                        ^
   * ```
   *
   * @type {State} */ function domainAfter(code) {
        // Note: that’s GH says a dot is needed, but it’s not true:
        // <https://github.com/github/cmark-gfm/issues/279>
        if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
            return nok(code);
        }
        return ok(code);
    }
}
/**
 * Path.
 *
 * ```markdown
 * > | a https://example.org/stuff b
 *                          ^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizePath(effects, ok) {
    let sizeOpen = 0;
    let sizeClose = 0;
    return pathInside;
    /**
   * In path.
   *
   * ```markdown
   * > | https://example.com/a
   *                        ^^
   * ```
   *
   * @type {State}
   */ function pathInside(code) {
        if (code === 40) {
            sizeOpen++;
            effects.consume(code);
            return pathInside;
        }
        // To do: `markdown-rs` also needs this.
        // If this is a paren, and there are less closings than openings,
        // we don’t check for a trail.
        if (code === 41 && sizeClose < sizeOpen) {
            return pathAtPunctuation(code);
        }
        // Check whether this trailing punctuation marker is optionally
        // followed by more trailing markers, and then followed
        // by an end.
        if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {
            return effects.check(trail, ok, pathAtPunctuation)(code);
        }
        if (code === null || (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) || (0, _micromarkutilcharacter.unicodeWhitespace)(code)) {
            return ok(code);
        }
        effects.consume(code);
        return pathInside;
    }
    /**
   * In path, at potential trailing punctuation, that was not trailing.
   *
   * ```markdown
   * > | https://example.com/a"b
   *                          ^
   * ```
   *
   * @type {State}
   */ function pathAtPunctuation(code) {
        // Count closing parens.
        if (code === 41) {
            sizeClose++;
        }
        effects.consume(code);
        return pathInside;
    }
}
/**
 * Trail.
 *
 * This calls `ok` if this *is* the trail, followed by an end, which means
 * the entire trail is not part of the link.
 * It calls `nok` if this *is* part of the link.
 *
 * ```markdown
 * > | https://example.com").
 *                        ^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeTrail(effects, ok, nok) {
    return trail;
    /**
   * In trail of domain or path.
   *
   * ```markdown
   * > | https://example.com").
   *                        ^
   * ```
   *
   * @type {State}
   */ function trail(code) {
        // Regular trailing punctuation.
        if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {
            effects.consume(code);
            return trail;
        }
        // `&` followed by one or more alphabeticals and then a `;`, is
        // as a whole considered as trailing punctuation.
        // In all other cases, it is considered as continuation of the URL.
        if (code === 38) {
            effects.consume(code);
            return trailCharRefStart;
        }
        // Needed because we allow literals after `[`, as we fix:
        // <https://github.com/github/cmark-gfm/issues/278>.
        // Check that it is not followed by `(` or `[`.
        if (code === 93) {
            effects.consume(code);
            return trailBracketAfter;
        }
        if (// `<` is an end.
        code === 60 || // So is whitespace.
        code === null || (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) || (0, _micromarkutilcharacter.unicodeWhitespace)(code)) {
            return ok(code);
        }
        return nok(code);
    }
    /**
   * In trail, after `]`.
   *
   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.
   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.
   *
   * ```markdown
   * > | https://example.com](
   *                         ^
   * ```
   *
   * @type {State}
   */ function trailBracketAfter(code) {
        // Whitespace or something that could start a resource or reference is the end.
        // Switch back to trail otherwise.
        if (code === null || code === 40 || code === 91 || (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code) || (0, _micromarkutilcharacter.unicodeWhitespace)(code)) {
            return ok(code);
        }
        return trail(code);
    }
    /**
   * In character-reference like trail, after `&`.
   *
   * ```markdown
   * > | https://example.com&amp;).
   *                         ^
   * ```
   *
   * @type {State}
   */ function trailCharRefStart(code) {
        // When non-alpha, it’s not a trail.
        return (0, _micromarkutilcharacter.asciiAlpha)(code) ? trailCharRefInside(code) : nok(code);
    }
    /**
   * In character-reference like trail.
   *
   * ```markdown
   * > | https://example.com&amp;).
   *                         ^
   * ```
   *
   * @type {State}
   */ function trailCharRefInside(code) {
        // Switch back to trail if this is well-formed.
        if (code === 59) {
            effects.consume(code);
            return trail;
        }
        if ((0, _micromarkutilcharacter.asciiAlpha)(code)) {
            effects.consume(code);
            return trailCharRefInside;
        }
        // It’s not a trail.
        return nok(code);
    }
}
/**
 * Dot in email domain trail.
 *
 * This calls `ok` if this *is* the trail, followed by an end, which means
 * the trail is not part of the link.
 * It calls `nok` if this *is* part of the link.
 *
 * ```markdown
 * > | contact@example.org.
 *                        ^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeEmailDomainDotTrail(effects, ok, nok) {
    return start;
    /**
   * Dot.
   *
   * ```markdown
   * > | contact@example.org.
   *                    ^   ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        // Must be dot.
        effects.consume(code);
        return after;
    }
    /**
   * After dot.
   *
   * ```markdown
   * > | contact@example.org.
   *                     ^   ^
   * ```
   *
   * @type {State}
   */ function after(code) {
        // Not a trail if alphanumeric.
        return (0, _micromarkutilcharacter.asciiAlphanumeric)(code) ? nok(code) : ok(code);
    }
}
/**
 * See:
 * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.
 *
 * @type {Previous}
 */ function previousWww(code) {
    return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || (0, _micromarkutilcharacter.markdownLineEndingOrSpace)(code);
}
/**
 * See:
 * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.
 *
 * @type {Previous}
 */ function previousProtocol(code) {
    return !(0, _micromarkutilcharacter.asciiAlpha)(code);
}
/**
 * @this {TokenizeContext}
 * @type {Previous}
 */ function previousEmail(code) {
    // Do not allow a slash “inside” atext.
    // The reference code is a bit weird, but that’s what it results in.
    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.
    // Other than slash, every preceding character is allowed.
    return !(code === 47 || gfmAtext(code));
}
/**
 * @param {Code} code
 * @returns {boolean}
 */ function gfmAtext(code) {
    return code === 43 || code === 45 || code === 46 || code === 95 || (0, _micromarkutilcharacter.asciiAlphanumeric)(code);
}
/**
 * @param {Array<Event>} events
 * @returns {boolean}
 */ function previousUnbalanced(events) {
    let index = events.length;
    let result = false;
    while(index--){
        const token = events[index][1];
        if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {
            result = true;
            break;
        }
        // If we’ve seen this token, and it was marked as not having any unbalanced
        // bracket before it, we can exit.
        if (token._gfmAutolinkLiteralWalkedInto) {
            result = false;
            break;
        }
    }
    if (events.length > 0 && !result) {
        // Mark the last token as “walked into” w/o finding
        // anything.
        events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
    }
    return result;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsL2xpYi9zeW50YXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvZGV9IENvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29uc3RydWN0UmVjb3JkfSBDb25zdHJ1Y3RSZWNvcmRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlByZXZpb3VzfSBQcmV2aW91c1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqL1xuXG5pbXBvcnQge1xuICBhc2NpaUFscGhhLFxuICBhc2NpaUFscGhhbnVtZXJpYyxcbiAgYXNjaWlDb250cm9sLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICB1bmljb2RlUHVuY3R1YXRpb24sXG4gIHVuaWNvZGVXaGl0ZXNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmNvbnN0IHd3d1ByZWZpeCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplV3d3UHJlZml4LFxuICBwYXJ0aWFsOiB0cnVlXG59XG5jb25zdCBkb21haW4gPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZURvbWFpbixcbiAgcGFydGlhbDogdHJ1ZVxufVxuY29uc3QgcGF0aCA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplUGF0aCxcbiAgcGFydGlhbDogdHJ1ZVxufVxuY29uc3QgdHJhaWwgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZVRyYWlsLFxuICBwYXJ0aWFsOiB0cnVlXG59XG5jb25zdCBlbWFpbERvbWFpbkRvdFRyYWlsID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVFbWFpbERvbWFpbkRvdFRyYWlsLFxuICBwYXJ0aWFsOiB0cnVlXG59XG5jb25zdCB3d3dBdXRvbGluayA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplV3d3QXV0b2xpbmssXG4gIHByZXZpb3VzOiBwcmV2aW91c1d3d1xufVxuY29uc3QgcHJvdG9jb2xBdXRvbGluayA9IHtcbiAgdG9rZW5pemU6IHRva2VuaXplUHJvdG9jb2xBdXRvbGluayxcbiAgcHJldmlvdXM6IHByZXZpb3VzUHJvdG9jb2xcbn1cbmNvbnN0IGVtYWlsQXV0b2xpbmsgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUVtYWlsQXV0b2xpbmssXG4gIHByZXZpb3VzOiBwcmV2aW91c0VtYWlsXG59XG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0UmVjb3JkfSAqL1xuY29uc3QgdGV4dCA9IHt9XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdG8gc3VwcG9ydCBHaXRIdWIgYXV0b2xpbmsgbGl0ZXJhbFxuICogc3ludGF4LlxuICpcbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBleHRlbnNpb25zYCB0byBlbmFibGUgR0ZNXG4gKiAgIGF1dG9saW5rIGxpdGVyYWwgc3ludGF4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtQXV0b2xpbmtMaXRlcmFsKCkge1xuICByZXR1cm4ge1xuICAgIHRleHRcbiAgfVxufVxuXG4vKiogQHR5cGUge0NvZGV9ICovXG5sZXQgY29kZSA9IDQ4XG5cbi8vIEFkZCBhbHBoYW51bWVyaWNzLlxud2hpbGUgKGNvZGUgPCAxMjMpIHtcbiAgdGV4dFtjb2RlXSA9IGVtYWlsQXV0b2xpbmtcbiAgY29kZSsrXG4gIGlmIChjb2RlID09PSA1OCkgY29kZSA9IDY1XG4gIGVsc2UgaWYgKGNvZGUgPT09IDkxKSBjb2RlID0gOTdcbn1cbnRleHRbNDNdID0gZW1haWxBdXRvbGlua1xudGV4dFs0NV0gPSBlbWFpbEF1dG9saW5rXG50ZXh0WzQ2XSA9IGVtYWlsQXV0b2xpbmtcbnRleHRbOTVdID0gZW1haWxBdXRvbGlua1xudGV4dFs3Ml0gPSBbZW1haWxBdXRvbGluaywgcHJvdG9jb2xBdXRvbGlua11cbnRleHRbMTA0XSA9IFtlbWFpbEF1dG9saW5rLCBwcm90b2NvbEF1dG9saW5rXVxudGV4dFs4N10gPSBbZW1haWxBdXRvbGluaywgd3d3QXV0b2xpbmtdXG50ZXh0WzExOV0gPSBbZW1haWxBdXRvbGluaywgd3d3QXV0b2xpbmtdXG5cbi8vIFRvIGRvOiBwZXJmb3JtIGVtYWlsIGF1dG9saW5rIGxpdGVyYWxzIG9uIGV2ZW50cywgYWZ0ZXJ3YXJkcy5cbi8vIFRoYXTigJlzIHdoZXJlIGBtYXJrZG93bi1yc2AgYW5kIGBjbWFyay1nZm1gIHBlcmZvcm0gaXQuXG4vLyBJdCBzaG91bGQgbG9vayBmb3IgYEBgLCB0aGVuIGZvciBhdGV4dCBiYWNrd2FyZHMsIGFuZCB0aGVuIGZvciBhIGxhYmVsXG4vLyBmb3J3YXJkcy5cbi8vIFRvIGRvOiBgbWFpbHRvOmAsIGB4bXBwOmAgcHJvdG9jb2wgYXMgcHJlZml4LlxuXG4vKipcbiAqIEVtYWlsIGF1dG9saW5rIGxpdGVyYWwuXG4gKlxuICogYGBgbWFya2Rvd25cbiAqID4gfCBhIGNvbnRhY3RAZXhhbXBsZS5vcmcgYlxuICogICAgICAgXl5eXl5eXl5eXl5eXl5eXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplRW1haWxBdXRvbGluayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGRvdFxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIGxldCBkYXRhXG4gIHJldHVybiBzdGFydFxuXG4gIC8qKlxuICAgKiBTdGFydCBvZiBlbWFpbCBhdXRvbGluayBsaXRlcmFsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSBjb250YWN0QGV4YW1wbGUub3JnIGJcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGlmIChcbiAgICAgICFnZm1BdGV4dChjb2RlKSB8fFxuICAgICAgIXByZXZpb3VzRW1haWwuY2FsbChzZWxmLCBzZWxmLnByZXZpb3VzKSB8fFxuICAgICAgcHJldmlvdXNVbmJhbGFuY2VkKHNlbGYuZXZlbnRzKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cbiAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGlua0VtYWlsJylcbiAgICByZXR1cm4gYXRleHQoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBlbWFpbCBhdGV4dC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGEgY29udGFjdEBleGFtcGxlLm9yZyBiXG4gICAqICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGF0ZXh0KGNvZGUpIHtcbiAgICBpZiAoZ2ZtQXRleHQoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGF0ZXh0XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA2NCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZW1haWxEb21haW5cbiAgICB9XG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIGVtYWlsIGRvbWFpbi5cbiAgICpcbiAgICogVGhlIHJlZmVyZW5jZSBjb2RlIGlzIGEgYml0IG92ZXJseSBjb21wbGV4IGFzIGl0IGhhbmRsZXMgdGhlIGBAYCwgb2Ygd2hpY2hcbiAgICogdGhlcmUgbWF5IGJlIGp1c3Qgb25lLlxuICAgKiBTb3VyY2U6IDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9ibG9iL2VmMWNmY2IvZXh0ZW5zaW9ucy9hdXRvbGluay5jI0wzMTg+XG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIGNvbnRhY3RAZXhhbXBsZS5vcmcgYlxuICAgKiAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVtYWlsRG9tYWluKGNvZGUpIHtcbiAgICAvLyBEb3QgZm9sbG93ZWQgYnkgYWxwaGFudW1lcmljYWwgKG5vdCBgLWAgb3IgYF9gKS5cbiAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKFxuICAgICAgICBlbWFpbERvbWFpbkRvdFRyYWlsLFxuICAgICAgICBlbWFpbERvbWFpbkFmdGVyLFxuICAgICAgICBlbWFpbERvbWFpbkRvdFxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIC8vIEFscGhhbnVtZXJpY2FsLCBgLWAsIGFuZCBgX2AuXG4gICAgaWYgKGNvZGUgPT09IDQ1IHx8IGNvZGUgPT09IDk1IHx8IGFzY2lpQWxwaGFudW1lcmljKGNvZGUpKSB7XG4gICAgICBkYXRhID0gdHJ1ZVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZW1haWxEb21haW5cbiAgICB9XG5cbiAgICAvLyBUbyBkbzogYC9gIGlmIHhtcHAuXG5cbiAgICAvLyBOb3RlOiBub3JtYWxseSB3ZeKAmWQgdHJ1bmNhdGUgdHJhaWxpbmcgcHVuY3R1YXRpb24gZnJvbSB0aGUgbGluay5cbiAgICAvLyBIb3dldmVyLCBlbWFpbCBhdXRvbGluayBsaXRlcmFscyBjYW5ub3QgY29udGFpbiBhbnkgb2YgdGhvc2UgbWFya2VycyxcbiAgICAvLyBleGNlcHQgZm9yIGAuYCwgYnV0IHRoYXQgY2FuIG9ubHkgb2NjdXIgaWYgaXQgaXNu4oCZdCB0cmFpbGluZy5cbiAgICAvLyBTbyB3ZSBjYW4gaWdub3JlIHRydW5jYXRpbmchXG4gICAgcmV0dXJuIGVtYWlsRG9tYWluQWZ0ZXIoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBlbWFpbCBkb21haW4sIG9uIGRvdCB0aGF0IGlzIG5vdCBhIHRyYWlsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSBjb250YWN0QGV4YW1wbGUub3JnIGJcbiAgICogICAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW1haWxEb21haW5Eb3QoY29kZSkge1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGRvdCA9IHRydWVcbiAgICByZXR1cm4gZW1haWxEb21haW5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBlbWFpbCBkb21haW4uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIGNvbnRhY3RAZXhhbXBsZS5vcmcgYlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW1haWxEb21haW5BZnRlcihjb2RlKSB7XG4gICAgLy8gRG9tYWluIG11c3Qgbm90IGJlIGVtcHR5LCBtdXN0IGluY2x1ZGUgYSBkb3QsIGFuZCBtdXN0IGVuZCBpbiBhbHBoYWJldGljYWwuXG4gICAgLy8gU291cmNlOiA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vYmxvYi9lZjFjZmNiL2V4dGVuc2lvbnMvYXV0b2xpbmsuYyNMMzMyPi5cbiAgICBpZiAoZGF0YSAmJiBkb3QgJiYgYXNjaWlBbHBoYShzZWxmLnByZXZpb3VzKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmtFbWFpbCcpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogYHd3d2AgYXV0b2xpbmsgbGl0ZXJhbC5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGEgd3d3LmV4YW1wbGUub3JnIGJcbiAqICAgICAgIF5eXl5eXl5eXl5eXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplV3d3QXV0b2xpbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICByZXR1cm4gd3d3U3RhcnRcblxuICAvKipcbiAgICogU3RhcnQgb2Ygd3d3IGF1dG9saW5rIGxpdGVyYWwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB3d3cuZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHd3d1N0YXJ0KGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICAoY29kZSAhPT0gODcgJiYgY29kZSAhPT0gMTE5KSB8fFxuICAgICAgIXByZXZpb3VzV3d3LmNhbGwoc2VsZiwgc2VsZi5wcmV2aW91cykgfHxcbiAgICAgIHByZXZpb3VzVW5iYWxhbmNlZChzZWxmLmV2ZW50cylcbiAgICApIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG4gICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rJylcbiAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmtXd3cnKVxuICAgIC8vIE5vdGU6IHdlICpjaGVjayosIHNvIHdlIGNhbiBkaXNjYXJkIHRoZSBgd3d3LmAgd2UgcGFyc2VkLlxuICAgIC8vIElmIGl0IHdvcmtlZCwgd2UgY29uc2lkZXIgaXQgYXMgYSBwYXJ0IG9mIHRoZSBkb21haW4uXG4gICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICB3d3dQcmVmaXgsXG4gICAgICBlZmZlY3RzLmF0dGVtcHQoZG9tYWluLCBlZmZlY3RzLmF0dGVtcHQocGF0aCwgd3d3QWZ0ZXIpLCBub2spLFxuICAgICAgbm9rXG4gICAgKShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGEgd3d3IGF1dG9saW5rIGxpdGVyYWwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB3d3cuZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHd3d0FmdGVyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGlua1d3dycpXG4gICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogUHJvdG9jb2wgYXV0b2xpbmsgbGl0ZXJhbC5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGEgaHR0cHM6Ly9leGFtcGxlLm9yZyBiXG4gKiAgICAgICBeXl5eXl5eXl5eXl5eXl5eXl5eXG4gKiBgYGBcbiAqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVQcm90b2NvbEF1dG9saW5rKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgbGV0IGJ1ZmZlciA9ICcnXG4gIGxldCBzZWVuID0gZmFsc2VcbiAgcmV0dXJuIHByb3RvY29sU3RhcnRcblxuICAvKipcbiAgICogU3RhcnQgb2YgcHJvdG9jb2wgYXV0b2xpbmsgbGl0ZXJhbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvY29sU3RhcnQoY29kZSkge1xuICAgIGlmIChcbiAgICAgIChjb2RlID09PSA3MiB8fCBjb2RlID09PSAxMDQpICYmXG4gICAgICBwcmV2aW91c1Byb3RvY29sLmNhbGwoc2VsZiwgc2VsZi5wcmV2aW91cykgJiZcbiAgICAgICFwcmV2aW91c1VuYmFsYW5jZWQoc2VsZi5ldmVudHMpXG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rSHR0cCcpXG4gICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHByb3RvY29sUHJlZml4SW5zaWRlXG4gICAgfVxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBwcm90b2NvbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgIF5eXl5eXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBwcm90b2NvbFByZWZpeEluc2lkZShjb2RlKSB7XG4gICAgLy8gYDVgIGlzIHNpemUgb2YgYGh0dHBzYFxuICAgIGlmIChhc2NpaUFscGhhKGNvZGUpICYmIGJ1ZmZlci5sZW5ndGggPCA1KSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBkZWZpbml0ZWx5IG51bWJlci5cbiAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gcHJvdG9jb2xQcmVmaXhJbnNpZGVcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDU4KSB7XG4gICAgICBjb25zdCBwcm90b2NvbCA9IGJ1ZmZlci50b0xvd2VyQ2FzZSgpXG4gICAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwJyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzJykge1xuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgcmV0dXJuIHByb3RvY29sU2xhc2hlc0luc2lkZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gc2xhc2hlcy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgICAgICAgIF5eXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBwcm90b2NvbFNsYXNoZXNJbnNpZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBpZiAoc2Vlbikge1xuICAgICAgICByZXR1cm4gYWZ0ZXJQcm90b2NvbFxuICAgICAgfVxuICAgICAgc2VlbiA9IHRydWVcbiAgICAgIHJldHVybiBwcm90b2NvbFNsYXNoZXNJbnNpZGVcbiAgICB9XG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIHByb3RvY29sLCBiZWZvcmUgZG9tYWluLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hP2IjY1xuICAgKiAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBhZnRlclByb3RvY29sKGNvZGUpIHtcbiAgICAvLyBUbyBkbzogdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBgbWFya2Rvd24tcnNgOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vbWFya2Rvd24tcnMvYmxvYi9iM2E5MjFjNzYxMzA5YWUwMGE1MWZlMzQ4ZDhhNDNhZGJjNTRiNTE4L3NyYy9jb25zdHJ1Y3QvZ2ZtX2F1dG9saW5rX2xpdGVyYWwucnMjTDE3Mi1MMTgyXG4gICAgcmV0dXJuIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIGFzY2lpQ29udHJvbChjb2RlKSB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVQdW5jdHVhdGlvbihjb2RlKVxuICAgICAgPyBub2soY29kZSlcbiAgICAgIDogZWZmZWN0cy5hdHRlbXB0KGRvbWFpbiwgZWZmZWN0cy5hdHRlbXB0KHBhdGgsIHByb3RvY29sQWZ0ZXIpLCBub2spKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgYSBwcm90b2NvbCBhdXRvbGluayBsaXRlcmFsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hP2IjY1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvY29sQWZ0ZXIoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rSHR0cCcpXG4gICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogYHd3d2AgcHJlZml4LlxuICpcbiAqIGBgYG1hcmtkb3duXG4gKiA+IHwgYSB3d3cuZXhhbXBsZS5vcmcgYlxuICogICAgICAgXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplV3d3UHJlZml4KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgbGV0IHNpemUgPSAwXG4gIHJldHVybiB3d3dQcmVmaXhJbnNpZGVcblxuICAvKipcbiAgICogSW4gd3d3IHByZWZpeC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHd3dy5leGFtcGxlLmNvbVxuICAgKiAgICAgXl5eXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gd3d3UHJlZml4SW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoKGNvZGUgPT09IDg3IHx8IGNvZGUgPT09IDExOSkgJiYgc2l6ZSA8IDMpIHtcbiAgICAgIHNpemUrK1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gd3d3UHJlZml4SW5zaWRlXG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0NiAmJiBzaXplID09PSAzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB3d3dQcmVmaXhBZnRlclxuICAgIH1cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgd3d3IHByZWZpeC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHd3dy5leGFtcGxlLmNvbVxuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHd3d1ByZWZpeEFmdGVyKGNvZGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyAqYW55dGhpbmcqLCB3ZSBjYW4gbGluay5cbiAgICByZXR1cm4gY29kZSA9PT0gbnVsbCA/IG5vayhjb2RlKSA6IG9rKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBEb21haW4uXG4gKlxuICogYGBgbWFya2Rvd25cbiAqID4gfCBhIGh0dHBzOi8vZXhhbXBsZS5vcmcgYlxuICogICAgICAgICAgICAgICBeXl5eXl5eXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplRG9tYWluKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgdW5kZXJzY29yZUluTGFzdFNlZ21lbnRcbiAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgdW5kZXJzY29yZUluTGFzdExhc3RTZWdtZW50XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHNlZW5cbiAgcmV0dXJuIGRvbWFpbkluc2lkZVxuXG4gIC8qKlxuICAgKiBJbiBkb21haW4uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2FcbiAgICogICAgICAgICAgICAgXl5eXl5eXl5eXl5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGRvbWFpbkluc2lkZShjb2RlKSB7XG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIG1hcmtlciwgd2hpY2ggaXMgYSB0cmFpbGluZyBwdW5jdHVhdGlvblxuICAgIC8vIG1hcmtlciwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBtb3JlIHRyYWlsaW5nIG1hcmtlcnMsIGFuZCB0aGVuXG4gICAgLy8gZm9sbG93ZWQgYnkgYW4gZW5kLlxuICAgIGlmIChjb2RlID09PSA0NiB8fCBjb2RlID09PSA5NSkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2sodHJhaWwsIGRvbWFpbkFmdGVyLCBkb21haW5BdFB1bmN0dWF0aW9uKShjb2RlKVxuICAgIH1cblxuICAgIC8vIEdIIGRvY3VtZW50cyB0aGF0IG9ubHkgYWxwaGFudW1lcmljcyAob3RoZXIgdGhhbiBgLWAsIGAuYCwgYW5kIGBfYCkgY2FuXG4gICAgLy8gb2NjdXIsIHdoaWNoIHNvdW5kcyBsaWtlIEFTQ0lJIG9ubHksIGJ1dCB0aGV5IGFsc28gc3VwcG9ydCBgd3d3Lum7nueciy5jb21gLFxuICAgIC8vIHNvIHRoYXTigJlzIFVuaWNvZGUuXG4gICAgLy8gSW5zdGVhZCBvZiBzb21lIG5ldyBwcm9kdWN0aW9uIGZvciBVbmljb2RlIGFscGhhbnVtZXJpY3MsIG1hcmtkb3duXG4gICAgLy8gYWxyZWFkeSBoYXMgdGhhdCBmb3IgVW5pY29kZSBwdW5jdHVhdGlvbiBhbmQgd2hpdGVzcGFjZSwgc28gdXNlIHRob3NlLlxuICAgIC8vIFNvdXJjZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2Jsb2IvZWYxY2ZjYi9leHRlbnNpb25zL2F1dG9saW5rLmMjTDEyPi5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBudWxsIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpIHx8XG4gICAgICB1bmljb2RlV2hpdGVzcGFjZShjb2RlKSB8fFxuICAgICAgKGNvZGUgIT09IDQ1ICYmIHVuaWNvZGVQdW5jdHVhdGlvbihjb2RlKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkb21haW5BZnRlcihjb2RlKVxuICAgIH1cbiAgICBzZWVuID0gdHJ1ZVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBkb21haW5JbnNpZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBkb21haW4sIGF0IHBvdGVudGlhbCB0cmFpbGluZyBwdW5jdHVhdGlvbiwgdGhhdCB3YXMgbm90IHRyYWlsaW5nLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbVxuICAgKiAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZG9tYWluQXRQdW5jdHVhdGlvbihjb2RlKSB7XG4gICAgLy8gVGhlcmUgaXMgYW4gdW5kZXJzY29yZSBpbiB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkb21haW5cbiAgICBpZiAoY29kZSA9PT0gOTUpIHtcbiAgICAgIHVuZGVyc2NvcmVJbkxhc3RTZWdtZW50ID0gdHJ1ZVxuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGl04oCZcyBhIGAuYDogc2F2ZSB0aGUgbGFzdCBzZWdtZW50IHVuZGVyc2NvcmUgaW4gdGhlXG4gICAgLy8gcGVudWx0aW1hdGUgc2VnbWVudCBzbG90LlxuICAgIGVsc2Uge1xuICAgICAgdW5kZXJzY29yZUluTGFzdExhc3RTZWdtZW50ID0gdW5kZXJzY29yZUluTGFzdFNlZ21lbnRcbiAgICAgIHVuZGVyc2NvcmVJbkxhc3RTZWdtZW50ID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBkb21haW5JbnNpZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkb21haW4uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2FcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIGRvbWFpbkFmdGVyKGNvZGUpIHtcbiAgICAvLyBOb3RlOiB0aGF04oCZcyBHSCBzYXlzIGEgZG90IGlzIG5lZWRlZCwgYnV0IGl04oCZcyBub3QgdHJ1ZTpcbiAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vaXNzdWVzLzI3OT5cbiAgICBpZiAodW5kZXJzY29yZUluTGFzdExhc3RTZWdtZW50IHx8IHVuZGVyc2NvcmVJbkxhc3RTZWdtZW50IHx8ICFzZWVuKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogUGF0aC5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGEgaHR0cHM6Ly9leGFtcGxlLm9yZy9zdHVmZiBiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXG4gKiBgYGBcbiAqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVQYXRoKGVmZmVjdHMsIG9rKSB7XG4gIGxldCBzaXplT3BlbiA9IDBcbiAgbGV0IHNpemVDbG9zZSA9IDBcbiAgcmV0dXJuIHBhdGhJbnNpZGVcblxuICAvKipcbiAgICogSW4gcGF0aC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20vYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIF5eXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBwYXRoSW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gNDApIHtcbiAgICAgIHNpemVPcGVuKytcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHBhdGhJbnNpZGVcbiAgICB9XG5cbiAgICAvLyBUbyBkbzogYG1hcmtkb3duLXJzYCBhbHNvIG5lZWRzIHRoaXMuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHBhcmVuLCBhbmQgdGhlcmUgYXJlIGxlc3MgY2xvc2luZ3MgdGhhbiBvcGVuaW5ncyxcbiAgICAvLyB3ZSBkb27igJl0IGNoZWNrIGZvciBhIHRyYWlsLlxuICAgIGlmIChjb2RlID09PSA0MSAmJiBzaXplQ2xvc2UgPCBzaXplT3Blbikge1xuICAgICAgcmV0dXJuIHBhdGhBdFB1bmN0dWF0aW9uKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHRyYWlsaW5nIHB1bmN0dWF0aW9uIG1hcmtlciBpcyBvcHRpb25hbGx5XG4gICAgLy8gZm9sbG93ZWQgYnkgbW9yZSB0cmFpbGluZyBtYXJrZXJzLCBhbmQgdGhlbiBmb2xsb3dlZFxuICAgIC8vIGJ5IGFuIGVuZC5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSAzMyB8fFxuICAgICAgY29kZSA9PT0gMzQgfHxcbiAgICAgIGNvZGUgPT09IDM4IHx8XG4gICAgICBjb2RlID09PSAzOSB8fFxuICAgICAgY29kZSA9PT0gNDEgfHxcbiAgICAgIGNvZGUgPT09IDQyIHx8XG4gICAgICBjb2RlID09PSA0NCB8fFxuICAgICAgY29kZSA9PT0gNDYgfHxcbiAgICAgIGNvZGUgPT09IDU4IHx8XG4gICAgICBjb2RlID09PSA1OSB8fFxuICAgICAgY29kZSA9PT0gNjAgfHxcbiAgICAgIGNvZGUgPT09IDYzIHx8XG4gICAgICBjb2RlID09PSA5MyB8fFxuICAgICAgY29kZSA9PT0gOTUgfHxcbiAgICAgIGNvZGUgPT09IDEyNlxuICAgICkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2sodHJhaWwsIG9rLCBwYXRoQXRQdW5jdHVhdGlvbikoY29kZSlcbiAgICB9XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gcGF0aEluc2lkZVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHBhdGgsIGF0IHBvdGVudGlhbCB0cmFpbGluZyBwdW5jdHVhdGlvbiwgdGhhdCB3YXMgbm90IHRyYWlsaW5nLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hXCJiXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBwYXRoQXRQdW5jdHVhdGlvbihjb2RlKSB7XG4gICAgLy8gQ291bnQgY2xvc2luZyBwYXJlbnMuXG4gICAgaWYgKGNvZGUgPT09IDQxKSB7XG4gICAgICBzaXplQ2xvc2UrK1xuICAgIH1cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gcGF0aEluc2lkZVxuICB9XG59XG5cbi8qKlxuICogVHJhaWwuXG4gKlxuICogVGhpcyBjYWxscyBgb2tgIGlmIHRoaXMgKmlzKiB0aGUgdHJhaWwsIGZvbGxvd2VkIGJ5IGFuIGVuZCwgd2hpY2ggbWVhbnNcbiAqIHRoZSBlbnRpcmUgdHJhaWwgaXMgbm90IHBhcnQgb2YgdGhlIGxpbmsuXG4gKiBJdCBjYWxscyBgbm9rYCBpZiB0aGlzICppcyogcGFydCBvZiB0aGUgbGluay5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb21cIikuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIF5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplVHJhaWwoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gdHJhaWxcblxuICAvKipcbiAgICogSW4gdHJhaWwgb2YgZG9tYWluIG9yIHBhdGguXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tXCIpLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYWlsKGNvZGUpIHtcbiAgICAvLyBSZWd1bGFyIHRyYWlsaW5nIHB1bmN0dWF0aW9uLlxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IDMzIHx8XG4gICAgICBjb2RlID09PSAzNCB8fFxuICAgICAgY29kZSA9PT0gMzkgfHxcbiAgICAgIGNvZGUgPT09IDQxIHx8XG4gICAgICBjb2RlID09PSA0MiB8fFxuICAgICAgY29kZSA9PT0gNDQgfHxcbiAgICAgIGNvZGUgPT09IDQ2IHx8XG4gICAgICBjb2RlID09PSA1OCB8fFxuICAgICAgY29kZSA9PT0gNTkgfHxcbiAgICAgIGNvZGUgPT09IDYzIHx8XG4gICAgICBjb2RlID09PSA5NSB8fFxuICAgICAgY29kZSA9PT0gMTI2XG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0cmFpbFxuICAgIH1cblxuICAgIC8vIGAmYCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBhbHBoYWJldGljYWxzIGFuZCB0aGVuIGEgYDtgLCBpc1xuICAgIC8vIGFzIGEgd2hvbGUgY29uc2lkZXJlZCBhcyB0cmFpbGluZyBwdW5jdHVhdGlvbi5cbiAgICAvLyBJbiBhbGwgb3RoZXIgY2FzZXMsIGl0IGlzIGNvbnNpZGVyZWQgYXMgY29udGludWF0aW9uIG9mIHRoZSBVUkwuXG4gICAgaWYgKGNvZGUgPT09IDM4KSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0cmFpbENoYXJSZWZTdGFydFxuICAgIH1cblxuICAgIC8vIE5lZWRlZCBiZWNhdXNlIHdlIGFsbG93IGxpdGVyYWxzIGFmdGVyIGBbYCwgYXMgd2UgZml4OlxuICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9pc3N1ZXMvMjc4Pi5cbiAgICAvLyBDaGVjayB0aGF0IGl0IGlzIG5vdCBmb2xsb3dlZCBieSBgKGAgb3IgYFtgLlxuICAgIGlmIChjb2RlID09PSA5Mykge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdHJhaWxCcmFja2V0QWZ0ZXJcbiAgICB9XG4gICAgaWYgKFxuICAgICAgLy8gYDxgIGlzIGFuIGVuZC5cbiAgICAgIGNvZGUgPT09IDYwIHx8XG4gICAgICAvLyBTbyBpcyB3aGl0ZXNwYWNlLlxuICAgICAgY29kZSA9PT0gbnVsbCB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gdHJhaWwsIGFmdGVyIGBdYC5cbiAgICpcbiAgICogPiDwn5GJICoqTm90ZSoqOiB0aGlzIGRldmlhdGVzIGZyb20gYGNtYXJrLWdmbWAgdG8gZml4IGEgYnVnLlxuICAgKiA+IFNlZSBlbmQgb2YgPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2lzc3Vlcy8yNzg+IGZvciBtb3JlLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbV0oXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYWlsQnJhY2tldEFmdGVyKGNvZGUpIHtcbiAgICAvLyBXaGl0ZXNwYWNlIG9yIHNvbWV0aGluZyB0aGF0IGNvdWxkIHN0YXJ0IGEgcmVzb3VyY2Ugb3IgcmVmZXJlbmNlIGlzIHRoZSBlbmQuXG4gICAgLy8gU3dpdGNoIGJhY2sgdG8gdHJhaWwgb3RoZXJ3aXNlLlxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IG51bGwgfHxcbiAgICAgIGNvZGUgPT09IDQwIHx8XG4gICAgICBjb2RlID09PSA5MSB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cbiAgICByZXR1cm4gdHJhaWwoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBjaGFyYWN0ZXItcmVmZXJlbmNlIGxpa2UgdHJhaWwsIGFmdGVyIGAmYC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20mYW1wOykuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYWlsQ2hhclJlZlN0YXJ0KGNvZGUpIHtcbiAgICAvLyBXaGVuIG5vbi1hbHBoYSwgaXTigJlzIG5vdCBhIHRyYWlsLlxuICAgIHJldHVybiBhc2NpaUFscGhhKGNvZGUpID8gdHJhaWxDaGFyUmVmSW5zaWRlKGNvZGUpIDogbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gY2hhcmFjdGVyLXJlZmVyZW5jZSBsaWtlIHRyYWlsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbSZhbXA7KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gdHJhaWxDaGFyUmVmSW5zaWRlKGNvZGUpIHtcbiAgICAvLyBTd2l0Y2ggYmFjayB0byB0cmFpbCBpZiB0aGlzIGlzIHdlbGwtZm9ybWVkLlxuICAgIGlmIChjb2RlID09PSA1OSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdHJhaWxcbiAgICB9XG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRyYWlsQ2hhclJlZkluc2lkZVxuICAgIH1cblxuICAgIC8vIEl04oCZcyBub3QgYSB0cmFpbC5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBEb3QgaW4gZW1haWwgZG9tYWluIHRyYWlsLlxuICpcbiAqIFRoaXMgY2FsbHMgYG9rYCBpZiB0aGlzICppcyogdGhlIHRyYWlsLCBmb2xsb3dlZCBieSBhbiBlbmQsIHdoaWNoIG1lYW5zXG4gKiB0aGUgdHJhaWwgaXMgbm90IHBhcnQgb2YgdGhlIGxpbmsuXG4gKiBJdCBjYWxscyBgbm9rYCBpZiB0aGlzICppcyogcGFydCBvZiB0aGUgbGluay5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGNvbnRhY3RAZXhhbXBsZS5vcmcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAqIGBgYFxuICpcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZUVtYWlsRG9tYWluRG90VHJhaWwoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcblxuICAvKipcbiAgICogRG90LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgY29udGFjdEBleGFtcGxlLm9yZy5cbiAgICogICAgICAgICAgICAgICAgICAgIF4gICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gTXVzdCBiZSBkb3QuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGFmdGVyXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgZG90LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgY29udGFjdEBleGFtcGxlLm9yZy5cbiAgICogICAgICAgICAgICAgICAgICAgICBeICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIC8vIE5vdCBhIHRyYWlsIGlmIGFscGhhbnVtZXJpYy5cbiAgICByZXR1cm4gYXNjaWlBbHBoYW51bWVyaWMoY29kZSkgPyBub2soY29kZSkgOiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogU2VlOlxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2Jsb2IvZWYxY2ZjYi9leHRlbnNpb25zL2F1dG9saW5rLmMjTDE1Nj4uXG4gKlxuICogQHR5cGUge1ByZXZpb3VzfVxuICovXG5mdW5jdGlvbiBwcmV2aW91c1d3dyhjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgY29kZSA9PT0gbnVsbCB8fFxuICAgIGNvZGUgPT09IDQwIHx8XG4gICAgY29kZSA9PT0gNDIgfHxcbiAgICBjb2RlID09PSA5NSB8fFxuICAgIGNvZGUgPT09IDkxIHx8XG4gICAgY29kZSA9PT0gOTMgfHxcbiAgICBjb2RlID09PSAxMjYgfHxcbiAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gIClcbn1cblxuLyoqXG4gKiBTZWU6XG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vYmxvYi9lZjFjZmNiL2V4dGVuc2lvbnMvYXV0b2xpbmsuYyNMMjE0Pi5cbiAqXG4gKiBAdHlwZSB7UHJldmlvdXN9XG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzUHJvdG9jb2woY29kZSkge1xuICByZXR1cm4gIWFzY2lpQWxwaGEoY29kZSlcbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1ByZXZpb3VzfVxuICovXG5mdW5jdGlvbiBwcmV2aW91c0VtYWlsKGNvZGUpIHtcbiAgLy8gRG8gbm90IGFsbG93IGEgc2xhc2gg4oCcaW5zaWRl4oCdIGF0ZXh0LlxuICAvLyBUaGUgcmVmZXJlbmNlIGNvZGUgaXMgYSBiaXQgd2VpcmQsIGJ1dCB0aGF04oCZcyB3aGF0IGl0IHJlc3VsdHMgaW4uXG4gIC8vIFNvdXJjZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2Jsb2IvZWYxY2ZjYi9leHRlbnNpb25zL2F1dG9saW5rLmMjTDMwNz4uXG4gIC8vIE90aGVyIHRoYW4gc2xhc2gsIGV2ZXJ5IHByZWNlZGluZyBjaGFyYWN0ZXIgaXMgYWxsb3dlZC5cbiAgcmV0dXJuICEoY29kZSA9PT0gNDcgfHwgZ2ZtQXRleHQoY29kZSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZ2ZtQXRleHQoY29kZSkge1xuICByZXR1cm4gKFxuICAgIGNvZGUgPT09IDQzIHx8XG4gICAgY29kZSA9PT0gNDUgfHxcbiAgICBjb2RlID09PSA0NiB8fFxuICAgIGNvZGUgPT09IDk1IHx8XG4gICAgYXNjaWlBbHBoYW51bWVyaWMoY29kZSlcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBwcmV2aW91c1VuYmFsYW5jZWQoZXZlbnRzKSB7XG4gIGxldCBpbmRleCA9IGV2ZW50cy5sZW5ndGhcbiAgbGV0IHJlc3VsdCA9IGZhbHNlXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgY29uc3QgdG9rZW4gPSBldmVudHNbaW5kZXhdWzFdXG4gICAgaWYgKFxuICAgICAgKHRva2VuLnR5cGUgPT09ICdsYWJlbExpbmsnIHx8IHRva2VuLnR5cGUgPT09ICdsYWJlbEltYWdlJykgJiZcbiAgICAgICF0b2tlbi5fYmFsYW5jZWRcbiAgICApIHtcbiAgICAgIHJlc3VsdCA9IHRydWVcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gSWYgd2XigJl2ZSBzZWVuIHRoaXMgdG9rZW4sIGFuZCBpdCB3YXMgbWFya2VkIGFzIG5vdCBoYXZpbmcgYW55IHVuYmFsYW5jZWRcbiAgICAvLyBicmFja2V0IGJlZm9yZSBpdCwgd2UgY2FuIGV4aXQuXG4gICAgaWYgKHRva2VuLl9nZm1BdXRvbGlua0xpdGVyYWxXYWxrZWRJbnRvKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50cy5sZW5ndGggPiAwICYmICFyZXN1bHQpIHtcbiAgICAvLyBNYXJrIHRoZSBsYXN0IHRva2VuIGFzIOKAnHdhbGtlZCBpbnRv4oCdIHcvbyBmaW5kaW5nXG4gICAgLy8gYW55dGhpbmcuXG4gICAgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXVsxXS5fZ2ZtQXV0b2xpbmtMaXRlcmFsV2Fsa2VkSW50byA9IHRydWVcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOlsiZ2ZtQXV0b2xpbmtMaXRlcmFsIiwid3d3UHJlZml4IiwidG9rZW5pemUiLCJ0b2tlbml6ZVd3d1ByZWZpeCIsInBhcnRpYWwiLCJkb21haW4iLCJ0b2tlbml6ZURvbWFpbiIsInBhdGgiLCJ0b2tlbml6ZVBhdGgiLCJ0cmFpbCIsInRva2VuaXplVHJhaWwiLCJlbWFpbERvbWFpbkRvdFRyYWlsIiwidG9rZW5pemVFbWFpbERvbWFpbkRvdFRyYWlsIiwid3d3QXV0b2xpbmsiLCJ0b2tlbml6ZVd3d0F1dG9saW5rIiwicHJldmlvdXMiLCJwcmV2aW91c1d3dyIsInByb3RvY29sQXV0b2xpbmsiLCJ0b2tlbml6ZVByb3RvY29sQXV0b2xpbmsiLCJwcmV2aW91c1Byb3RvY29sIiwiZW1haWxBdXRvbGluayIsInRva2VuaXplRW1haWxBdXRvbGluayIsInByZXZpb3VzRW1haWwiLCJ0ZXh0IiwiY29kZSIsImVmZmVjdHMiLCJvayIsIm5vayIsInNlbGYiLCJkb3QiLCJkYXRhIiwic3RhcnQiLCJnZm1BdGV4dCIsImNhbGwiLCJwcmV2aW91c1VuYmFsYW5jZWQiLCJldmVudHMiLCJlbnRlciIsImF0ZXh0IiwiY29uc3VtZSIsImVtYWlsRG9tYWluIiwiY2hlY2siLCJlbWFpbERvbWFpbkFmdGVyIiwiZW1haWxEb21haW5Eb3QiLCJhc2NpaUFscGhhbnVtZXJpYyIsImFzY2lpQWxwaGEiLCJleGl0Iiwid3d3U3RhcnQiLCJhdHRlbXB0Iiwid3d3QWZ0ZXIiLCJidWZmZXIiLCJzZWVuIiwicHJvdG9jb2xTdGFydCIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJwcm90b2NvbFByZWZpeEluc2lkZSIsImxlbmd0aCIsInByb3RvY29sIiwidG9Mb3dlckNhc2UiLCJwcm90b2NvbFNsYXNoZXNJbnNpZGUiLCJhZnRlclByb3RvY29sIiwiYXNjaWlDb250cm9sIiwibWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSIsInVuaWNvZGVXaGl0ZXNwYWNlIiwidW5pY29kZVB1bmN0dWF0aW9uIiwicHJvdG9jb2xBZnRlciIsInNpemUiLCJ3d3dQcmVmaXhJbnNpZGUiLCJ3d3dQcmVmaXhBZnRlciIsInVuZGVyc2NvcmVJbkxhc3RTZWdtZW50IiwidW5kZXJzY29yZUluTGFzdExhc3RTZWdtZW50IiwiZG9tYWluSW5zaWRlIiwiZG9tYWluQWZ0ZXIiLCJkb21haW5BdFB1bmN0dWF0aW9uIiwidW5kZWZpbmVkIiwic2l6ZU9wZW4iLCJzaXplQ2xvc2UiLCJwYXRoSW5zaWRlIiwicGF0aEF0UHVuY3R1YXRpb24iLCJ0cmFpbENoYXJSZWZTdGFydCIsInRyYWlsQnJhY2tldEFmdGVyIiwidHJhaWxDaGFyUmVmSW5zaWRlIiwiYWZ0ZXIiLCJpbmRleCIsInJlc3VsdCIsInRva2VuIiwidHlwZSIsIl9iYWxhbmNlZCIsIl9nZm1BdXRvbGlua0xpdGVyYWxXYWxrZWRJbnRvIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0NBU0M7Ozs7K0JBc0RlQTs7O2VBQUFBOzs7d0NBN0NUO0FBQ1AsTUFBTUMsWUFBWTtJQUNoQkMsVUFBVUM7SUFDVkMsU0FBUztBQUNYO0FBQ0EsTUFBTUMsU0FBUztJQUNiSCxVQUFVSTtJQUNWRixTQUFTO0FBQ1g7QUFDQSxNQUFNRyxPQUFPO0lBQ1hMLFVBQVVNO0lBQ1ZKLFNBQVM7QUFDWDtBQUNB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