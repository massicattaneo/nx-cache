{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-core-commonmark/lib/heading-atx.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n  let content\n  /** @type {Token} */\n  let text\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: 'text'\n    }\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  let size = 0\n  return start\n\n  /**\n   * Start of a heading (atx).\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    effects.enter('atxHeading')\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at `#`.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('atxHeadingSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return sequenceOpen\n    }\n\n    // Always at least one `#`.\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return atBreak(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ## aa\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequenceFurther(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      // To do: interrupt like `markdown-rs`.\n      // // Feel free to interrupt.\n      // tokenizer.interrupt = false\n      return ok(code)\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code)\n    }\n\n    // To do: generate `data` tokens, add the `text` token later.\n    // Needs edit map, see: `markdown.rs`.\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n\n  /**\n   * In further sequence (after whitespace).\n   *\n   * Could be normal “visible” hashes in the heading or a final sequence.\n   *\n   * ```markdown\n   * > | ## aa ##\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceFurther(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequenceFurther\n    }\n    effects.exit('atxHeadingSequence')\n    return atBreak(code)\n  }\n\n  /**\n   * In text.\n   *\n   * ```markdown\n   * > | ## aa\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    return data\n  }\n}\n"],"names":["headingAtx","name","tokenize","tokenizeHeadingAtx","resolve","resolveHeadingAtx","events","context","contentEnd","length","contentStart","content","text","type","start","end","contentType","splice","effects","ok","nok","size","code","enter","before","sequenceOpen","consume","markdownLineEndingOrSpace","exit","atBreak","sequenceFurther","markdownLineEnding","markdownSpace","factorySpace","data"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}