4c50e586a173c3e76b6e471c7fc377a6
/**
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Token} Token
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "subtokenize", {
    enumerable: true,
    get: function() {
        return subtokenize;
    }
});
const _micromarkutilchunked = require("micromark-util-chunked");
function subtokenize(events) {
    /** @type {Record<string, number>} */ const jumps = {};
    let index = -1;
    /** @type {Event} */ let event;
    /** @type {number | undefined} */ let lineIndex;
    /** @type {number} */ let otherIndex;
    /** @type {Event} */ let otherEvent;
    /** @type {Array<Event>} */ let parameters;
    /** @type {Array<Event>} */ let subevents;
    /** @type {boolean | undefined} */ let more;
    while(++index < events.length){
        while(index in jumps){
            index = jumps[index];
        }
        event = events[index];
        // Add a hook for the GFM tasklist extension, which needs to know if text
        // is in the first content of a list item.
        if (index && event[1].type === 'chunkFlow' && events[index - 1][1].type === 'listItemPrefix') {
            subevents = event[1]._tokenizer.events;
            otherIndex = 0;
            if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'lineEndingBlank') {
                otherIndex += 2;
            }
            if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'content') {
                while(++otherIndex < subevents.length){
                    if (subevents[otherIndex][1].type === 'content') {
                        break;
                    }
                    if (subevents[otherIndex][1].type === 'chunkText') {
                        subevents[otherIndex][1]._isInFirstContentOfListItem = true;
                        otherIndex++;
                    }
                }
            }
        }
        // Enter.
        if (event[0] === 'enter') {
            if (event[1].contentType) {
                Object.assign(jumps, subcontent(events, index));
                index = jumps[index];
                more = true;
            }
        } else if (event[1]._container) {
            otherIndex = index;
            lineIndex = undefined;
            while(otherIndex--){
                otherEvent = events[otherIndex];
                if (otherEvent[1].type === 'lineEnding' || otherEvent[1].type === 'lineEndingBlank') {
                    if (otherEvent[0] === 'enter') {
                        if (lineIndex) {
                            events[lineIndex][1].type = 'lineEndingBlank';
                        }
                        otherEvent[1].type = 'lineEnding';
                        lineIndex = otherIndex;
                    }
                } else {
                    break;
                }
            }
            if (lineIndex) {
                // Fix position.
                event[1].end = Object.assign({}, events[lineIndex][1].start);
                // Switch container exit w/ line endings.
                parameters = events.slice(lineIndex, index);
                parameters.unshift(event);
                (0, _micromarkutilchunked.splice)(events, lineIndex, index - lineIndex + 1, parameters);
            }
        }
    }
    return !more;
}
/**
 * Tokenize embedded tokens.
 *
 * @param {Array<Event>} events
 * @param {number} eventIndex
 * @returns {Record<string, number>}
 */ function subcontent(events, eventIndex) {
    const token = events[eventIndex][1];
    const context = events[eventIndex][2];
    let startPosition = eventIndex - 1;
    /** @type {Array<number>} */ const startPositions = [];
    const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
    const childEvents = tokenizer.events;
    /** @type {Array<[number, number]>} */ const jumps = [];
    /** @type {Record<string, number>} */ const gaps = {};
    /** @type {Array<Chunk>} */ let stream;
    /** @type {Token | undefined} */ let previous;
    let index = -1;
    /** @type {Token | undefined} */ let current = token;
    let adjust = 0;
    let start = 0;
    const breaks = [
        start
    ];
    // Loop forward through the linked tokens to pass them in order to the
    // subtokenizer.
    while(current){
        // Find the position of the event for this token.
        while(events[++startPosition][1] !== current){
        // Empty.
        }
        startPositions.push(startPosition);
        if (!current._tokenizer) {
            stream = context.sliceStream(current);
            if (!current.next) {
                stream.push(null);
            }
            if (previous) {
                tokenizer.defineSkip(current.start);
            }
            if (current._isInFirstContentOfListItem) {
                tokenizer._gfmTasklistFirstContentOfListItem = true;
            }
            tokenizer.write(stream);
            if (current._isInFirstContentOfListItem) {
                tokenizer._gfmTasklistFirstContentOfListItem = undefined;
            }
        }
        // Unravel the next token.
        previous = current;
        current = current.next;
    }
    // Now, loop back through all events (and linked tokens), to figure out which
    // parts belong where.
    current = token;
    while(++index < childEvents.length){
        if (// Find a void token that includes a break.
        childEvents[index][0] === 'exit' && childEvents[index - 1][0] === 'enter' && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {
            start = index + 1;
            breaks.push(start);
            // Help GC.
            current._tokenizer = undefined;
            current.previous = undefined;
            current = current.next;
        }
    }
    // Help GC.
    tokenizer.events = [];
    // If there’s one more token (which is the cases for lines that end in an
    // EOF), that’s perfect: the last point we found starts it.
    // If there isn’t then make sure any remaining content is added to it.
    if (current) {
        // Help GC.
        current._tokenizer = undefined;
        current.previous = undefined;
    } else {
        breaks.pop();
    }
    // Now splice the events from the subtokenizer into the current events,
    // moving back to front so that splice indices aren’t affected.
    index = breaks.length;
    while(index--){
        const slice = childEvents.slice(breaks[index], breaks[index + 1]);
        const start = startPositions.pop();
        jumps.unshift([
            start,
            start + slice.length - 1
        ]);
        (0, _micromarkutilchunked.splice)(events, start, 2, slice);
    }
    index = -1;
    while(++index < jumps.length){
        gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];
        adjust += jumps[index][1] - jumps[index][0] - 1;
    }
    return gaps;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1zdWJ0b2tlbml6ZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ2h1bmt9IENodW5rXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqL1xuXG5pbXBvcnQge3NwbGljZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2h1bmtlZCdcbi8qKlxuICogVG9rZW5pemUgc3ViY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gKiAgIExpc3Qgb2YgZXZlbnRzLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgc3VidG9rZW5zIHdlcmUgZm91bmQuXG4gKi8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBzdWJ0b2tlbml6ZShldmVudHMpIHtcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSAqL1xuICBjb25zdCBqdW1wcyA9IHt9XG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7RXZlbnR9ICovXG4gIGxldCBldmVudFxuICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGxpbmVJbmRleFxuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgbGV0IG90aGVySW5kZXhcbiAgLyoqIEB0eXBlIHtFdmVudH0gKi9cbiAgbGV0IG90aGVyRXZlbnRcbiAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gIGxldCBwYXJhbWV0ZXJzXG4gIC8qKiBAdHlwZSB7QXJyYXk8RXZlbnQ+fSAqL1xuICBsZXQgc3ViZXZlbnRzXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IG1vcmVcbiAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgd2hpbGUgKGluZGV4IGluIGp1bXBzKSB7XG4gICAgICBpbmRleCA9IGp1bXBzW2luZGV4XVxuICAgIH1cbiAgICBldmVudCA9IGV2ZW50c1tpbmRleF1cblxuICAgIC8vIEFkZCBhIGhvb2sgZm9yIHRoZSBHRk0gdGFza2xpc3QgZXh0ZW5zaW9uLCB3aGljaCBuZWVkcyB0byBrbm93IGlmIHRleHRcbiAgICAvLyBpcyBpbiB0aGUgZmlyc3QgY29udGVudCBvZiBhIGxpc3QgaXRlbS5cbiAgICBpZiAoXG4gICAgICBpbmRleCAmJlxuICAgICAgZXZlbnRbMV0udHlwZSA9PT0gJ2NodW5rRmxvdycgJiZcbiAgICAgIGV2ZW50c1tpbmRleCAtIDFdWzFdLnR5cGUgPT09ICdsaXN0SXRlbVByZWZpeCdcbiAgICApIHtcbiAgICAgIHN1YmV2ZW50cyA9IGV2ZW50WzFdLl90b2tlbml6ZXIuZXZlbnRzXG4gICAgICBvdGhlckluZGV4ID0gMFxuICAgICAgaWYgKFxuICAgICAgICBvdGhlckluZGV4IDwgc3ViZXZlbnRzLmxlbmd0aCAmJlxuICAgICAgICBzdWJldmVudHNbb3RoZXJJbmRleF1bMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmdCbGFuaydcbiAgICAgICkge1xuICAgICAgICBvdGhlckluZGV4ICs9IDJcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgb3RoZXJJbmRleCA8IHN1YmV2ZW50cy5sZW5ndGggJiZcbiAgICAgICAgc3ViZXZlbnRzW290aGVySW5kZXhdWzFdLnR5cGUgPT09ICdjb250ZW50J1xuICAgICAgKSB7XG4gICAgICAgIHdoaWxlICgrK290aGVySW5kZXggPCBzdWJldmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHN1YmV2ZW50c1tvdGhlckluZGV4XVsxXS50eXBlID09PSAnY29udGVudCcpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWJldmVudHNbb3RoZXJJbmRleF1bMV0udHlwZSA9PT0gJ2NodW5rVGV4dCcpIHtcbiAgICAgICAgICAgIHN1YmV2ZW50c1tvdGhlckluZGV4XVsxXS5faXNJbkZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSB0cnVlXG4gICAgICAgICAgICBvdGhlckluZGV4KytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnRlci5cbiAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgIGlmIChldmVudFsxXS5jb250ZW50VHlwZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGp1bXBzLCBzdWJjb250ZW50KGV2ZW50cywgaW5kZXgpKVxuICAgICAgICBpbmRleCA9IGp1bXBzW2luZGV4XVxuICAgICAgICBtb3JlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeGl0LlxuICAgIGVsc2UgaWYgKGV2ZW50WzFdLl9jb250YWluZXIpIHtcbiAgICAgIG90aGVySW5kZXggPSBpbmRleFxuICAgICAgbGluZUluZGV4ID0gdW5kZWZpbmVkXG4gICAgICB3aGlsZSAob3RoZXJJbmRleC0tKSB7XG4gICAgICAgIG90aGVyRXZlbnQgPSBldmVudHNbb3RoZXJJbmRleF1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG90aGVyRXZlbnRbMV0udHlwZSA9PT0gJ2xpbmVFbmRpbmcnIHx8XG4gICAgICAgICAgb3RoZXJFdmVudFsxXS50eXBlID09PSAnbGluZUVuZGluZ0JsYW5rJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAob3RoZXJFdmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgICAgaWYgKGxpbmVJbmRleCkge1xuICAgICAgICAgICAgICBldmVudHNbbGluZUluZGV4XVsxXS50eXBlID0gJ2xpbmVFbmRpbmdCbGFuaydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG90aGVyRXZlbnRbMV0udHlwZSA9ICdsaW5lRW5kaW5nJ1xuICAgICAgICAgICAgbGluZUluZGV4ID0gb3RoZXJJbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGluZUluZGV4KSB7XG4gICAgICAgIC8vIEZpeCBwb3NpdGlvbi5cbiAgICAgICAgZXZlbnRbMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2xpbmVJbmRleF1bMV0uc3RhcnQpXG5cbiAgICAgICAgLy8gU3dpdGNoIGNvbnRhaW5lciBleGl0IHcvIGxpbmUgZW5kaW5ncy5cbiAgICAgICAgcGFyYW1ldGVycyA9IGV2ZW50cy5zbGljZShsaW5lSW5kZXgsIGluZGV4KVxuICAgICAgICBwYXJhbWV0ZXJzLnVuc2hpZnQoZXZlbnQpXG4gICAgICAgIHNwbGljZShldmVudHMsIGxpbmVJbmRleCwgaW5kZXggLSBsaW5lSW5kZXggKyAxLCBwYXJhbWV0ZXJzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gIW1vcmVcbn1cblxuLyoqXG4gKiBUb2tlbml6ZSBlbWJlZGRlZCB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50SW5kZXhcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fVxuICovXG5mdW5jdGlvbiBzdWJjb250ZW50KGV2ZW50cywgZXZlbnRJbmRleCkge1xuICBjb25zdCB0b2tlbiA9IGV2ZW50c1tldmVudEluZGV4XVsxXVxuICBjb25zdCBjb250ZXh0ID0gZXZlbnRzW2V2ZW50SW5kZXhdWzJdXG4gIGxldCBzdGFydFBvc2l0aW9uID0gZXZlbnRJbmRleCAtIDFcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBjb25zdCBzdGFydFBvc2l0aW9ucyA9IFtdXG4gIGNvbnN0IHRva2VuaXplciA9XG4gICAgdG9rZW4uX3Rva2VuaXplciB8fCBjb250ZXh0LnBhcnNlclt0b2tlbi5jb250ZW50VHlwZV0odG9rZW4uc3RhcnQpXG4gIGNvbnN0IGNoaWxkRXZlbnRzID0gdG9rZW5pemVyLmV2ZW50c1xuICAvKiogQHR5cGUge0FycmF5PFtudW1iZXIsIG51bWJlcl0+fSAqL1xuICBjb25zdCBqdW1wcyA9IFtdXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgY29uc3QgZ2FwcyA9IHt9XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q2h1bms+fSAqL1xuICBsZXQgc3RyZWFtXG4gIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBwcmV2aW91c1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgY3VycmVudCA9IHRva2VuXG4gIGxldCBhZGp1c3QgPSAwXG4gIGxldCBzdGFydCA9IDBcbiAgY29uc3QgYnJlYWtzID0gW3N0YXJ0XVxuXG4gIC8vIExvb3AgZm9yd2FyZCB0aHJvdWdoIHRoZSBsaW5rZWQgdG9rZW5zIHRvIHBhc3MgdGhlbSBpbiBvcmRlciB0byB0aGVcbiAgLy8gc3VidG9rZW5pemVyLlxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIC8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBmb3IgdGhpcyB0b2tlbi5cbiAgICB3aGlsZSAoZXZlbnRzWysrc3RhcnRQb3NpdGlvbl1bMV0gIT09IGN1cnJlbnQpIHtcbiAgICAgIC8vIEVtcHR5LlxuICAgIH1cbiAgICBzdGFydFBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zaXRpb24pXG4gICAgaWYgKCFjdXJyZW50Ll90b2tlbml6ZXIpIHtcbiAgICAgIHN0cmVhbSA9IGNvbnRleHQuc2xpY2VTdHJlYW0oY3VycmVudClcbiAgICAgIGlmICghY3VycmVudC5uZXh0KSB7XG4gICAgICAgIHN0cmVhbS5wdXNoKG51bGwpXG4gICAgICB9XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgdG9rZW5pemVyLmRlZmluZVNraXAoY3VycmVudC5zdGFydClcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50Ll9pc0luRmlyc3RDb250ZW50T2ZMaXN0SXRlbSkge1xuICAgICAgICB0b2tlbml6ZXIuX2dmbVRhc2tsaXN0Rmlyc3RDb250ZW50T2ZMaXN0SXRlbSA9IHRydWVcbiAgICAgIH1cbiAgICAgIHRva2VuaXplci53cml0ZShzdHJlYW0pXG4gICAgICBpZiAoY3VycmVudC5faXNJbkZpcnN0Q29udGVudE9mTGlzdEl0ZW0pIHtcbiAgICAgICAgdG9rZW5pemVyLl9nZm1UYXNrbGlzdEZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVbnJhdmVsIHRoZSBuZXh0IHRva2VuLlxuICAgIHByZXZpb3VzID0gY3VycmVudFxuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcbiAgfVxuXG4gIC8vIE5vdywgbG9vcCBiYWNrIHRocm91Z2ggYWxsIGV2ZW50cyAoYW5kIGxpbmtlZCB0b2tlbnMpLCB0byBmaWd1cmUgb3V0IHdoaWNoXG4gIC8vIHBhcnRzIGJlbG9uZyB3aGVyZS5cbiAgY3VycmVudCA9IHRva2VuXG4gIHdoaWxlICgrK2luZGV4IDwgY2hpbGRFdmVudHMubGVuZ3RoKSB7XG4gICAgaWYgKFxuICAgICAgLy8gRmluZCBhIHZvaWQgdG9rZW4gdGhhdCBpbmNsdWRlcyBhIGJyZWFrLlxuICAgICAgY2hpbGRFdmVudHNbaW5kZXhdWzBdID09PSAnZXhpdCcgJiZcbiAgICAgIGNoaWxkRXZlbnRzW2luZGV4IC0gMV1bMF0gPT09ICdlbnRlcicgJiZcbiAgICAgIGNoaWxkRXZlbnRzW2luZGV4XVsxXS50eXBlID09PSBjaGlsZEV2ZW50c1tpbmRleCAtIDFdWzFdLnR5cGUgJiZcbiAgICAgIGNoaWxkRXZlbnRzW2luZGV4XVsxXS5zdGFydC5saW5lICE9PSBjaGlsZEV2ZW50c1tpbmRleF1bMV0uZW5kLmxpbmVcbiAgICApIHtcbiAgICAgIHN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICBicmVha3MucHVzaChzdGFydClcbiAgICAgIC8vIEhlbHAgR0MuXG4gICAgICBjdXJyZW50Ll90b2tlbml6ZXIgPSB1bmRlZmluZWRcbiAgICAgIGN1cnJlbnQucHJldmlvdXMgPSB1bmRlZmluZWRcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcbiAgICB9XG4gIH1cblxuICAvLyBIZWxwIEdDLlxuICB0b2tlbml6ZXIuZXZlbnRzID0gW11cblxuICAvLyBJZiB0aGVyZeKAmXMgb25lIG1vcmUgdG9rZW4gKHdoaWNoIGlzIHRoZSBjYXNlcyBmb3IgbGluZXMgdGhhdCBlbmQgaW4gYW5cbiAgLy8gRU9GKSwgdGhhdOKAmXMgcGVyZmVjdDogdGhlIGxhc3QgcG9pbnQgd2UgZm91bmQgc3RhcnRzIGl0LlxuICAvLyBJZiB0aGVyZSBpc27igJl0IHRoZW4gbWFrZSBzdXJlIGFueSByZW1haW5pbmcgY29udGVudCBpcyBhZGRlZCB0byBpdC5cbiAgaWYgKGN1cnJlbnQpIHtcbiAgICAvLyBIZWxwIEdDLlxuICAgIGN1cnJlbnQuX3Rva2VuaXplciA9IHVuZGVmaW5lZFxuICAgIGN1cnJlbnQucHJldmlvdXMgPSB1bmRlZmluZWRcbiAgfSBlbHNlIHtcbiAgICBicmVha3MucG9wKClcbiAgfVxuXG4gIC8vIE5vdyBzcGxpY2UgdGhlIGV2ZW50cyBmcm9tIHRoZSBzdWJ0b2tlbml6ZXIgaW50byB0aGUgY3VycmVudCBldmVudHMsXG4gIC8vIG1vdmluZyBiYWNrIHRvIGZyb250IHNvIHRoYXQgc3BsaWNlIGluZGljZXMgYXJlbuKAmXQgYWZmZWN0ZWQuXG4gIGluZGV4ID0gYnJlYWtzLmxlbmd0aFxuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIGNvbnN0IHNsaWNlID0gY2hpbGRFdmVudHMuc2xpY2UoYnJlYWtzW2luZGV4XSwgYnJlYWtzW2luZGV4ICsgMV0pXG4gICAgY29uc3Qgc3RhcnQgPSBzdGFydFBvc2l0aW9ucy5wb3AoKVxuICAgIGp1bXBzLnVuc2hpZnQoW3N0YXJ0LCBzdGFydCArIHNsaWNlLmxlbmd0aCAtIDFdKVxuICAgIHNwbGljZShldmVudHMsIHN0YXJ0LCAyLCBzbGljZSlcbiAgfVxuICBpbmRleCA9IC0xXG4gIHdoaWxlICgrK2luZGV4IDwganVtcHMubGVuZ3RoKSB7XG4gICAgZ2Fwc1thZGp1c3QgKyBqdW1wc1tpbmRleF1bMF1dID0gYWRqdXN0ICsganVtcHNbaW5kZXhdWzFdXG4gICAgYWRqdXN0ICs9IGp1bXBzW2luZGV4XVsxXSAtIGp1bXBzW2luZGV4XVswXSAtIDFcbiAgfVxuICByZXR1cm4gZ2Fwc1xufVxuIl0sIm5hbWVzIjpbInN1YnRva2VuaXplIiwiZXZlbnRzIiwianVtcHMiLCJpbmRleCIsImV2ZW50IiwibGluZUluZGV4Iiwib3RoZXJJbmRleCIsIm90aGVyRXZlbnQiLCJwYXJhbWV0ZXJzIiwic3ViZXZlbnRzIiwibW9yZSIsImxlbmd0aCIsInR5cGUiLCJfdG9rZW5pemVyIiwiX2lzSW5GaXJzdENvbnRlbnRPZkxpc3RJdGVtIiwiY29udGVudFR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJzdWJjb250ZW50IiwiX2NvbnRhaW5lciIsInVuZGVmaW5lZCIsImVuZCIsInN0YXJ0Iiwic2xpY2UiLCJ1bnNoaWZ0Iiwic3BsaWNlIiwiZXZlbnRJbmRleCIsInRva2VuIiwiY29udGV4dCIsInN0YXJ0UG9zaXRpb24iLCJzdGFydFBvc2l0aW9ucyIsInRva2VuaXplciIsInBhcnNlciIsImNoaWxkRXZlbnRzIiwiZ2FwcyIsInN0cmVhbSIsInByZXZpb3VzIiwiY3VycmVudCIsImFkanVzdCIsImJyZWFrcyIsInB1c2giLCJzbGljZVN0cmVhbSIsIm5leHQiLCJkZWZpbmVTa2lwIiwiX2dmbVRhc2tsaXN0Rmlyc3RDb250ZW50T2ZMaXN0SXRlbSIsIndyaXRlIiwibGluZSIsInBvcCJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQzs7OzsrQkFXZUE7OztlQUFBQTs7O3NDQVRLO0FBU2QsU0FBU0EsWUFBWUMsTUFBTTtJQUNoQyxtQ0FBbUMsR0FDbkMsTUFBTUMsUUFBUSxDQUFDO0lBQ2YsSUFBSUMsUUFBUSxDQUFDO0lBQ2Isa0JBQWtCLEdBQ2xCLElBQUlDO0lBQ0osK0JBQStCLEdBQy9CLElBQUlDO0lBQ0osbUJBQW1CLEdBQ25CLElBQUlDO0lBQ0osa0JBQWtCLEdBQ2xCLElBQUlDO0lBQ0oseUJBQXlCLEdBQ3pCLElBQUlDO0lBQ0oseUJBQXlCLEdBQ3pCLElBQUlDO0lBQ0osZ0NBQWdDLEdBQ2hDLElBQUlDO0lBQ0osTUFBTyxFQUFFUCxRQUFRRixPQUFPVSxNQUFNLENBQUU7UUFDOUIsTUFBT1IsU0FBU0QsTUFBTztZQUNyQkMsUUFBUUQsS0FBSyxDQUFDQyxNQUFNO1FBQ3RCO1FBQ0FDLFFBQVFILE1BQU0sQ0FBQ0UsTUFBTTtRQUVyQix5RUFBeUU7UUFDekUsMENBQTBDO1FBQzFDLElBQ0VBLFNBQ0FDLEtBQUssQ0FBQyxFQUFFLENBQUNRLElBQUksS0FBSyxlQUNsQlgsTUFBTSxDQUFDRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUNTLElBQUksS0FBSyxrQkFDOUI7WUFDQUgsWUFBWUwsS0FBSyxDQUFDLEVBQUUsQ0FBQ1MsVUFBVSxDQUFDWixNQUFNO1lBQ3RDSyxhQUFhO1lBQ2IsSUFDRUEsYUFBYUcsVUFBVUUsTUFBTSxJQUM3QkYsU0FBUyxDQUFDSCxXQUFXLENBQUMsRUFBRSxDQUFDTSxJQUFJLEtBQUssbUJBQ2xDO2dCQUNBTixjQUFjO1lBQ2hCO1lBQ0EsSUFDRUEsYUFBYUcsVUFBVUUsTUFBTSxJQUM3QkYsU0FBUyxDQUFDSCxXQUFXLENBQUMsRUFBRSxDQUFDTSxJQUFJLEtBQUssV0FDbEM7Z0JBQ0EsTUFBTyxFQUFFTixhQUFhRyxVQUFVRSxNQUFNLENBQUU7b0JBQ3RDLElBQUlGLFNBQVMsQ0FBQ0gsV0FBVyxDQUFDLEVBQUUsQ0FBQ00sSUFBSSxLQUFLLFdBQVc7d0JBQy9DO29CQUNGO29CQUNBLElBQUlILFNBQVMsQ0FBQ0gsV0FBVyxDQUFDLEVBQUUsQ0FBQ00sSUFBSSxLQUFLLGFBQWE7d0JBQ2pESCxTQUFTLENBQUNILFdBQVcsQ0FBQyxFQUFFLENBQUNRLDJCQUEyQixHQUFHO3dCQUN2RFI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBUztRQUNULElBQUlGLEtBQUssQ0FBQyxFQUFFLEtBQUssU0FBUztZQUN4QixJQUFJQSxLQUFLLENBQUMsRUFBRSxDQUFDVyxXQUFXLEVBQUU7Z0JBQ3hCQyxPQUFPQyxNQUFNLENBQUNmLE9BQU9nQixXQUFXakIsUUFBUUU7Z0JBQ3hDQSxRQUFRRCxLQUFLLENBQUNDLE1BQU07Z0JBQ3BCTyxPQUFPO1lBQ1Q7UUFDRixPQUVLLElBQUlOLEtBQUssQ0FBQyxFQUFFLENBQUNlLFVBQVUsRUFBRTtZQUM1QmIsYUFBYUg7WUFDYkUsWUFBWWU7WUFDWixNQUFPZCxhQUFjO2dCQUNuQkMsYUFBYU4sTUFBTSxDQUFDSyxXQUFXO2dCQUMvQixJQUNFQyxVQUFVLENBQUMsRUFBRSxDQUFDSyxJQUFJLEtBQUssZ0JBQ3ZCTCxVQUFVLENBQUMsRUFBRSxDQUFDSyxJQUFJLEtBQUssbUJBQ3ZCO29CQUNBLElBQUlMLFVBQVUsQ0FBQyxFQUFFLEtBQUssU0FBUzt3QkFDN0IsSUFBSUYsV0FBVzs0QkFDYkosTUFBTSxDQUFDSSxVQUFVLENBQUMsRUFBRSxDQUFDTyxJQUFJLEdBQUc7d0JBQzlCO3dCQUNBTCxVQUFVLENBQUMsRUFBRSxDQUFDSyxJQUFJLEdBQUc7d0JBQ3JCUCxZQUFZQztvQkFDZDtnQkFDRixPQUFPO29CQUNMO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJRCxXQUFXO2dCQUNiLGdCQUFnQjtnQkFDaEJELEtBQUssQ0FBQyxFQUFFLENBQUNpQixHQUFHLEdBQUdMLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdoQixNQUFNLENBQUNJLFVBQVUsQ0FBQyxFQUFFLENBQUNpQixLQUFLO2dCQUUzRCx5Q0FBeUM7Z0JBQ3pDZCxhQUFhUCxPQUFPc0IsS0FBSyxDQUFDbEIsV0FBV0Y7Z0JBQ3JDSyxXQUFXZ0IsT0FBTyxDQUFDcEI7Z0JBQ25CcUIsSUFBQUEsNEJBQU0sRUFBQ3hCLFFBQVFJLFdBQVdGLFFBQVFFLFlBQVksR0FBR0c7WUFDbkQ7UUFDRjtJQUNGO0lBQ0EsT0FBTyxDQUFDRTtBQUNWO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1EsV0FBV2pCLE1BQU0sRUFBRXlCLFVBQVU7SUFDcEMsTUFBTUMsUUFBUTFCLE1BQU0sQ0FBQ3lCLFdBQVcsQ0FBQyxFQUFFO0lBQ25DLE1BQU1FLFVBQVUzQixNQUFNLENBQUN5QixXQUFXLENBQUMsRUFBRTtJQUNyQyxJQUFJRyxnQkFBZ0JILGFBQWE7SUFDakMsMEJBQTBCLEdBQzFCLE1BQU1JLGlCQUFpQixFQUFFO0lBQ3pCLE1BQU1DLFlBQ0pKLE1BQU1kLFVBQVUsSUFBSWUsUUFBUUksTUFBTSxDQUFDTCxNQUFNWixXQUFXLENBQUMsQ0FBQ1ksTUFBTUwsS0FBSztJQUNuRSxNQUFNVyxjQUFjRixVQUFVOUIsTUFBTTtJQUNwQyxvQ0FBb0MsR0FDcEMsTUFBTUMsUUFBUSxFQUFFO0lBQ2hCLG1DQUFtQyxHQUNuQyxNQUFNZ0MsT0FBTyxDQUFDO0lBQ2QseUJBQXlCLEdBQ3pCLElBQUlDO0lBQ0osOEJBQThCLEdBQzlCLElBQUlDO0lBQ0osSUFBSWpDLFFBQVEsQ0FBQztJQUNiLDhCQUE4QixHQUM5QixJQUFJa0MsVUFBVVY7SUFDZCxJQUFJVyxTQUFTO0lBQ2IsSUFBSWhCLFFBQVE7SUFDWixNQUFNaUIsU0FBUztRQUFDakI7S0FBTTtJQUV0QixzRUFBc0U7SUFDdEUsZ0JBQWdCO0lBQ2hCLE1BQU9lLFFBQVM7UUFDZCxpREFBaUQ7UUFDakQsTUFBT3BDLE1BQU0sQ0FBQyxFQUFFNEIsY0FBYyxDQUFDLEVBQUUsS0FBS1EsUUFBUztRQUM3QyxTQUFTO1FBQ1g7UUFDQVAsZUFBZVUsSUFBSSxDQUFDWDtRQUNwQixJQUFJLENBQUNRLFFBQVF4QixVQUFVLEVBQUU7WUFDdkJzQixTQUFTUCxRQUFRYSxXQUFXLENBQUNKO1lBQzdCLElBQUksQ0FBQ0EsUUFBUUssSUFBSSxFQUFFO2dCQUNqQlAsT0FBT0ssSUFBSSxDQUFDO1lBQ2Q7WUFDQSxJQUFJSixVQUFVO2dCQUNaTCxVQUFVWSxVQUFVLENBQUNOLFFBQVFmLEtBQUs7WUFDcEM7WUFDQSxJQUFJZSxRQUFRdkIsMkJBQTJCLEVBQUU7Z0JBQ3ZDaUIsVUFBVWEsa0NBQWtDLEdBQUc7WUFDakQ7WUFDQWIsVUFBVWMsS0FBSyxDQUFDVjtZQUNoQixJQUFJRSxRQUFRdkIsMkJBQTJCLEVBQUU7Z0JBQ3ZDaUIsVUFBVWEsa0NBQWtDLEdBQUd4QjtZQUNqRDtRQUNGO1FBRUEsMEJBQTBCO1FBQzFCZ0IsV0FBV0M7UUFDWEEsVUFBVUEsUUFBUUssSUFBSTtJQUN4QjtJQUVBLDZFQUE2RTtJQUM3RSxzQkFBc0I7SUFDdEJMLFVBQVVWO0lBQ1YsTUFBTyxFQUFFeEIsUUFBUThCLFlBQVl0QixNQUFNLENBQUU7UUFDbkMsSUFDRSwyQ0FBMkM7UUFDM0NzQixXQUFXLENBQUM5QixNQUFNLENBQUMsRUFBRSxLQUFLLFVBQzFCOEIsV0FBVyxDQUFDOUIsUUFBUSxFQUFFLENBQUMsRUFBRSxLQUFLLFdBQzlCOEIsV0FBVyxDQUFDOUIsTUFBTSxDQUFDLEVBQUUsQ0FBQ1MsSUFBSSxLQUFLcUIsV0FBVyxDQUFDOUIsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDUyxJQUFJLElBQzdEcUIsV0FBVyxDQUFDOUIsTUFBTSxDQUFDLEVBQUUsQ0FBQ21CLEtBQUssQ0FBQ3dCLElBQUksS0FBS2IsV0FBVyxDQUFDOUIsTUFBTSxDQUFDLEVBQUUsQ0FBQ2tCLEdBQUcsQ0FBQ3lCLElBQUksRUFDbkU7WUFDQXhCLFFBQVFuQixRQUFRO1lBQ2hCb0MsT0FBT0MsSUFBSSxDQUFDbEI7WUFDWixXQUFXO1lBQ1hlLFFBQVF4QixVQUFVLEdBQUdPO1lBQ3JCaUIsUUFBUUQsUUFBUSxHQUFHaEI7WUFDbkJpQixVQUFVQSxRQUFRSyxJQUFJO1FBQ3hCO0lBQ0Y7SUFFQSxXQUFXO0lBQ1hYLFVBQVU5QixNQUFNLEdBQUcsRUFBRTtJQUVyQix5RUFBeUU7SUFDekUsMkRBQTJEO0lBQzNELHNFQUFzRTtJQUN0RSxJQUFJb0MsU0FBUztRQUNYLFdBQVc7UUFDWEEsUUFBUXhCLFVBQVUsR0FBR087UUFDckJpQixRQUFRRCxRQUFRLEdBQUdoQjtJQUNyQixPQUFPO1FBQ0xtQixPQUFPUSxHQUFHO0lBQ1o7SUFFQSx1RUFBdUU7SUFDdkUsK0RBQStEO0lBQy9ENUMsUUFBUW9DLE9BQU81QixNQUFNO0lBQ3JCLE1BQU9SLFFBQVM7UUFDZCxNQUFNb0IsUUFBUVUsWUFBWVYsS0FBSyxDQUFDZ0IsTUFBTSxDQUFDcEMsTUFBTSxFQUFFb0MsTUFBTSxDQUFDcEMsUUFBUSxFQUFFO1FBQ2hFLE1BQU1tQixRQUFRUSxlQUFlaUIsR0FBRztRQUNoQzdDLE1BQU1zQixPQUFPLENBQUM7WUFBQ0Y7WUFBT0EsUUFBUUMsTUFBTVosTUFBTSxHQUFHO1NBQUU7UUFDL0NjLElBQUFBLDRCQUFNLEVBQUN4QixRQUFRcUIsT0FBTyxHQUFHQztJQUMzQjtJQUNBcEIsUUFBUSxDQUFDO0lBQ1QsTUFBTyxFQUFFQSxRQUFRRCxNQUFNUyxNQUFNLENBQUU7UUFDN0J1QixJQUFJLENBQUNJLFNBQVNwQyxLQUFLLENBQUNDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBR21DLFNBQVNwQyxLQUFLLENBQUNDLE1BQU0sQ0FBQyxFQUFFO1FBQ3pEbUMsVUFBVXBDLEtBQUssQ0FBQ0MsTUFBTSxDQUFDLEVBQUUsR0FBR0QsS0FBSyxDQUFDQyxNQUFNLENBQUMsRUFBRSxHQUFHO0lBQ2hEO0lBQ0EsT0FBTytCO0FBQ1QifQ==