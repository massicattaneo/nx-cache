{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\n\n/**\n * Create an HTML extension for `micromark` to support GFM task list items\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM task list items when serializing to HTML.\n */\nexport function gfmTaskListItem() {\n  return {\n    text: {\n      [91]: tasklistCheck\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n      // Exit if there’s stuff before.\n      self.previous !== null ||\n      // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n    return nok(code)\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code)\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )(code)\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, 'whitespace')\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means there’s content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code)\n  }\n}\n"],"names":["gfmTaskListItem","tasklistCheck","tokenize","tokenizeTasklistCheck","text","effects","ok","nok","self","open","code","previous","_gfmTasklistFirstContentOfListItem","enter","consume","exit","inside","markdownLineEndingOrSpace","close","after","markdownLineEnding","markdownSpace","check","spaceThenNonSpace","factorySpace"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;;;CAKC;;;;+BAoBeA;;;eAAAA;;;uCAlBW;wCAKpB;AACP,MAAMC,gBAAgB;IACpBC,UAAUC;AACZ;AAUO,SAASH;IACd,OAAO;QACLI,MAAM;YACJ,CAAC,GAAG,EAAEH;QACR;IACF;AACF;AAEA;;;CAGC,GACD,SAASE,sBAAsBE,OAAO,EAAEC,EAAE,EAAEC,GAAG;IAC7C,MAAMC,OAAO,IAAI;IACjB,OAAOC;IAEP;;;;;;;;;GASC,GACD,SAASA,KAAKC,IAAI;QAChB,IACE,gCAAgC;QAChCF,KAAKG,QAAQ,KAAK,QAClB,qEAAqE;QACrE,QAAQ;QACR,CAACH,KAAKI,kCAAkC,EACxC;YACA,OAAOL,IAAIG;QACb;QACAL,QAAQQ,KAAK,CAAC;QACdR,QAAQQ,KAAK,CAAC;QACdR,QAAQS,OAAO,CAACJ;QAChBL,QAAQU,IAAI,CAAC;QACb,OAAOC;IACT;IAEA;;;;;;;;;GASC,GACD,SAASA,OAAON,IAAI;QAClB,4CAA4C;QAC5C,2EAA2E;QAC3E,gDAAgD;QAChD,IAAIO,IAAAA,iDAAyB,EAACP,OAAO;YACnCL,QAAQQ,KAAK,CAAC;YACdR,QAAQS,OAAO,CAACJ;YAChBL,QAAQU,IAAI,CAAC;YACb,OAAOG;QACT;QACA,IAAIR,SAAS,MAAMA,SAAS,KAAK;YAC/BL,QAAQQ,KAAK,CAAC;YACdR,QAAQS,OAAO,CAACJ;YAChBL,QAAQU,IAAI,CAAC;YACb,OAAOG;QACT;QACA,OAAOX,IAAIG;IACb;IAEA;;;;;;;;;GASC,GACD,SAASQ,MAAMR,IAAI;QACjB,IAAIA,SAAS,IAAI;YACfL,QAAQQ,KAAK,CAAC;YACdR,QAAQS,OAAO,CAACJ;YAChBL,QAAQU,IAAI,CAAC;YACbV,QAAQU,IAAI,CAAC;YACb,OAAOI;QACT;QACA,OAAOZ,IAAIG;IACb;IAEA;;GAEC,GACD,SAASS,MAAMT,IAAI;QACjB,gEAAgE;QAChE,IAAIU,IAAAA,0CAAkB,EAACV,OAAO;YAC5B,OAAOJ,GAAGI;QACZ;QAEA,gBAAgB;QAChB,0BAA0B;QAC1B,IAAIW,IAAAA,qCAAa,EAACX,OAAO;YACvB,OAAOL,QAAQiB,KAAK,CAClB;gBACEpB,UAAUqB;YACZ,GACAjB,IACAC,KACAG;QACJ;QAEA,sCAAsC;QACtC,OAAOH,IAAIG;IACb;AACF;AAEA;;;CAGC,GACD,SAASa,kBAAkBlB,OAAO,EAAEC,EAAE,EAAEC,GAAG;IACzC,OAAOiB,IAAAA,mCAAY,EAACnB,SAASc,OAAO;IAEpC;;;;;;;;;GASC,GACD,SAASA,MAAMT,IAAI;QACjB,uCAAuC;QACvC,+CAA+C;QAC/C,kCAAkC;QAClC,yBAAyB;QACzB,OAAOA,SAAS,OAAOH,IAAIG,QAAQJ,GAAGI;IACxC;AACF"}