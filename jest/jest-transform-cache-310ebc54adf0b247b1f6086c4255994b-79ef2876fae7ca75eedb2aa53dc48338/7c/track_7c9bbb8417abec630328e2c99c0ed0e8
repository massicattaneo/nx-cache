0c1db3adc5ebd57818d2a362a0572b3c
/**
 * @typedef {import('../types.js').CreateTracker} CreateTracker
 * @typedef {import('../types.js').TrackCurrent} TrackCurrent
 * @typedef {import('../types.js').TrackMove} TrackMove
 * @typedef {import('../types.js').TrackShift} TrackShift
 */ /**
 * Track positional info in the output.
 *
 * @type {CreateTracker}
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "track", {
    enumerable: true,
    get: function() {
        return track;
    }
});
function track(config) {
    // Defaults are used to prevent crashes when older utilities somehow activate
    // this code.
    /* c8 ignore next 5 */ const options = config || {};
    const now = options.now || {};
    let lineShift = options.lineShift || 0;
    let line = now.line || 1;
    let column = now.column || 1;
    return {
        move,
        current,
        shift
    };
    /**
   * Get the current tracked info.
   *
   * @type {TrackCurrent}
   */ function current() {
        return {
            now: {
                line,
                column
            },
            lineShift
        };
    }
    /**
   * Define an increased line shift (the typical indent for lines).
   *
   * @type {TrackShift}
   */ function shift(value) {
        lineShift += value;
    }
    /**
   * Move past some generated markdown.
   *
   * @type {TrackMove}
   */ function move(input) {
        // eslint-disable-next-line unicorn/prefer-default-parameters
        const value = input || '';
        const chunks = value.split(/\r?\n|\r/g);
        const tail = chunks[chunks.length - 1];
        line += chunks.length - 1;
        column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
        return value;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3RyYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5DcmVhdGVUcmFja2VyfSBDcmVhdGVUcmFja2VyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLlRyYWNrQ3VycmVudH0gVHJhY2tDdXJyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLlRyYWNrTW92ZX0gVHJhY2tNb3ZlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLlRyYWNrU2hpZnR9IFRyYWNrU2hpZnRcbiAqL1xuXG4vKipcbiAqIFRyYWNrIHBvc2l0aW9uYWwgaW5mbyBpbiB0aGUgb3V0cHV0LlxuICpcbiAqIEB0eXBlIHtDcmVhdGVUcmFja2VyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhY2soY29uZmlnKSB7XG4gIC8vIERlZmF1bHRzIGFyZSB1c2VkIHRvIHByZXZlbnQgY3Jhc2hlcyB3aGVuIG9sZGVyIHV0aWxpdGllcyBzb21laG93IGFjdGl2YXRlXG4gIC8vIHRoaXMgY29kZS5cbiAgLyogYzggaWdub3JlIG5leHQgNSAqL1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnIHx8IHt9XG4gIGNvbnN0IG5vdyA9IG9wdGlvbnMubm93IHx8IHt9XG4gIGxldCBsaW5lU2hpZnQgPSBvcHRpb25zLmxpbmVTaGlmdCB8fCAwXG4gIGxldCBsaW5lID0gbm93LmxpbmUgfHwgMVxuICBsZXQgY29sdW1uID0gbm93LmNvbHVtbiB8fCAxXG5cbiAgcmV0dXJuIHttb3ZlLCBjdXJyZW50LCBzaGlmdH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHRyYWNrZWQgaW5mby5cbiAgICpcbiAgICogQHR5cGUge1RyYWNrQ3VycmVudH1cbiAgICovXG4gIGZ1bmN0aW9uIGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHtub3c6IHtsaW5lLCBjb2x1bW59LCBsaW5lU2hpZnR9XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGFuIGluY3JlYXNlZCBsaW5lIHNoaWZ0ICh0aGUgdHlwaWNhbCBpbmRlbnQgZm9yIGxpbmVzKS5cbiAgICpcbiAgICogQHR5cGUge1RyYWNrU2hpZnR9XG4gICAqL1xuICBmdW5jdGlvbiBzaGlmdCh2YWx1ZSkge1xuICAgIGxpbmVTaGlmdCArPSB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgcGFzdCBzb21lIGdlbmVyYXRlZCBtYXJrZG93bi5cbiAgICpcbiAgICogQHR5cGUge1RyYWNrTW92ZX1cbiAgICovXG4gIGZ1bmN0aW9uIG1vdmUoaW5wdXQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItZGVmYXVsdC1wYXJhbWV0ZXJzXG4gICAgY29uc3QgdmFsdWUgPSBpbnB1dCB8fCAnJ1xuICAgIGNvbnN0IGNodW5rcyA9IHZhbHVlLnNwbGl0KC9cXHI/XFxufFxcci9nKVxuICAgIGNvbnN0IHRhaWwgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdXG4gICAgbGluZSArPSBjaHVua3MubGVuZ3RoIC0gMVxuICAgIGNvbHVtbiA9XG4gICAgICBjaHVua3MubGVuZ3RoID09PSAxID8gY29sdW1uICsgdGFpbC5sZW5ndGggOiAxICsgdGFpbC5sZW5ndGggKyBsaW5lU2hpZnRcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuIl0sIm5hbWVzIjpbInRyYWNrIiwiY29uZmlnIiwib3B0aW9ucyIsIm5vdyIsImxpbmVTaGlmdCIsImxpbmUiLCJjb2x1bW4iLCJtb3ZlIiwiY3VycmVudCIsInNoaWZ0IiwidmFsdWUiLCJpbnB1dCIsImNodW5rcyIsInNwbGl0IiwidGFpbCIsImxlbmd0aCJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FFRDs7OztDQUlDOzs7OytCQUNlQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxNQUFNQyxNQUFNO0lBQzFCLDZFQUE2RTtJQUM3RSxhQUFhO0lBQ2Isb0JBQW9CLEdBQ3BCLE1BQU1DLFVBQVVELFVBQVUsQ0FBQztJQUMzQixNQUFNRSxNQUFNRCxRQUFRQyxHQUFHLElBQUksQ0FBQztJQUM1QixJQUFJQyxZQUFZRixRQUFRRSxTQUFTLElBQUk7SUFDckMsSUFBSUMsT0FBT0YsSUFBSUUsSUFBSSxJQUFJO0lBQ3ZCLElBQUlDLFNBQVNILElBQUlHLE1BQU0sSUFBSTtJQUUzQixPQUFPO1FBQUNDO1FBQU1DO1FBQVNDO0lBQUs7SUFFNUI7Ozs7R0FJQyxHQUNELFNBQVNEO1FBQ1AsT0FBTztZQUFDTCxLQUFLO2dCQUFDRTtnQkFBTUM7WUFBTTtZQUFHRjtRQUFTO0lBQ3hDO0lBRUE7Ozs7R0FJQyxHQUNELFNBQVNLLE1BQU1DLEtBQUs7UUFDbEJOLGFBQWFNO0lBQ2Y7SUFFQTs7OztHQUlDLEdBQ0QsU0FBU0gsS0FBS0ksS0FBSztRQUNqQiw2REFBNkQ7UUFDN0QsTUFBTUQsUUFBUUMsU0FBUztRQUN2QixNQUFNQyxTQUFTRixNQUFNRyxLQUFLLENBQUM7UUFDM0IsTUFBTUMsT0FBT0YsTUFBTSxDQUFDQSxPQUFPRyxNQUFNLEdBQUcsRUFBRTtRQUN0Q1YsUUFBUU8sT0FBT0csTUFBTSxHQUFHO1FBQ3hCVCxTQUNFTSxPQUFPRyxNQUFNLEtBQUssSUFBSVQsU0FBU1EsS0FBS0MsTUFBTSxHQUFHLElBQUlELEtBQUtDLE1BQU0sR0FBR1g7UUFDakUsT0FBT007SUFDVDtBQUNGIn0=