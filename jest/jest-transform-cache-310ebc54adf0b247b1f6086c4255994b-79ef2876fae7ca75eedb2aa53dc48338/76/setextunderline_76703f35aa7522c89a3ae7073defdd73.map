{"version":3,"sources":["/Users/mcattaneo/workspace/frontend/node_modules/micromark-core-commonmark/lib/setext-underline.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length\n  /** @type {number | undefined} */\n  let content\n  /** @type {number | undefined} */\n  let text\n  /** @type {number | undefined} */\n  let definition\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = 'setextHeadingText'\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context])\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length\n    /** @type {boolean | undefined} */\n    let paragraph\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (\n        self.events[index][1].type !== 'lineEnding' &&\n        self.events[index][1].type !== 'linePrefix' &&\n        self.events[index][1].type !== 'content'\n      ) {\n        paragraph = self.events[index][1].type === 'paragraph'\n        break\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      marker = code\n      return before(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('setextHeadingLineSequence')\n    return inside(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n    effects.exit('setextHeadingLineSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, after, 'lineSuffix')(code)\n      : after(code)\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n"],"names":["setextUnderline","name","tokenize","tokenizeSetextUnderline","resolveTo","resolveToSetextUnderline","events","context","index","length","content","text","definition","type","splice","heading","start","Object","assign","end","push","effects","ok","nok","self","marker","code","paragraph","parser","lazy","now","line","interrupt","enter","before","inside","consume","exit","markdownSpace","factorySpace","after","markdownLineEnding"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}