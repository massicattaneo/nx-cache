1644787bcd1f4135eed628f669820c3f
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "onSmartGridSummary", {
    enumerable: true,
    get: function() {
        return onSmartGridSummary;
    }
});
const _hooks = require("@rp/react/common/hooks");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
const isCollapsableBlock = (block)=>{
    return block.type === "COLLAPSE";
};
function onSmartGridSummary(setSmartGridColumns) {
    return function(summary, status, chatId) {
        const { chunkMap, externalMap } = (0, _hooks.createChunkMap)(summary.auditTraces || [], summary.originSources);
        setSmartGridColumns((prev)=>{
            const col = prev.find((c)=>c.chatId === chatId);
            if (col) {
                var _col_rows;
                const rows = Object.entries((_col_rows = col.rows) !== null && _col_rows !== void 0 ? _col_rows : {}).reduce((acc, [key, row])=>{
                    var _summary_auditBlocks_filter_find;
                    const value = (_summary_auditBlocks_filter_find = summary.auditBlocks.filter(isCollapsableBlock).find((item)=>item.title === row.cqsName)) === null || _summary_auditBlocks_filter_find === void 0 ? void 0 : _summary_auditBlocks_filter_find.content.value;
                    const rawValue = (value === null || value === void 0 ? void 0 : value.trim().includes("No relevant information found for")) ? undefined : value;
                    const isLoading = !rawValue && !(status === "COMPLETED" || status === "ERROR");
                    return _object_spread_props(_object_spread({}, acc), {
                        [key]: _object_spread_props(_object_spread({}, row), {
                            isLoading,
                            value: rawValue,
                            isError: status === "ERROR"
                        })
                    });
                }, {});
                Object.assign(col, {
                    rows,
                    chunkMap,
                    externalMap,
                    status
                });
            }
            return [
                ...prev
            ];
        });
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tY2F0dGFuZW8vd29ya3NwYWNlL2Zyb250ZW5kL2xpYnMvcmVhY3Qvd2ViL3dhdGNobGlzdHMvc3JjL2xpYi9XYXRjaGxpc3RTbWFydEdyaWQvb25TbWFydEdyaWRTdW1tYXJ5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpc3BhdGNoLCBTZXRTdGF0ZUFjdGlvbiB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBTdW1tYXJ5U3RhdGUsIFN1bW1hcnlTdGF0dXMsIGNyZWF0ZUNodW5rTWFwIH0gZnJvbSBcIkBycC9yZWFjdC9jb21tb24vaG9va3NcIlxuaW1wb3J0IHsgQ29sbGFwc2FibGVCbG9jayB9IGZyb20gXCJAcnAvcmVhY3QvdGFuc3RhY2stYXBpL2xsbS1zdW1tYXJ5XCJcbmltcG9ydCB7IFNtYXJ0R3JpZENvbHVtbiwgU21hcnRHcmlkUm93IH0gZnJvbSBcIi4vV2F0Y2hsaXN0U21hcnRHcmlkXCJcblxuY29uc3QgaXNDb2xsYXBzYWJsZUJsb2NrID0gKFxuICBibG9jazogU3VtbWFyeVN0YXRlW1wiYXVkaXRCbG9ja3NcIl1bbnVtYmVyXSxcbik6IGJsb2NrIGlzIENvbGxhcHNhYmxlQmxvY2sgPT4ge1xuICByZXR1cm4gYmxvY2sudHlwZSA9PT0gXCJDT0xMQVBTRVwiXG59XG5cbmZ1bmN0aW9uIG9uU21hcnRHcmlkU3VtbWFyeShzZXRTbWFydEdyaWRDb2x1bW5zOiBEaXNwYXRjaDxTZXRTdGF0ZUFjdGlvbjxBcnJheTxTbWFydEdyaWRDb2x1bW4+Pj4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdW1tYXJ5OiBTdW1tYXJ5U3RhdGUsIHN0YXR1czogU3VtbWFyeVN0YXR1cywgY2hhdElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGNodW5rTWFwLCBleHRlcm5hbE1hcCB9ID0gY3JlYXRlQ2h1bmtNYXAoXG4gICAgICBzdW1tYXJ5LmF1ZGl0VHJhY2VzIHx8IFtdLFxuICAgICAgc3VtbWFyeS5vcmlnaW5Tb3VyY2VzLFxuICAgIClcbiAgICBzZXRTbWFydEdyaWRDb2x1bW5zKHByZXYgPT4ge1xuICAgICAgY29uc3QgY29sID0gcHJldi5maW5kKGMgPT4gYy5jaGF0SWQgPT09IGNoYXRJZClcbiAgICAgIGlmIChjb2wpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IE9iamVjdC5lbnRyaWVzKGNvbC5yb3dzID8/IHt9KS5yZWR1Y2UoKGFjYywgW2tleSwgcm93XSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3VtbWFyeS5hdWRpdEJsb2Nrc1xuICAgICAgICAgICAgLmZpbHRlcihpc0NvbGxhcHNhYmxlQmxvY2spXG4gICAgICAgICAgICAuZmluZChpdGVtID0+IGl0ZW0udGl0bGUgPT09IHJvdy5jcXNOYW1lKT8uY29udGVudC52YWx1ZVxuICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gdmFsdWU/LnRyaW0oKS5pbmNsdWRlcyhcIk5vIHJlbGV2YW50IGluZm9ybWF0aW9uIGZvdW5kIGZvclwiKVxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICBjb25zdCBpc0xvYWRpbmcgPSAhcmF3VmFsdWUgJiYgIShzdGF0dXMgPT09IFwiQ09NUExFVEVEXCIgfHwgc3RhdHVzID09PSBcIkVSUk9SXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIFtrZXldOiB7XG4gICAgICAgICAgICAgIC4uLnJvdyxcbiAgICAgICAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICAgICAgICB2YWx1ZTogcmF3VmFsdWUsXG4gICAgICAgICAgICAgIGlzRXJyb3I6IHN0YXR1cyA9PT0gXCJFUlJPUlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIFNtYXJ0R3JpZFJvdz4pXG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29sLCB7XG4gICAgICAgICAgcm93cyxcbiAgICAgICAgICBjaHVua01hcCxcbiAgICAgICAgICBleHRlcm5hbE1hcCxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gWy4uLnByZXZdXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgeyBvblNtYXJ0R3JpZFN1bW1hcnkgfVxuIl0sIm5hbWVzIjpbIm9uU21hcnRHcmlkU3VtbWFyeSIsImlzQ29sbGFwc2FibGVCbG9jayIsImJsb2NrIiwidHlwZSIsInNldFNtYXJ0R3JpZENvbHVtbnMiLCJzdW1tYXJ5Iiwic3RhdHVzIiwiY2hhdElkIiwiY2h1bmtNYXAiLCJleHRlcm5hbE1hcCIsImNyZWF0ZUNodW5rTWFwIiwiYXVkaXRUcmFjZXMiLCJvcmlnaW5Tb3VyY2VzIiwicHJldiIsImNvbCIsImZpbmQiLCJjIiwicm93cyIsIk9iamVjdCIsImVudHJpZXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJyb3ciLCJ2YWx1ZSIsImF1ZGl0QmxvY2tzIiwiZmlsdGVyIiwiaXRlbSIsInRpdGxlIiwiY3FzTmFtZSIsImNvbnRlbnQiLCJyYXdWYWx1ZSIsInRyaW0iLCJpbmNsdWRlcyIsInVuZGVmaW5lZCIsImlzTG9hZGluZyIsImlzRXJyb3IiLCJhc3NpZ24iXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwibWFwcGluZ3MiOiI7Ozs7K0JBa0RTQTs7O2VBQUFBOzs7dUJBakRtRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJNUQsTUFBTUMscUJBQXFCLENBQ3pCQztJQUVBLE9BQU9BLE1BQU1DLElBQUksS0FBSztBQUN4QjtBQUVBLFNBQVNILG1CQUFtQkksbUJBQXFFO0lBQy9GLE9BQU8sU0FBVUMsT0FBcUIsRUFBRUMsTUFBcUIsRUFBRUMsTUFBYztRQUMzRSxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsV0FBVyxFQUFFLEdBQUdDLElBQUFBLHFCQUFjLEVBQzlDTCxRQUFRTSxXQUFXLElBQUksRUFBRSxFQUN6Qk4sUUFBUU8sYUFBYTtRQUV2QlIsb0JBQW9CUyxDQUFBQTtZQUNsQixNQUFNQyxNQUFNRCxLQUFLRSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVULE1BQU0sS0FBS0E7WUFDeEMsSUFBSU8sS0FBSztvQkFDcUJBO2dCQUE1QixNQUFNRyxPQUFPQyxPQUFPQyxPQUFPLENBQUNMLENBQUFBLFlBQUFBLElBQUlHLElBQUksY0FBUkgsdUJBQUFBLFlBQVksQ0FBQyxHQUFHTSxNQUFNLENBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxLQUFLQyxJQUFJO3dCQUNuRGxCO29CQUFkLE1BQU1tQixTQUFRbkIsbUNBQUFBLFFBQVFvQixXQUFXLENBQzlCQyxNQUFNLENBQUN6QixvQkFDUGMsSUFBSSxDQUFDWSxDQUFBQSxPQUFRQSxLQUFLQyxLQUFLLEtBQUtMLElBQUlNLE9BQU8sZUFGNUJ4Qix1REFBQUEsaUNBRStCeUIsT0FBTyxDQUFDTixLQUFLO29CQUMxRCxNQUFNTyxXQUFXUCxDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU9RLElBQUksR0FBR0MsUUFBUSxDQUFDLHdDQUNwQ0MsWUFDQVY7b0JBQ0osTUFBTVcsWUFBWSxDQUFDSixZQUFZLENBQUV6QixDQUFBQSxXQUFXLGVBQWVBLFdBQVcsT0FBTTtvQkFDNUUsT0FBTyx3Q0FDRmU7d0JBQ0gsQ0FBQ0MsSUFBSSxFQUFFLHdDQUNGQzs0QkFDSFk7NEJBQ0FYLE9BQU9POzRCQUNQSyxTQUFTOUIsV0FBVzs7O2dCQUcxQixHQUFHLENBQUM7Z0JBQ0pZLE9BQU9tQixNQUFNLENBQUN2QixLQUFLO29CQUNqQkc7b0JBQ0FUO29CQUNBQztvQkFDQUg7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU87bUJBQUlPO2FBQUs7UUFDbEI7SUFDRjtBQUNGIn0=